WEBVTT

00:02.840 --> 00:04.730
Alors pourquoi faire des tests unitaires ?

00:04.880 --> 00:06.200
J'aime bien commencer par cette citation.

00:06.200 --> 00:07.050
Je vais la lire ici.

00:07.070 --> 00:14.150
Chaque décision que nous prenons, qu'il s'agisse de technologie, de processus ou de personnes, peut être considérée comme une forme d'investissement.

00:14.510 --> 00:19.040
Ces investissements ont un coût et nous sommes convaincus qu'ils seront rentables.

00:19.250 --> 00:24.950
Si vous êtes déjà familiarisé avec le développement de jeux et que vous êtes en mesure d'obtenir certaines fonctionnalités

00:24.950 --> 00:29.480
que vous avez en tête dans les projets et les partager avec les joueurs qui jouent à votre jeu,

00:29.480 --> 00:32.520
il se peut que la valeur des tests unitaires ne soit pas tout à fait claire.

00:32.540 --> 00:38.060
Les tests unitaires doivent avant tout être considérés comme une activité facultative que vous pouvez ajouter à votre jeu.

00:38.060 --> 00:39.640
à votre code de production.

00:39.650 --> 00:47.210
D'une certaine manière, vos utilisateurs finaux ne voient jamais cette fonctionnalité, mais l'idée et les avantages qui en découlent sont les suivants

00:47.210 --> 00:53.960
Nous espérons que les tests unitaires, et en particulier le développement piloté par les tests, nous permettront de rentabiliser cet investissement.

00:53.990 --> 01:01.010
Nous aurons des classes et des systèmes qui fonctionneront de manière plus fiable, qui seront plus robustes, mais qui seront aussi plus sûrs.

01:01.010 --> 01:08.330
moins sujettes aux erreurs et qui vous permettront d'ajouter plus de fonctionnalités pour vos utilisateurs à un rythme plus rapide et plus sûr.

01:08.330 --> 01:11.670
avec les tests unitaires comme l'une de vos compétences.

01:11.690 --> 01:15.190
Dans le monde des tests unitaires, il existe de nombreux termes différents.

01:15.200 --> 01:18.320
Je vais vous en lire quelques-uns.

01:18.320 --> 01:23.660
Composition et abstraction, se référant à la façon dont vos classes et vos architectures peuvent s'adapter.

01:23.660 --> 01:24.470
ensemble.

01:24.710 --> 01:29.120
Les classes et les méthodes sont des éléments fondamentaux de la programmation orientée objet.

01:29.120 --> 01:34.630
Puis des choses comme mock et assertion et range act et assert aussi.

01:34.640 --> 01:37.850
Ce sont des choses qui se réfèrent spécifiquement aux tests unitaires.

01:37.850 --> 01:42.500
Nous allons couvrir de manière informelle tous les termes que nous voyons ici.

01:42.500 --> 01:44.810
Nous allons probablement les aborder maintenant dans la dernière partie.

01:44.810 --> 01:46.040
Le développement professionnel.

01:46.040 --> 01:52.010
Lorsque vous commencez en tant que développeur de jeux à l'intérieur d'unity, en apprenant l'outil unity, en apprenant la théorie

01:52.010 --> 01:56.840
derrière unity et bien sûr le codage en C-sharp, vous remarquez que vous obtenez votre diplôme.

01:56.840 --> 02:01.700
Les concepts deviennent de plus en plus complexes au fur et à mesure que vous abordez ces différents sujets.

02:01.730 --> 02:06.050
Des choses comme les classes dans la POO, qui sont des choses que vous apprenez tôt dans le développement.

02:06.050 --> 02:13.340
Plus tard dans votre carrière, vous vous concentrerez davantage sur la modularité de vos projets, leur réutilisation, l'ajout de nouvelles fonctionnalités, etc.

02:13.370 --> 02:18.800
des tests, ce qui est l'essentiel ici, et parler en grande partie de l'architecture de vos projets.

02:18.830 --> 02:25.460
Le signe d'un projet bien architecturé est qu'au moment d'ajouter la 101e fonctionnalité, il n'est pas nécessaire d'ajouter une nouvelle fonctionnalité.

02:25.460 --> 02:26.900
ne brise pas tout ce que vous avez déjà.

02:26.930 --> 02:33.050
Nous voyons ici l'un des parcours possibles d'un développeur junior au cours de sa carrière.

02:33.050 --> 02:38.600
Il est particulièrement intéressant de constater que les compétences dont nous parlons ici sont vraiment celles qui font évoluer

02:38.600 --> 02:42.890
d'un développeur débutant à un développeur junior, puis à un développeur senior.

02:42.890 --> 02:49.070
Ce sont vraiment ces types de connaissances pratiques que vous ajoutez à votre ensemble de compétences qui vous aideront à

02:49.070 --> 02:55.040
à obtenir une promotion dans votre fonction actuelle, ou à trouver de nouvelles fonctions et possibilités de contribution dans d'autres domaines.

02:55.040 --> 02:55.790
équipes.

02:55.820 --> 03:02.030
Toutes les équipes n'utilisent pas les tests unitaires dans le monde de la programmation, et je pense que c'est particulièrement le cas dans le développement de jeux,

03:02.030 --> 03:07.670
On ne les trouve pas aussi souvent qu'avec d'autres plates-formes et paradigmes de programmation, mais c'est le cas.

03:07.670 --> 03:08.870
tout aussi important ici.

03:08.870 --> 03:11.150
Voyons pourquoi les tests unitaires sont importants.

03:11.150 --> 03:12.460
Je vais lire ici.

03:12.470 --> 03:19.100
Au fur et à mesure que votre projet s'enrichit de scripts, de classes et de méthodes, il devient difficile de s'assurer que les tests unitaires sont effectués.

03:19.100 --> 03:23.810
qu'un changement dans une partie de votre code ne casse pas quelque chose ailleurs.

03:23.900 --> 03:28.850
Les tests automatisés vous aident à vérifier que votre code fonctionne comme prévu.

03:29.150 --> 03:35.870
Les tests permettent de gagner du temps en trouvant où et quand les problèmes surviennent dès qu'ils sont introduits dans le développement,

03:35.870 --> 03:42.290
plutôt que de s'appuyer sur des tests manuels, ou même sur l'attente, plus coûteuse, de vos utilisateurs finaux, de vos clients et de vos partenaires.

03:42.290 --> 03:47.030
joueurs pour signaler un bogue, parlons un peu de la valeur de la détection précoce des erreurs.

03:47.030 --> 03:54.410
En tant que développeurs, nous sommes nombreux à penser que le processus de développement d'un jeu se résume à l'ajout de nouvelles fonctionnalités.

03:54.410 --> 03:59.540
et pensent que plus vous les ajoutez rapidement, plus vous offrez de valeur à vos utilisateurs finaux.

03:59.570 --> 04:05.300
Bien que ce soit une façon amusante de commencer un projet, nous connaissons tous les résultats qui découlent de l'ajout de fonctionnalités.

04:05.300 --> 04:13.160
trop rapidement au début du développement, en particulier sur une base de code qui n'est pas bien conçue, bien architecturée

04:13.160 --> 04:14.210
ou bien testée.

04:14.210 --> 04:21.620
Les recherches menées dans l'industrie du développement de jeux illustrent la règle des 80 sur 20, selon laquelle 80 % des projets de développement de jeux sont des projets de développement de jeux.

04:21.620 --> 04:25.250
développement proviennent de seulement 20 % de vos fonctionnalités.

04:25.250 --> 04:29.780
La complexité de base se situe souvent dans un coin étroit de la base de code.

04:29.780 --> 04:36.080
Le projet, l'organisation ou le manque d'organisation peuvent être à l'origine de problèmes récurrents considérables.

04:36.110 --> 04:42.050
Vous finissez par lutter contre les mêmes vieux incendies, encore et encore, parce que vous n'avez pas la conception et l'organisation nécessaires.

04:42.050 --> 04:46.070
d'essais pour prouver que cette zone est développée en toute confiance.

04:47.120 --> 04:49.770
80 % du temps de développement est consacré à la maintenance du code.

04:49.790 --> 04:55.190
C'est une chose effrayante à entendre, mais c'est ce que nous voyons sur les grandes bases de code.

04:55.220 --> 05:01.100
Imaginez que vous livriez un jeu en six mois et que vous le souteniez pendant 1 ou 2 ans de plus pendant que vous faites le bug.

05:01.100 --> 05:03.210
corrections de bugs et l'ajout de nouvelles fonctionnalités.

05:03.230 --> 05:05.800
C'est un exemple de jeu très simple.

05:05.810 --> 05:12.020
Même dans ce processus, nous constatons que 80 % du temps que vous passez en tant que développeur n'est pas consacré à l'ajout de ces fonctionnalités.

05:12.020 --> 05:12.890
nouvelles fonctionnalités.

05:12.890 --> 05:20.030
Il s'agit d'identifier et de trouver des bogues dans les anciens systèmes et de procéder à des remaniements au cours des six premiers mois.

05:20.060 --> 05:24.050
L'architecture peut ne pas correspondre au deuxième semestre de l'architecture.

05:24.080 --> 05:29.300
Votre projet va se développer et votre équipe va apprendre, vous allez donc procéder à des changements

05:29.300 --> 05:30.150
en cours de route.

05:30.170 --> 05:31.430
Aucun problème.

05:31.460 --> 05:33.950
Ces changements sont souvent appelés "refactoring".

05:33.950 --> 05:39.860
La refonte consiste à rendre votre code plus efficace tout en offrant la même valeur à vos clients finaux.

05:39.890 --> 05:45.530
Chaque refactorisation vous permet d'avoir un nouveau point de départ pour ajouter de nouvelles fonctionnalités.

05:45.530 --> 05:52.460
Ce que nous voyons ici, c'est qu'en établissant de bonnes pratiques en matière de tests, cela va contribuer à ce que

05:52.460 --> 05:56.450
la maintenance du code, cela va aider les 80% où nous passons une grande partie de notre temps.

05:56.450 --> 06:02.480
Et comme je l'ai déjà mentionné, voyons ici que le coût des bogues logiciels augmente avec le temps.

06:02.480 --> 06:08.420
Cette tranche de recherche particulière montre que si vous discutez avec un collègue des points suivants

06:08.420 --> 06:13.250
d'un jeu et que l'un d'entre vous signale un problème, il le corrige,

06:13.280 --> 06:15.420
Cette conversation est très bon marché.

06:15.440 --> 06:22.340
Appelons cela une x quantité de temps et d'efforts très faible au fur et à mesure que vous la mettez en œuvre.

06:22.340 --> 06:28.430
projet, trouver ce même bogue après l'avoir codé, c'est plus difficile à trouver et plus difficile

06:28.430 --> 06:30.860
de le corriger et de s'assurer que vous le corrigez.

06:30.860 --> 06:36.860
Une fois que vous avez effectué vos tests, vous les transmettez à vos clients pour qu'ils les testent, puis vous les expédiez.

06:36.860 --> 06:38.400
à vos joueurs finaux.

06:38.420 --> 06:41.000
Imaginez qu'un joueur rencontre le même problème.

06:41.030 --> 06:44.330
Il devra être déçu.

06:44.330 --> 06:47.510
Peut-être que cela affecte négativement l'idée qu'ils se font du jeu.

06:47.510 --> 06:50.060
Il se peut même que vous les perdiez en tant que joueur.

06:50.060 --> 06:55.400
Mais s'il s'agit d'une personne qui s'exprime et que vous disposez d'un bon canal d'assistance à la clientèle et qu'elle envoie son message,

06:55.430 --> 07:00.950
il entre dans votre système de tickets de bogues, finit par être assigné, finit par être corrigé, peut-être qu'il

07:00.950 --> 07:06.950
est ou n'est pas corrigé correctement, puis vous envoyez cette mise à jour aux utilisateurs finaux, en espérant qu'elle leur sera utile.

07:06.980 --> 07:08.270
ont été pris en compte.

07:08.300 --> 07:09.590
C'est beaucoup plus cher.

07:09.590 --> 07:10.210
A la fin.

07:10.220 --> 07:15.480
Nous allons voir que les tests unitaires nous permettent, tout d'abord, de mieux concevoir nos logiciels.

07:15.500 --> 07:22.550
Deuxièmement, mettre des tests dans son projet pour que ces tests automatisés trouvent le bug plus tôt.

07:22.550 --> 07:28.130
Peut-être que dans la phase d'intégration, comme nous le voyons ici, ce n'est pas aussi bien que de le corriger dans la première phase d'intégration.

07:28.130 --> 07:32.240
conversation, mais c'est beaucoup mieux que d'attendre que le projet soit publié.

07:32.480 --> 07:38.090
Certaines des meilleures pratiques mises en évidence ici sont la création d'un code facile à maintenir, l'augmentation de la productivité et la réduction des coûts.

07:38.090 --> 07:44.150
l'automatisation et les tests de votre code, la détection précoce et fréquente des bogues et leur correction.

07:44.150 --> 07:46.490
avant d'ajouter de nouvelles fonctionnalités.
