WEBVTT

00:00.590 --> 00:02.660
Bonjour et bienvenue à Unit Testing for unity.

00:02.690 --> 00:03.860
Les ateliers.

00:03.860 --> 00:09.590
Dans cette section des ateliers, nous allons couvrir un grand nombre de petits exemples différents qui nous montrent chacun quelques

00:09.590 --> 00:11.030
caractéristiques des tests unitaires.

00:11.030 --> 00:12.800
Jetons un coup d'œil au contenu de ce document.

00:12.800 --> 00:16.730
Tout d'abord, je vais donner un aperçu de ce que je suis en train de faire dans cette section d'introduction.

00:16.730 --> 00:19.070
Ensuite, nous passerons en revue chaque atelier.

00:19.070 --> 00:24.320
En règle générale, chaque atelier se rapporte à une scène de notre projet d'exemple.

00:24.320 --> 00:28.370
Si vous téléchargez cet exemple de projet, vous pouvez donc suivre chacune des scènes.

00:28.370 --> 00:35.270
Nous allons couvrir mon système mathématique, qui est un exemple très basique, juste pour nous réhabituer à ce que sont les tests unitaires.

00:35.270 --> 00:36.500
à l'intérieur d'unity.

00:36.500 --> 00:42.230
Ensuite, nous passerons à un exemple de chargeur de données, dont je montrerai une version de base et ensuite

00:42.230 --> 00:48.740
une version plus avancée utilisant quelques fonctionnalités supplémentaires qui sont optionnelles mais terriblement puissantes à l'intérieur.

00:48.740 --> 00:50.390
unity pour les tests unitaires.

00:50.420 --> 00:54.920
Ensuite, nous verrons un exemple dans lequel je voulais faire quelque chose avec des graphiques rendus.

00:54.920 --> 01:00.530
J'ai donc un cube que nous pouvons manipuler à l'aide des touches fléchées ou d'une manette de jeu.

01:00.530 --> 01:01.340
personnage.

01:01.400 --> 01:06.950
Nous allons passer en revue quelques exemples, en examinant des cas d'utilisation de plus en plus complexes pour les tests,

01:06.950 --> 01:13.520
nous finirons par faire un mouvement basé sur la physique, en prenant des données et en déplaçant notre personnage à l'aide d'un corps rigide,

01:13.520 --> 01:17.990
et regarder comment et pourquoi nous voudrions faire des tests unitaires autour de cela.

01:18.020 --> 01:25.340
D'une manière générale, plus vous utilisez de fonctions unity et plus vous faites d'animations en cours d'exécution, plus il est difficile de faire des tests unitaires.

01:25.340 --> 01:27.440
plus de défis pour le processus de test.

01:27.440 --> 01:28.880
Nous allons donc en parler un peu.

01:28.880 --> 01:31.670
J'ai toujours la possibilité d'ajouter du contenu ici.

01:31.670 --> 01:34.160
Nous allons donc également aborder des sujets avancés.

01:34.160 --> 01:38.990
Cet atelier nous permettra d'approfondir certains thèmes secondaires.

01:38.990 --> 01:43.580
Tout le code source est disponible dans le code source téléchargé pour le projet lui-même.

01:43.580 --> 01:44.720
Vous pouvez donc le télécharger.

01:44.720 --> 01:48.950
Le format utilisé ici est celui d'un partage d'écran improvisé.

01:48.980 --> 01:53.750
Je vais faire des prises plus longues que d'habitude, et penser à haute voix quand il y a des choses différentes.

01:53.750 --> 01:58.520
que j'aimerais aborder et partager avec vous sur les pouvoirs et les défis des tests unitaires.

01:58.820 --> 02:03.320
Je vais passer en revue le code existant et, ici et là, créer du nouveau code en cours de route.

02:03.320 --> 02:09.590
Une bonne façon d'examiner et d'utiliser ces informations est de télécharger le projet d'exemple et de le suivre.

02:09.590 --> 02:10.400
ici et là.

02:10.400 --> 02:16.190
Je vous encourage à ajouter une nouvelle méthode de production à tester ou de nouvelles méthodes de test pour couvrir ce que vous avez déjà testé.

02:16.190 --> 02:17.540
dans le code de production.

02:17.540 --> 02:21.200
Vous pouvez vous appuyer sur les échantillons existants que j'ai ici.

02:21.200 --> 02:23.720
Vous pouvez également créer vos propres exemples de scènes.

02:23.720 --> 02:27.230
Et pour récapituler, lisons ici les avantages des tests unitaires.

02:27.230 --> 02:33.560
Certains d'entre eux comprennent l'amélioration de la confiance dans le code, ainsi que la possibilité d'effectuer des remaniements plus audacieux de votre code.

02:33.560 --> 02:39.560
La base de données est plus consciente de l'état d'avancement du projet avant et après la refonte.

02:39.560 --> 02:44.990
Dans l'ensemble, cela permettra de gagner du temps, car nous avons constaté que, bien que nous ayons l'impression d'être toujours

02:45.020 --> 02:50.210
l'ajout de nouvelles fonctionnalités dans la majeure partie de notre travail, la recherche nous apprend que le développement de logiciels

02:50.210 --> 02:55.220
consiste principalement à maintenir un code existant, et c'est vraiment là que les tests unitaires interviennent.

02:55.220 --> 02:55.640
de briller.

02:55.640 --> 02:58.700
Ils vont donc nous faire gagner du temps pendant toute la durée du projet.

02:58.730 --> 03:04.130
Les résultats que nous attendons de ce cours et de l'utilisation des tests unitaires sont une plus grande confiance et une plus grande efficacité.

03:04.130 --> 03:05.990
robustesse dans notre base de code.

03:06.020 --> 03:12.680
Nous aurons plus de classes et de méthodes à usage unique, ce qui est un excellent principe de conception à appliquer.

03:12.680 --> 03:14.930
sur lequel nous devons nous concentrer et qui nous aide certainement à améliorer notre testabilité.

03:14.930 --> 03:17.450
Et nous allons encourager des solutions plus simples.

03:17.450 --> 03:19.550
Nous en parlerons dans certains de ces exemples.

03:19.550 --> 03:21.650
Récapitulons l'exemple le plus simple.

03:21.650 --> 03:24.380
C'est également le premier des ateliers que nous allons étudier.

03:24.410 --> 03:30.290
Si nous avons une classe de système mathématique de l'esprit, et qu'elle possède deux méthodes pour additionner et soustraire.

03:30.320 --> 03:35.090
Une fois que vous aurez vu cette base de code fonctionner, vous pourrez imaginer d'ajouter votre propre méthode pour multiplier...

03:35.090 --> 03:38.300
ou diviser, puis ajouter des tests unitaires par-dessus.

03:38.310 --> 03:39.800
Une excellente façon de s'entraîner.

03:39.800 --> 03:43.220
Cette scène est volontairement la plus simple de toutes celles que nous allons voir.

03:43.220 --> 03:48.560
Si vous êtes encore en train de vous familiariser avec les principes fondamentaux et que vous voulez vous assurer qu'ils sont bien assimilés, nous vous proposons de passer à l'étape suivante,

03:48.560 --> 03:53.300
Je vous suggère de passer un peu plus de temps sur cette partie de la vidéo et cette partie de la base de code jusqu'à ce que

03:53.300 --> 03:55.340
jusqu'à ce que vous vous sentiez bien, puis de passer à autre chose.

03:55.340 --> 03:59.450
Encore une fois, voici un exemple du type de tests unitaires que nous allons créer.

03:59.450 --> 04:04.100
Il s'agit d'un test simple, complet et approprié pour couvrir mon système mathématique.

04:04.100 --> 04:08.690
Ici, nous suivons le paradigme de l'arrangement, de l'action et de l'affirmation.

04:08.720 --> 04:14.540
Il s'agit d'une manière facultative d'aborder les tests unitaires, juste pour organiser vos propres pensées au fur et à mesure que vous avancez.

04:14.720 --> 04:18.740
Parfois, en cours de route, vous pouvez être amené à développer du code asynchrone.

04:18.740 --> 04:23.990
Dans cette méthodologie, je ferais donc arrange, act, await et assert.

04:23.990 --> 04:29.840
Et si vous n'êtes pas exactement sûr de ce qu'est une attente, nous allons examiner les méthodes d'attente et d'asynchronisme.

04:29.870 --> 04:32.120
codage asynchrone dans le cadre de l'atelier.

04:32.120 --> 04:37.760
En travaillant sur le code source pour contribuer au projet et à ce cours, que se passe-t-il ?

04:37.760 --> 04:40.330
j'ai regardé chacune des dépendances.

04:40.340 --> 04:47.990
Unity dispose de certaines bibliothèques dans le gestionnaire de paquets unity pour que nous puissions utiliser la solution unity officielle.

04:47.990 --> 04:49.550
pour les tests unitaires.

04:49.550 --> 04:55.820
Maintenant, ce que j'ai fait ici, c'est qu'au lieu d'utiliser la version x qui est en cours de publication, j'utilise une version expérimentale.

04:55.820 --> 04:59.900
Vous pouvez donc remarquer que le programme d'essai que je suis en train de parcourir dans la vidéo ressemble à ce qui suit

05:00.050 --> 05:04.940
un peu différent de certaines captures d'écran que vous avez pu voir sur le web, ou si vous avez de l'expérience

05:04.940 --> 05:06.400
avec le test runner.

05:06.410 --> 05:08.630
Ce que je montre aujourd'hui peut sembler un peu différent.

05:08.660 --> 05:13.370
Le projet d'exemple que vous allez télécharger va correspondre à l'aspect de cette vidéo, parce que j'ai

05:13.400 --> 05:15.020
j'ai inclus cette dépendance.

05:15.050 --> 05:16.340
Il y a des raisons pour lesquelles je l'ai fait.

05:16.340 --> 05:21.020
Ce n'est pas seulement parce que le test runner a une apparence différente et est plus stable, ce que je pense être le cas.

05:21.050 --> 05:26.870
C'est aussi que la bibliothèque derrière nous permet de faire quelques choses de plus, en particulier autour de certaines fonctions asynchrones.

05:26.870 --> 05:28.370
développement et des tests.

05:29.730 --> 05:33.060
Vous pouvez jeter un coup d'œil à ce fichier texte de version qui est inclus dans le projet.

05:33.060 --> 05:37.790
Si vous voulez voir comment, où et pourquoi chacune de ces dépendances a été incluse.

05:37.800 --> 05:43.020
L'exemple de projet dans lequel nous allons aller comprend un fichier Readme, sur lequel nous pouvons cliquer et voir

05:43.020 --> 05:44.390
ce joli menu sur la droite.

05:44.400 --> 05:49.950
C'est un moyen facile de se souvenir des liens les plus courants et de cliquer directement sur chacun d'entre eux.

05:49.950 --> 05:51.690
échantillons que vous souhaitez consulter.

05:51.960 --> 05:57.270
J'ai une disposition particulière que vous me verrez utiliser ici, qui consiste à garder le programme d'essai au centre.

05:57.270 --> 05:59.930
pour qu'il soit bien gros pour les besoins de la vidéo.

05:59.940 --> 06:04.710
Souvent, dans le développement, mon programme de test se trouve sur le côté droit, mais j'aime bien l'avoir

06:04.710 --> 06:08.280
au premier plan, surtout pour discuter des tests.

06:08.370 --> 06:13.290
Vous pouvez bien sûr redimensionner ces fenêtres et ces présentations comme vous le souhaitez, mais certaines des plus importantes sont les suivantes

06:13.290 --> 06:18.150
de jeter un coup d'oeil à la fenêtre de projet, au gestionnaire de tests et à l'inspecteur, que nous allons

06:18.150 --> 06:19.020
allons voir.

06:19.020 --> 06:23.310
Nous allons donc nous plonger dans le premier de ces ateliers.

06:23.370 --> 06:27.870
Je l'ai divisé en plusieurs sections, en me concentrant à nouveau sur différents sous-sujets.

06:27.870 --> 06:35.130
J'ai également pensé en cours de route à les organiser plus ou moins à partir de un jusqu'au nombre le plus élevé, en commençant par

06:35.130 --> 06:39.840
en commençant par le plus facile et le moins complexe, puis en développant ces concepts.

06:40.140 --> 06:42.810
Chacune des scènes de démonstration s'exécute seule.

06:42.810 --> 06:44.880
Il suffit d'appuyer sur play dans la fenêtre de la console.

06:44.910 --> 06:47.070
Vous verrez des affichages et des choses comme ça.

06:47.070 --> 06:52.050
Vous pouvez suivre le déroulement de la scène et, pour certaines d'entre elles, il y a quelque chose à faire lorsque vous appuyez sur "play".

06:52.080 --> 06:56.610
Parfois, il n'y a pas d'interface utilisateur, c'est très simple et vous n'avez qu'à regarder les déclarations du journal de débogage.

06:56.610 --> 07:00.110
Je suis donc très enthousiaste à l'idée de partager ces ateliers, qui constituent un excellent moyen de se plonger dans le sujet.

07:00.120 --> 07:01.140
Commençons donc.

07:01.140 --> 07:02.970
Nous allons ouvrir l'éditeur unity.

07:02.970 --> 07:07.680
J'ai déjà téléchargé le code source en suivant les ressources du cours plus tôt dans la leçon.

07:07.680 --> 07:12.540
Nous allons ouvrir ce projet d'exemple de cours, puis nous allons ouvrir et jouer une ou plusieurs scènes.

07:12.540 --> 07:13.680
dans chacun des ateliers.

07:13.680 --> 07:18.360
Nous allons tout d'abord consulter le fichier Readme qui nous oriente dans le projet.

07:18.390 --> 07:23.700
Nous allons également voir le gestionnaire de paquets, explorer la structure du projet et enfin jeter un coup d'œil au test.

07:23.700 --> 07:24.630
de test.

07:24.630 --> 07:29.610
Ici, nous donnons un aperçu de l'échantillon de projet et de la façon dont les ateliers sont organisés.

07:29.610 --> 07:30.270
formatés.

07:30.270 --> 07:33.090
Ensuite, nous passerons en revue chacun des ateliers.

07:33.090 --> 07:35.190
Nous voici donc à l'intérieur de l'unité.

07:35.190 --> 07:39.960
Je vais faire de mon mieux pour que la tête de ma webcam ne soit pas au cœur de l'action.

07:39.960 --> 07:45.360
Ce que nous allons voir, c'est que le Readme, qui est disponible à quelques endroits, nous

07:45.360 --> 07:48.810
pouvons aller ici et explorer cette option de menu pour ouvrir le Readme.

07:49.440 --> 07:54.060
Nous pouvons également parcourir la fenêtre du projet et cliquer sur le fichier readme.

07:54.180 --> 07:56.900
Quoi qu'il en soit, le fichier readme s'ouvrira dans l'inspecteur.

07:56.910 --> 07:58.650
Jetons un coup d'œil à ce que nous avons ici.

08:00.900 --> 08:05.490
Nous avons quelques liens vers le cours et vers l'exemple de projet, à titre d'orientation, où ces informations sont disponibles.

08:05.490 --> 08:06.060
sont disponibles.

08:06.060 --> 08:08.670
Si vous voulez cliquer et consulter ces liens.

08:11.450 --> 08:13.220
Puis la section "Getting Started".

08:13.220 --> 08:18.650
Il s'agit d'un moyen rapide d'accéder à certains des exemples les plus courants.

08:18.650 --> 08:20.060
la fenêtre du projet et les trouver.

08:20.060 --> 08:22.140
Mais c'est une bonne façon de s'orienter.

08:22.160 --> 08:25.190
Je voulais également jeter un coup d'œil au gestionnaire de paquets.

08:25.220 --> 08:29.360
Si vous téléchargez ce projet, vous verrez les mêmes paquets ici.

08:29.360 --> 08:35.510
Mais si vous décidez, dans le cadre de votre apprentissage ici ou dans le futur, d'apporter ces leçons

08:35.510 --> 08:40.640
dans un autre projet, vous devrez faire en sorte que votre gestionnaire de paquets soit similaire si vous voulez

08:40.640 --> 08:42.230
avoir la même expérience.

08:42.230 --> 08:46.160
Remarquez que j'ai le paquet de substitution de fin.

08:46.400 --> 08:52.130
J'ai également le paquet de couverture de code, le cadre de test.

08:52.130 --> 08:56.990
Et pour les besoins de ce cours, notez que j'ai une version pré-version qui nous donne des informations supplémentaires sur la couverture du code.

08:56.990 --> 08:57.940
fonctionnalités supplémentaires.

08:57.950 --> 09:00.050
Ceci est optionnel pour les tests unitaires.

09:00.050 --> 09:04.730
Vous n'en avez certainement pas besoin pour l'essentiel des fonctionnalités des tests unitaires, mais je pense qu'il a un certain nombre d'avantages.

09:04.730 --> 09:06.020
des choses intéressantes à la pointe de la technologie.

09:06.020 --> 09:10.040
C'est donc sur cela que nous allons nous concentrer, et je vous recommande de l'essayer.

09:10.070 --> 09:11.420
Autre chose à noter ici.

09:11.420 --> 09:14.750
Ce fichier de version que j'ai sélectionné va approfondir ce point.

09:14.750 --> 09:19.430
C'est juste quelques notes que j'ai prises en cours de route pour parler un peu des dépendances que je

09:19.430 --> 09:20.390
choisi et pourquoi.

09:22.530 --> 09:24.420
Nous n'y reviendrons donc pas ici.

09:24.450 --> 09:26.080
Cela peut également changer au fil du temps.

09:26.100 --> 09:30.210
Mais consultez ce fichier si vous êtes curieux de savoir comment et pourquoi j'ai utilisé chacune des dépendances.

09:30.210 --> 09:33.450
pourquoi j'utilise cette version pré-version que j'ai mentionnée explicitement.

09:33.480 --> 09:37.110
Et enfin, au centre de l'écran, regardons la fenêtre du programme de test.

09:37.140 --> 09:42.480
Cette fenêtre est disponible à partir de Window General et Test Runner.

09:42.480 --> 09:47.160
Et elle est incluse dans chaque installation par défaut de unity comme je l'ai mentionné.

09:47.190 --> 09:51.600
J'ai ajouté la pré-version d'un paquet donné, donc la disposition de la mienne peut sembler un peu différente.

09:51.600 --> 09:54.150
que la norme ici dans cette présentation.

09:54.180 --> 10:01.260
Nous avons ici la possibilité d'activer et de désactiver les tests en mode édition, ainsi que les tests en mode lecture.

10:01.260 --> 10:03.570
Ils sont affichés ici dans la même vue d'onglet.

10:03.720 --> 10:04.840
C'est vraiment génial.

10:04.860 --> 10:07.800
Je peux ensuite parcourir les différentes catégories.

10:07.800 --> 10:13.140
J'ai créé tous les tests que nous examinons et je les ai classés dans une catégorie spécifique.

10:13.140 --> 10:18.360
Ainsi, si je veux en examiner un en particulier, comme mon système de mathématiques, il suffit de filtrer la vue.

10:18.390 --> 10:23.970
et il ne vous montrera que l'édition ou la lecture et d'une catégorie donnée.

10:24.000 --> 10:25.230
C'est très utile.

10:25.260 --> 10:31.170
Ce que je peux faire ici en ne sélectionnant que l'édition, par exemple, c'est voir tous les tests.

10:31.170 --> 10:31.770
qui s'y trouvent.

10:31.770 --> 10:36.600
Et ici, en bas, je peux exécuter sélectionné ou exécuter tout ce que je vais exécuter sélectionné, par exemple.

10:36.600 --> 10:40.950
Et ce qu'il fait, c'est qu'il passe en revue et exécute tout le code de test.

10:41.040 --> 10:48.270
C'est un peu le cœur de la méthodologie que nous abordons ici, c'est que périodiquement dans votre développement

10:48.270 --> 10:50.270
vous voulez tester votre propre base de code.

10:50.280 --> 10:55.190
Vous arrivez à cette fenêtre et vous appuyez manuellement sur le bouton "run selected" ou "run all".

10:55.200 --> 10:59.340
Nous voyons ici tout le vert indiquant le succès en haut.

10:59.340 --> 11:02.970
Cela nous donne un petit récapitulatif indiquant que nous avons 100 tests qui ont réussi.

11:02.970 --> 11:07.550
Nous avons zéro test qui a échoué, et nous avons zéro test qui a été ignoré.

11:07.560 --> 11:13.530
Une bonne pratique pour les tests unitaires est donc de s'assurer que tous les tests sont réussis.

11:13.560 --> 11:18.570
Ne laissez pas un test défaillant dans votre projet pendant longtemps.

11:18.570 --> 11:19.680
Il faut s'en préoccuper.

11:19.680 --> 11:20.520
Déplacez-la du chemin.

11:20.520 --> 11:23.280
Même si vous savez qu'une migration est prévue dans le futur.

11:23.280 --> 11:29.280
La meilleure pratique consiste donc à mettre à jour vos tests en fonction des modifications apportées au code et à toujours les avoir à portée de main.

11:29.280 --> 11:30.030
en train de passer.

11:30.030 --> 11:32.700
Voici donc la meilleure pratique en vigueur.

11:33.690 --> 11:36.690
Dans le prochain atelier, nous examinerons de plus près le code source concerné.

11:36.690 --> 11:41.850
Mais c'est tout pour cette section consacrée aux ateliers et au projet d'exemple.

11:46.910 --> 11:47.900
Bonjour et bienvenue.

11:47.900 --> 11:53.990
Dans cet atelier, nous allons jeter un coup d'œil au système My Math, en pénétrant dans ce qui est un projet assez complexe.

11:54.020 --> 11:58.250
un exemple assez simple, qui nous permettra de nous familiariser à nouveau avec les bases des tests unitaires.

11:58.250 --> 12:01.640
Dans cette démo, vous pouvez utiliser le projet Core Sample pour nous suivre.

12:01.640 --> 12:06.440
Nous allons ouvrir l'éditeur unity, ouvrir le projet core sample, et ensuite nous allons

12:06.440 --> 12:08.060
ouvrir et jouer quelques scènes ici.

12:08.060 --> 12:13.310
Nous allons examiner le système My Math ainsi que le test qui le sous-tend, et nous ferons un récapitulatif.

12:13.340 --> 12:18.920
des tests unitaires, en parlant simplement des concepts de base que je vois là et que je pense à mentionner.

12:18.920 --> 12:25.370
Nous parlerons aussi des valeurs paramétrées, qui sont une façon intermédiaire d'aborder les tests unitaires.

12:25.370 --> 12:25.880
les tests.

12:25.880 --> 12:29.540
Il s'agit d'une bonne compétence supplémentaire à acquérir lorsque l'on aborde les tests unitaires.

12:29.570 --> 12:30.560
Plongeons dans le vif du sujet.

12:30.770 --> 12:35.330
Ici, je suis dans l'éditeur unity et j'ai ouvert l'exemple de mon système mathématique.

12:35.330 --> 12:37.970
Jouons la scène elle-même.

12:38.000 --> 12:41.630
Parfois, dans ces ateliers, la scène est plus excitante.

12:41.630 --> 12:43.220
Celle-ci n'est pas si passionnante.

12:43.220 --> 12:48.680
Nous allons appuyer sur play dans la fenêtre du bas, nous voyons un texte simple qui nous aide.

12:48.680 --> 12:53.960
nous aider à comprendre que nous sommes dans la démo de test unitaire, et nous allons juste jouer la scène et voir la console.

12:53.960 --> 12:55.430
Regardons donc la console.

12:55.520 --> 12:58.520
La console indique que cette scène n'a pas d'interface utilisateur.

12:58.550 --> 13:01.430
Voyons la console unity, nous sommes ici dans la console.

13:01.430 --> 13:02.090
Vraiment.

13:02.090 --> 13:06.830
Cela va juste nous montrer une valeur qui a été crachée après une opération réussie.

13:06.830 --> 13:12.290
Dans un code de production réel, cette scène serait beaucoup plus intéressante.

13:12.290 --> 13:17.540
Peut-être qu'il y a en fait le menu du jeu ou le jeu qui se passe ici.

13:17.780 --> 13:22.730
Il s'agit d'une scène assez maigre où il n'y a pas grand-chose à voir, mais vous pouvez imaginer que cela pourrait

13:22.730 --> 13:23.150
être.

13:23.720 --> 13:28.880
Il n'est pas particulièrement important qu'il y ait une scène d'exécution pour les besoins du test.

13:28.880 --> 13:34.520
Je veux juste parler souvent de l'équilibre entre le code de production qui fait son travail de production et le code de test.

13:34.520 --> 13:35.150
chose.

13:35.150 --> 13:38.480
Et ici, le code de test fait son travail de test.

13:38.480 --> 13:44.330
Le code de production, nous l'expérimentons toujours en appuyant sur play sur une scène unity comme celle-ci.

13:44.330 --> 13:47.750
Et pour faire nos tests unitaires, nous faisons quelque chose de différent.

13:47.780 --> 13:50.990
Ce que nous faisons ici, c'est que nous regardons la fenêtre du programme de test.

13:51.530 --> 13:55.340
Nous explorons la catégorie appropriée à ce que nous voulons examiner ici.

13:55.340 --> 13:57.470
Nous nous contentons de regarder le système "my math".

13:58.560 --> 14:01.020
Puis nous cliquons sur Let's see.

14:01.020 --> 14:02.280
Faisons le test du mode édition.

14:02.430 --> 14:06.780
Nous allons faire run all ici et tous les tests se dérouleront comme ça.

14:06.810 --> 14:09.050
Maintenant, la scène n'a pas été exécutée.

14:09.060 --> 14:15.420
Il s'exécute juste un peu à l'écart, dans son propre petit univers, en exécutant ces tests à l'intérieur d'un fichier

14:15.420 --> 14:16.290
mode édition.

14:16.290 --> 14:19.790
Donc, les tests en mode édition, en parlant un peu de la différence entre les deux.

14:19.800 --> 14:25.050
Les tests en mode édition s'exécutent en mode édition, qui, dans l'unité, comporte deux modes principaux.

14:25.050 --> 14:30.630
En gros, du moment où vous appuyez sur le bouton de lecture au moment où vous appuyez sur le bouton de lecture, c'est-à-dire

14:30.630 --> 14:31.290
mode lecture.

14:31.320 --> 14:35.440
C'est généralement là que l'utilisateur fait l'expérience de l'unité de jeu.

14:35.610 --> 14:38.430
Chaque fois que nous ne sommes pas dans ce mode, nous sommes en mode édition.

14:38.430 --> 14:40.170
Ici, nous sommes en mode édition.

14:40.200 --> 14:46.260
Ces tests sont exécutés en mode édition parce qu'ils n'ont pas nécessairement besoin de toute la complexité d'une exécution.

14:46.260 --> 14:46.800
scène.

14:46.800 --> 14:52.110
Cela nous permet d'avoir une petite zone isolée plus simple où ces codes s'exécutent.

14:52.110 --> 14:57.780
Parfois, on a besoin des commodités des comportements monoblocs et des fonctionnalités d'exécution.

14:57.780 --> 15:01.680
C'est là que le mode lecture entre en jeu.

15:01.680 --> 15:04.260
Et ici, nous avons également quelques tests en mode lecture.

15:04.260 --> 15:09.480
Chaque fois que je clique sur l'une de ces cases à cocher, nous obtenons des listes légèrement différentes.

15:09.510 --> 15:10.740
de ce que nous avons à disposition.

15:10.740 --> 15:13.140
Ici, en mode lecture, je vais appuyer sur run all.

15:13.950 --> 15:18.090
Et ici, cela crée une toute nouvelle scène.

15:18.090 --> 15:24.420
Lancement d'une scène d'exécution juste pour la démo avec le code de test que j'ai, puis retour à l'écran.

15:24.420 --> 15:26.880
nous ramène à la scène originale dans laquelle nous étions.

15:26.880 --> 15:31.110
Si nous n'avions pas sauvegardé la scène, le logiciel nous le signalerait en nous disant que nous sommes sur le point d'exécuter un mode de jeu.

15:31.140 --> 15:31.620
test.

15:31.650 --> 15:33.360
Nous allons quitter temporairement votre scène.

15:33.390 --> 15:35.040
Voulez-vous d'abord sauvegarder votre scène ?

15:35.040 --> 15:37.500
En général, c'est une bonne idée, alors faites attention.

15:37.530 --> 15:39.300
Regardons maintenant le code source.

15:39.330 --> 15:43.020
Regardons d'abord le code de production de l'exécution.

15:43.020 --> 15:45.810
Nous allons donc ouvrir l'exemple du système My Math.

15:45.810 --> 15:52.740
Chacun de ces ateliers a, en général, un objet de jeu avec un script d'exemple qui donne le coup d'envoi

15:52.740 --> 15:53.580
le tout.

15:53.580 --> 15:59.490
En regardant cela, nous sommes dans l'éditeur de code et nous pouvons voir l'ensemble de mon système mathématique.

15:59.490 --> 16:00.180
exemple.

16:00.180 --> 16:05.670
Il s'agit d'un monobehaviour car je veux que le code soit placé sur un objet de jeu.

16:05.670 --> 16:10.380
Et à l'intérieur de l'attente ici, je vais simuler un peu de code de production.

16:10.380 --> 16:16.140
Maintenant c'est très simple, il n'y a pas grand chose, et ça ressemble un peu au test dont nous parlons

16:16.140 --> 16:21.780
parce que je crée la classe à partir de zéro, puis j'appelle une méthode, et ensuite je montre

16:21.780 --> 16:22.530
les résultats.

16:22.530 --> 16:28.320
Mais il est important de savoir que dans un exemple de production, dans un vrai projet de jeu, cet équivalent serait

16:28.320 --> 16:33.600
serait de nombreuses classes et toutes les scènes et tous les préfabriqués et toute la complexité que vous auriez généralement

16:33.600 --> 16:34.530
dans votre projet.

16:34.530 --> 16:37.230
Mais ici, j'ai délibérément opté pour un projet très dépouillé.

16:37.230 --> 16:38.910
Remarquez donc ce que nous faisons ici.

16:38.910 --> 16:40.920
Nous créons le système my math.

16:40.920 --> 16:45.750
Nous prenons quelques ints et les remplissons avec les valeurs cinq et dix.

16:45.750 --> 16:47.940
Nous appelons ensuite le système my Math.

16:47.940 --> 16:50.550
Et nous passons les valeurs cinq et dix ensemble.

16:50.550 --> 16:52.500
Nous affichons ensuite le résultat.

16:52.500 --> 16:54.030
Allons-y, faisons-le.

16:54.030 --> 16:55.470
Je lance la lecture.

16:59.430 --> 17:03.560
Et ici, dans la fenêtre de la console, nous voyons que le résultat est 15.

17:03.570 --> 17:09.240
J'aime la simplicité de cet exemple de codage, parce qu'il nous permet de commencer à penser dans un monde

17:09.240 --> 17:14.540
où les tests unitaires n'existeraient pas, comment pourrais-je m'assurer que ce code est fonctionnel ?

17:14.550 --> 17:21.570
Eh bien, peut-être que ce code de mon système mathématique est utilisé dans de très nombreux endroits de votre jeu, et que vous..,

17:21.570 --> 17:26.970
chaque fois que vous voulez voir et valider que ce système fonctionne bien, vous jouez simplement au jeu et

17:26.970 --> 17:31.110
votre jeu peut durer quelques minutes ou plusieurs heures.

17:31.110 --> 17:37.140
Et ce système particulier en cours de test pourrait être utilisé dans de très nombreux endroits différents, en fonction de la durée de vie du jeu.

17:37.140 --> 17:40.320
du comportement, des données et des situations de l'utilisateur.

17:40.320 --> 17:42.660
Le moment de la journée pourrait être important.

17:42.660 --> 17:47.970
Il est donc difficile de savoir si je le teste vraiment en isolation brute.

17:47.970 --> 17:56.490
Donc la première chose que je pourrais faire si je voulais faire une validation, c'est de copier ceci ici, de le coller

17:56.490 --> 17:57.360
ici.

17:59.710 --> 18:02.220
Et appeler ceci ici et tester.

18:02.230 --> 18:03.790
Et si c'était six ?

18:03.790 --> 18:05.680
Et si c'était 11 ?

18:07.710 --> 18:09.360
A à, B à.

18:14.010 --> 18:20.000
Je ne teste pas un test unitaire, mais je valide deux exemples différents.

18:20.010 --> 18:22.770
Donc je fais celui-ci en premier et je fais celui-là en second.

18:22.800 --> 18:29.760
C'est ce qu'on appelle les tests d'utilisateur, les tests de jeu ou les tests d'intégration.

18:29.760 --> 18:30.900
le code de production.

18:30.900 --> 18:37.710
Et je l'essaie juste en tant qu'utilisateur, en espérant que je lui demande accidentellement de faire un tas de choses différentes.

18:37.740 --> 18:40.620
opérations différentes, et qu'aucune n'échoue.

18:40.650 --> 18:44.790
Mais vous pouvez imaginer que ce que je fais ici, c'est ajouter des choses que je ne veux pas vraiment pour la fin...

18:44.790 --> 18:46.140
l'expérience de l'utilisateur final.

18:46.140 --> 18:52.650
J'essaie juste de me donner un peu plus de confiance dans mon propre code en appelant une fonctionnalité

18:52.650 --> 18:53.910
supplémentaires.

18:53.940 --> 19:00.510
Vous pouvez également définir un booléen quelque part dans votre projet qui dit que le mode de débogage est vrai, et ensuite

19:00.510 --> 19:02.280
tout au long de votre code de production.

19:02.280 --> 19:05.730
Si c'est le cas, vous ferez un peu plus de tests.

19:05.730 --> 19:07.140
Ce n'est pas si mal.

19:07.140 --> 19:12.150
Dans certaines situations, cela peut certainement vous aider, mais regardons à quel point la situation s'améliore

19:12.150 --> 19:12.720
peut être.

19:12.720 --> 19:15.960
Si au lieu de faire cela, j'exécute des tests unitaires.

19:15.960 --> 19:18.780
Voici donc où se trouve le code de ce projet.

19:18.780 --> 19:23.010
Dans ce projet, nous avons le système My Math, l'exemple du système My Math, que nous avons étudié.

19:23.700 --> 19:29.580
La structure de ce système et la manière dont il fonctionne ensemble ont été abordées plus tôt dans le cours.

19:29.580 --> 19:34.350
Mais nous avons un test d'éditeur et un test d'exécution dont nous allons parler.

19:34.350 --> 19:40.980
Encore une fois, tout test d'éditeur va se dérouler en mode édition, et c'est généralement idéal pour les choses qui n'ont pas besoin d'être modifiées.

19:40.980 --> 19:44.310
utiliser des classes spécifiques à l'unité comme Monobehaviour.

19:44.310 --> 19:49.440
Monobehaviour est conçu uniquement pour fonctionner de manière optimale en mode jeu.

19:49.440 --> 19:51.390
Donc ici, ce n'est pas trop approprié.

19:51.390 --> 19:51.870
Donc.

19:51.870 --> 19:54.810
Mais pour des tests simples comme celui que nous avons ici, c'est très bien.

19:54.840 --> 19:59.580
La zone d'exécution ici, où nous avons le test du mode lecture, serait un endroit idéal.

19:59.580 --> 20:05.130
Pour chacun de ces ateliers, j'en fais un pour que vous puissiez voir les différences.

20:05.130 --> 20:09.960
Mais il est important de penser que dans certaines situations, en fonction de ce que vous testez, probablement

20:09.960 --> 20:14.010
un test unitaire en mode édition est probablement plus approprié dans cette situation.

20:14.010 --> 20:18.630
C'est certainement le cas plus tard lorsque nous parlons de se déplacer avec l'entrée et de faire quelque chose avec

20:18.630 --> 20:24.750
physique, peut-être que le test du mode de jeu est nécessaire à ce moment-là, parce que l'entrée et la physique sont vraiment conçues

20:24.750 --> 20:26.220
comme des expériences de mode de jeu.

20:26.220 --> 20:28.650
Il est donc important de faire cette distinction.

20:28.650 --> 20:30.030
Et j'en parlerai ici et là.

20:30.270 --> 20:32.760
Examinons donc le test du système mathématique de l'esprit.

20:36.190 --> 20:39.130
Et voyons comment il est organisé.

20:40.710 --> 20:45.990
Ici, vous remarquerez que le test "My Math system" est organisé différemment.

20:51.350 --> 20:53.180
Il comporte plusieurs méthodes différentes.

20:53.330 --> 20:57.500
Chacun des noms que nous voyons ici sont les noms des méthodes de test.

20:57.500 --> 20:59.000
Commençons par le premier.

20:59.600 --> 21:04.970
La convention que j'aime utiliser est suivie ici, et nous y reviendrons dans le code que je mets généralement

21:04.970 --> 21:10.460
d'abord, quelle méthode testons-nous, qu'attendons-nous et ensuite quelle est la situation.

21:10.460 --> 21:13.400
Ici, nous testons la méthode add.

21:13.400 --> 21:18.080
Nous nous attendons à ce que le résultat soit 15 lorsque nous passons cinq et dix.

21:18.320 --> 21:23.750
Un raccourci intéressant consiste à double-cliquer sur un test pour l'exécuter à nouveau.

21:24.800 --> 21:26.540
Ensuite, je peux faire un clic droit.

21:28.490 --> 21:29.360
Désolé, j'étais en mode lecture.

21:29.810 --> 21:31.850
Double-cliquez dessus et il s'exécute à nouveau.

21:31.880 --> 21:32.330
Très bien.

21:32.330 --> 21:33.230
Toujours vert.

21:33.230 --> 21:36.560
Je peux cliquer dessus avec le bouton droit de la souris et choisir open source code.

21:37.720 --> 21:41.800
C'est un moyen facile d'accéder à la bonne classe et à la bonne méthode.

21:41.830 --> 21:44.320
Voici à nouveau le nom de la méthode que nous avons vue.

21:44.350 --> 21:47.860
Encore une fois, le résultat de l'addition est 15 quand cinq et dix.

21:47.890 --> 21:54.070
La raison pour laquelle cela est important est que si vous avez beaucoup de classes de test avec beaucoup de méthodes de test,

21:54.070 --> 22:01.600
et j'espère que c'est le cas dans votre projet, afin de raisonner sur ce qui, dans un test runner, correspond à ce qui dans le code

22:01.600 --> 22:04.610
Ici, c'est bien d'avoir un nom cohérent.

22:04.630 --> 22:09.910
Donc ici, ce que nous faisons, c'est la méthodologie arrange, act et assert.

22:09.910 --> 22:10.720
Dans l'arrangement.

22:10.720 --> 22:15.310
Ce que nous allons faire en premier, c'est créer une nouvelle instance de ce que nous voulons tester.

22:15.310 --> 22:19.420
De cette façon, nous savons qu'elle n'est pas restée inactive et qu'elle ne contient pas de vieilles données.

22:19.430 --> 22:20.770
C'est toujours une bonne pratique.

22:20.770 --> 22:22.480
Ensuite, nous allons agir en conséquence.

22:22.480 --> 22:26.140
C'est comme, quelle est la seule méthode si vous pouvez vous en sortir ?

22:26.140 --> 22:28.690
Peut-être deux méthodes qui font vraiment les tests.

22:28.690 --> 22:30.160
Mais une seule méthode est idéale.

22:30.190 --> 22:32.680
Ici, on additionne cinq et dix.

22:32.680 --> 22:36.670
Et dans l'assert, nous allons utiliser ce langage d'assert.

22:36.670 --> 22:43.630
La classe assert a une certaine structure qui permet de dire que j'affirme que quelque chose est quelque chose.

22:43.630 --> 22:48.670
Vous pouvez consulter la documentation sur cette classe pour voir les différentes façons de la formater.

22:48.670 --> 22:54.790
Mais j'utilise souvent is equal to ou is true ou is false.

22:54.790 --> 22:57.670
Ce sont donc des exemples que vous verrez assez souvent ici.

22:57.970 --> 23:02.920
Lorsque j'exécute ce code, parce qu'il s'exécute correctement, il ajoute cinq et dix pour obtenir 15.

23:02.950 --> 23:03.700
C'est tout.

23:03.730 --> 23:05.010
Nous sommes en mesure de le faire.

23:05.020 --> 23:08.620
Maintenant, souvenez-vous de l'exemple que je donnais dans le code de production.

23:08.620 --> 23:17.650
Et si vous vouliez tester 5 et 10, puis 6 et 11, puis 7 et 12, ou autre chose ?

23:17.650 --> 23:18.700
combinaisons ?

23:18.700 --> 23:25.510
Plus vous maîtriserez les tests, plus vous vous rendrez compte du nombre de tests dont vous avez réellement besoin pour assurer une couverture adéquate.

23:25.510 --> 23:31.180
Il y a beaucoup d'art et de science autour du nombre minimum de tests que l'on peut fournir pour assurer une couverture adéquate.

23:31.180 --> 23:34.720
maximiser votre impact et la couverture du code que vous avez ?

23:34.750 --> 23:40.030
L'une des choses dont je voulais parler dans le cadre de cet atelier particulier est ce que l'on appelle les

23:40.030 --> 23:41.830
les tests paramétrés.

23:41.830 --> 23:48.460
Ainsi, au lieu de copier celui-ci, de le coller ci-dessous et d'ajuster les valeurs pour obtenir un total de six

23:48.460 --> 23:55.780
et 11 ou 0 et 10 négatif, nous pouvons demander à unity d'effectuer le même test exact, mais en passant par des valeurs différentes.

23:55.780 --> 23:56.530
valeurs.

23:56.530 --> 23:58.750
Il y a beaucoup d'options différentes ici.

23:58.750 --> 24:00.340
Je n'en montre qu'une.

24:00.340 --> 24:02.800
Mais jetons un coup d'œil ici.

24:03.730 --> 24:10.090
Nous disons, et ensemble, que nous supposons que le résultat est correct lorsque ces valeurs.

24:10.090 --> 24:15.640
Donc les noms de méthode un peu plus vague parce que c'est paramétré, je ne sais pas forcément.

24:15.640 --> 24:18.430
Est-ce que ça va tester cinq et dix, c'est 15.

24:18.460 --> 24:24.250
Remarquez qu'au lieu de ce que j'ai fait précédemment, c'est-à-dire déclarer cinq et dix, je vais déclarer cinq et dix.

24:24.280 --> 24:29.890
Dans le corps de la méthode, j'utilise ce langage particulier, j'utilise ce que l'on appelle une source de valeur.

24:29.890 --> 24:31.210
Et je la passe ensuite.

24:31.210 --> 24:37.090
Ce que fait unity, c'est qu'il remplit ce premier passage de valeurs ici.

24:37.090 --> 24:38.740
Disons que c'est cinq.

24:38.770 --> 24:41.290
Il saisit ensuite une autre source de valeur ici.

24:41.320 --> 24:48.010
Disons que l'un est dix et qu'il suppose qu'il s'agit de cinq plus dix additionnés.

24:48.010 --> 24:52.960
Ainsi, à chaque fois qu'il s'exécute, il va faire l'équivalent du dernier test que nous avons vu.

24:52.960 --> 24:59.050
Mais au lieu d'être codé sur un seul ensemble de valeurs, il va les mélanger et en montrer une variété.

24:59.050 --> 24:59.560
d'entre elles.

24:59.560 --> 25:02.460
Là encore, il existe de nombreuses possibilités de formatage.

25:02.460 --> 25:06.670
Vous pouvez donc consulter la documentation sur les tests paramétrés dans unity.

25:06.670 --> 25:08.920
Mais regardons mon cas spécifique ici.

25:08.950 --> 25:11.350
Ces sources de valeurs sont les valeurs A et b.

25:11.350 --> 25:14.770
Elles font simplement référence à deux tableaux que j'ai ici.

25:14.770 --> 25:20.980
Et ce qu'il va faire, c'est qu'il va tester un et un, négatif deux et

25:20.980 --> 25:23.530
négatif deux, négatif trois et négatif trois et les transmettre.

25:23.560 --> 25:30.070
Vous pouvez les organiser comme vous le souhaitez et tester différents scénarios dans lesquels vous pouvez faire sept, 11

25:30.070 --> 25:30.670
et 12.

25:30.700 --> 25:32.230
Vous testez tout ce que vous voulez.

25:32.260 --> 25:35.020
Maintenant, vous n'êtes pas obligé de tester des quantités infinies.

25:35.020 --> 25:37.450
C'est là que l'art et la science entrent en jeu.

25:37.450 --> 25:43.960
Dans certains cas, vous voudrez peut-être tester quelques valeurs négatives (zéro) et quelques valeurs positives.

25:43.990 --> 25:48.820
Peut-être que ce que vous faites n'est pas basé sur les mathématiques et que vous voulez y réfléchir d'une autre manière, mais ce que vous faites, c'est

25:48.820 --> 25:51.370
recherche ce que l'on appelle des cas d'espèce.

25:51.370 --> 25:57.250
Par exemple, si vous utilisez une méthode de division et que vous voulez la tester mathématiquement, il y a

25:57.250 --> 25:59.740
un défi concernant la division par zéro.

25:59.740 --> 26:03.970
Il faut donc s'assurer que l'on passe à zéro et gérer cela de manière élégante.

26:03.970 --> 26:09.040
Vous devez vraiment connaître le domaine spécifique dans lequel se trouve votre code de production, afin de savoir comment

26:09.040 --> 26:09.730
le tester.

26:09.730 --> 26:14.020
Mais voici quelques exemples positifs et négatifs et des choses comme ça.

26:15.200 --> 26:17.950
Voyons ce que cela donne dans l'éditeur unity.

26:17.960 --> 26:19.670
Remarquez ce que cela fait ici.

26:19.670 --> 26:24.980
Il exécute en fait 49 tests basés sur toutes les combinaisons que nous avons ici.

26:24.980 --> 26:28.850
Il vous montre donc quand les valeurs sont et ensuite il les transmet.

26:28.850 --> 26:30.430
C'est vraiment bien.

26:30.440 --> 26:37.430
En regardant cette sortie, vous pourriez vous rendre compte qu'il est important pour moi de tester 100

26:37.430 --> 26:38.800
et -100.

26:38.810 --> 26:39.320
Très bien.

26:39.320 --> 26:45.890
Il suffit ensuite de revenir en arrière et d'ajouter ces valeurs d'échantillonnage si vous voulez faire d'autres choses au lieu de vous contenter d'une valeur absolue.

26:45.890 --> 26:46.610
liste codée.

26:46.610 --> 26:50.510
Si vous souhaitez sélectionner des valeurs aléatoires, vous disposez de nombreuses autres options.

26:50.510 --> 26:53.180
Là encore, faites des recherches sur les tests paramétrés.

26:53.360 --> 26:57.860
Vous pouvez également vous pencher sur le test du mode de jeu si vous le souhaitez, mais étant donné que ce sera plus intéressant, il est préférable de faire des recherches sur les tests paramétrés.

26:57.860 --> 27:02.000
dans d'autres exemples, nous allons passer à autre chose et conclure cet atelier.

27:02.000 --> 27:02.840
Merci.

27:09.660 --> 27:13.260
Bonjour et bienvenue à cet atelier sur les tests unitaires Unity.

27:13.260 --> 27:16.830
Nous allons examiner mon chargeur de données Basic à titre d'exemple.

27:16.830 --> 27:17.420
Entrons dans le vif du sujet.

27:17.430 --> 27:20.280
Dans cette démo, je vais ouvrir unity.

27:20.280 --> 27:25.650
Ouvrez notre projet core sample et regardez la scène de mon data loader basic.

27:25.650 --> 27:31.500
La raison pour laquelle j'ai choisi de faire une sorte de chargement de données est juste pour parler de, eh bien, ce que

27:31.500 --> 27:39.900
si nos tests unitaires, que nous espérons très fiables et isolés, s'exécutent rapidement pour le bien de nos clients.

27:39.900 --> 27:42.000
propres méthodologies de test ?

27:42.000 --> 27:47.760
Et s'ils dépendent d'autres systèmes, comment savoir si nous sommes en mesure de tester une seule partie ?

27:47.790 --> 27:55.740
En général, les tests unitaires consistent à tester une seule unité, que l'on peut assimiler à une méthode d'une classe.

27:55.740 --> 28:01.740
Mais notre code est souvent constitué de plusieurs classes dépendant les unes des autres, ce qui peut être un défi pour la prise de décision.

28:01.740 --> 28:05.100
comment les séparer et les tester de manière isolée.

28:05.100 --> 28:11.280
Vous pouvez également avoir un système qui dépend de quelque chose d'asynchrone, comme le rendu de graphiques, le rendu d'images, etc.

28:11.280 --> 28:14.760
audio, ou dans ce cas, l'appel d'un serveur final.

28:14.760 --> 28:22.380
J'ai donc créé un exemple très simple qui charge des données que vous passez dans une URL, il appelle simplement une page web

28:22.380 --> 28:24.630
et récupère le texte de cette page web.

28:24.660 --> 28:31.410
Il s'agit de l'exemple le plus simple, mais on peut imaginer qu'il s'agit de n'importe quelle logique de serveur appelant à l'envoi de

28:31.410 --> 28:36.540
un score élevé de votre jeu, un appel pour charger des données de joueur, quelque chose en rapport avec le multijoueur.

28:36.540 --> 28:41.250
Tous ces éléments pourraient dépendre d'un trafic réseau asynchrone.

28:41.340 --> 28:42.330
Jetons un coup d'œil.

28:42.420 --> 28:44.250
Nous voici donc dans l'échantillon.

28:44.250 --> 28:46.290
Nous avons mon chargeur de données de base.

28:46.290 --> 28:46.890
Chargez-le.

28:46.890 --> 28:47.940
Lançons la lecture.

28:50.730 --> 28:51.990
Dans cette démo particulière.

28:52.020 --> 28:56.550
Il n'y a pas vraiment de choses intéressantes dans cette démo.

28:56.580 --> 28:58.950
Il n'y a rien de très intéressant qui se passe au niveau du gameplay.

28:59.220 --> 29:02.940
Nous allons aller sur la console ici et nous verrons que cette scène n'a pas d'interface utilisateur.

29:02.970 --> 29:09.300
Nous voyons la console unity, qui montre simplement la longueur de ce qui est renvoyé par le serveur.

29:09.300 --> 29:13.200
Tout ce qui n'est pas zéro signifie qu'une page a été chargée.

29:13.200 --> 29:14.670
Donc très léger.

29:14.670 --> 29:15.690
Test simple.

29:15.690 --> 29:19.190
Je n'ai pas de contrôle d'erreur ou ce genre de choses intégrées.

29:19.200 --> 29:23.640
Pour la simplicité de cette démo, on suppose que le test est réussi.

29:23.670 --> 29:27.780
Si vous faites du code de production et que vous appelez des serveurs, vous voudrez ajouter beaucoup plus de fonctionnalités

29:27.780 --> 29:28.410
à cela.

29:28.410 --> 29:32.770
Voilà donc l'expérience d'exécution, qui est assez simple et pas très intéressante.

29:32.790 --> 29:38.550
Maintenant, si nous regardons le lanceur de test ici, nous pouvons définir notre catégorie comme étant mon chargeur de données de base.

29:38.550 --> 29:42.360
Il ne nous montre donc que les tests liés à ce code particulier.

29:42.360 --> 29:44.160
Puis nous passons en mode édition.

29:44.160 --> 29:48.210
Ici encore, nous disposons d'un mode lecture, mais vous pouvez l'explorer par vous-même.

29:48.210 --> 29:52.230
Pour cette démo en particulier, je trouve que le mode édition est plus intéressant.

29:52.230 --> 29:54.660
Je vais donc appuyer sur run all.

29:56.330 --> 29:58.350
Et nous pouvons voir que nous avons réussi.

29:58.370 --> 30:04.520
Ceci indique que le résultat load async contient le doctype quand il est chargé.

30:04.520 --> 30:06.500
Jetons donc un coup d'œil à un peu de tout cela.

30:06.630 --> 30:08.780
Nous allons ici ouvrir notre source.

30:10.200 --> 30:11.820
Et voici le test.

30:11.940 --> 30:17.640
Il montre que nous créons d'abord une instance de notre base My Data Loader.

30:17.940 --> 30:21.660
Ensuite, nous écoutons lorsqu'il est chargé.

30:22.610 --> 30:25.880
Nous vérifions les données chargées par le serveur.

30:25.890 --> 30:30.800
Encore une fois, il s'agit simplement d'appeler une page web, et quel que soit le code source de la page web, il est renvoyé sous la forme d'un fichier

30:30.800 --> 30:32.030
un gros bloc de texte.

30:32.030 --> 30:34.370
Cela va donc ressembler à du HTML.

30:34.370 --> 30:39.920
En le regardant pendant que je le créais, j'ai remarqué qu'il indiquait doctype.

30:39.920 --> 30:45.530
Doctype n'est pas quelque chose de très important, en tout cas pas dans le monde de l'unité, mais je me suis dit

30:45.530 --> 30:49.640
qu'il s'agissait d'un petit test qui me disait si j'avais reçu quelque chose en retour d'une page web ?

30:49.640 --> 30:53.030
Vous pouvez imaginer des tests pour n'importe quelle autre sous-chaîne qui vous semble logique.

30:53.120 --> 31:00.020
Enfin, j'effectue l'action que nous testons ici, et je charge l'appel asynchrone ici

31:00.020 --> 31:01.340
et je passe l'URL.

31:01.370 --> 31:05.690
Remarquez que l'URL est celle de la page GitHub.

31:05.690 --> 31:07.280
Mais ce n'est pas si important.

31:07.430 --> 31:08.600
Il n'y a rien d'unique ici.

31:08.600 --> 31:15.620
Si vous voulez tester google.com, il suffit d'appeler google.com et d'obtenir la source.

31:15.620 --> 31:16.820
et récupère le code source.

31:16.820 --> 31:22.220
Je ne veux pas vraiment me concentrer sur ce que je fais ici dans le code de production, parce qu'il s'agit d'une tâche certes

31:22.220 --> 31:23.330
exemple simple.

31:23.330 --> 31:28.640
Je voulais juste que ce soit un moyen d'obtenir quelque chose d'asynchrone à l'intérieur de unity.

31:29.800 --> 31:32.500
Regardons le code source pour bien comprendre.

31:33.520 --> 31:33.970
Ici.

31:33.970 --> 31:34.540
Ce que nous faisons.

31:34.540 --> 31:38.740
Quand j'appelle load, je dis juste, hey, assurez-vous que l'URL n'est pas vide.

31:39.130 --> 31:44.320
Ensuite, j'utilise la requête web d'Unity, qui est une fonctionnalité intégrée.

31:44.320 --> 31:51.520
J'appelle send request, et je mets le résultat comme étant le texte du download handler.

31:51.550 --> 31:53.830
C'est juste un moyen facile et bon marché.

31:53.830 --> 31:57.010
Recommandé par unity pour appeler des données simples en ligne.

31:57.040 --> 31:58.570
Très simple et direct.

31:58.600 --> 32:02.860
Cela soulève une question : qu'est-ce que nous testons réellement ici ?

32:03.280 --> 32:09.580
J'ai une classe personnalisée appelée mon chargeur de données, mais à l'intérieur, je suis fortement dépendant d'une unité existante.

32:09.610 --> 32:12.160
fonctionnalité de unity web request.

32:12.190 --> 32:16.060
Ensuite, j'appelle une page web, dans ce cas GitHub.

32:16.060 --> 32:17.650
Et ça, c'est impliqué.

32:17.650 --> 32:22.810
Si GitHub était en panne pour la journée, ce test échouerait.

32:22.840 --> 32:24.100
Est-ce approprié ?

32:24.100 --> 32:31.000
Si mon test unitaire est vraiment destiné à tester ma propre méthodologie, ma propre fonctionnalité, je ne devrais pas prendre en compte les éléments suivants

32:31.000 --> 32:32.050
qu'il s'agit d'un test raté.

32:32.050 --> 32:34.840
Si une dépendance sans rapport avec le test échoue.

32:34.840 --> 32:36.610
Mais ici, c'est le cas.

32:36.610 --> 32:38.640
J'échouerais si GitHub était en panne.

32:38.650 --> 32:44.440
De plus, ici, j'utilise la requête web Unity qui est une fonctionnalité intégrée à unity.

32:44.470 --> 32:50.920
Nous espérons que cela fonctionne à 100% dans toutes les situations, mais il est possible que mon code fonctionne et que

32:50.920 --> 32:52.210
son code ne fonctionne pas.

32:52.210 --> 32:54.520
Il y a donc une zone grise.

32:54.520 --> 32:59.680
Quand vous pensez à la conception de vos classes et ensuite à la conception des tests sur ces classes, comment faites-vous ?

32:59.680 --> 33:01.990
savoir sur quoi vous devez vous concentrer ?

33:01.990 --> 33:04.390
Les tests, d'une manière générale.

33:04.390 --> 33:09.550
Et il y a des livres et des livres écrits sur ce sujet de la façon d'aborder l'art des tests unitaires.

33:09.550 --> 33:15.370
Mais d'une manière générale, vous voulez réduire vos dépendances et simplifier le nombre de tests unitaires.

33:15.370 --> 33:17.530
de lignes de code que vous testez.

33:17.530 --> 33:24.490
Moins de code, c'est mieux, car c'est plus simple et plus ciblé, et vous savez exactement, de manière isolée, quels sont les éléments que vous testez.

33:24.490 --> 33:26.020
code que vous testez.

33:26.020 --> 33:28.000
Voici donc un exemple parfait.

33:28.000 --> 33:32.950
Mais pour nous, c'est un excellent moyen de commencer et de parler de l'exécution de code asynchrone.

33:32.950 --> 33:35.020
Pour l'instant, nous allons terminer cet exemple.

33:42.300 --> 33:44.460
Bonjour et bienvenue à Unit Testing for unity.

33:44.490 --> 33:48.120
Nous allons examiner mon chargeur de données en version avancée.

33:48.120 --> 33:54.270
Pour voir cette démo en action, nous allons ouvrir unity Download et utiliser le projet d'exemple Source pour

33:54.270 --> 33:55.020
ce cours.

33:55.020 --> 33:57.120
Nous allons examiner une scène clé.

33:57.120 --> 33:59.310
Il s'agit du chargeur My Data avancé.

33:59.310 --> 34:05.310
Parmi les concepts dont je vais parler ici, il y a l'injection de dépendances comme nous le voyons et le substitut de fin.

34:05.310 --> 34:11.250
Nous voici à l'intérieur d'unity, j'ai la scène pour le chargeur My Data avancé et prêt à partir ici.

34:11.250 --> 34:16.170
Nous allons donc lancer cette scène pour un grand nombre de scènes de l'atelier.

34:16.170 --> 34:20.940
L'exécution de la scène de production n'est pas la chose la plus intéressante, mais je vous encourage toujours à le faire.

34:20.940 --> 34:21.990
comme point de départ.

34:21.990 --> 34:28.410
Nous voyons ici un simple journal de console qui indique que la longueur des données chargées est la suivante.

34:28.440 --> 34:32.220
Cette valeur n'est pas très importante, mais vous pouvez creuser dans cette classe d'exemple si vous voulez y jeter un coup d'œil

34:32.220 --> 34:32.550
à ce sujet.

34:32.550 --> 34:34.290
Exécutons le test.

34:36.660 --> 34:40.200
Ici, ma catégorie est définie sur mon chargeur de données avancé.

34:40.200 --> 34:44.430
Nous ne voyons donc que les tests liés à cette catégorie et uniquement en mode édition.

34:44.460 --> 34:47.430
Il y a aussi un test en mode lecture que vous pouvez consulter à votre guise.

34:47.430 --> 34:49.710
Mais je pense que le mode édition est plus intéressant ici.

34:49.710 --> 34:51.600
Je vais donc faire le run all.

34:57.250 --> 35:01.540
Et là, nous voyons que nous avons deux tests et qu'ils passent tous les deux avec une coche verte, ce qui est très bien.

35:01.570 --> 35:06.590
Regardons à la fois le load async et le mock load async et regardons comment ils fonctionnent.

35:06.610 --> 35:08.350
Nous voici donc dans l'exemple de code.

35:08.350 --> 35:11.260
Si vous avez suivi la vidéo précédente, et j'espère que c'est le cas.

35:11.290 --> 35:18.760
Nous avons passé en revue la méthode que nous étudions ici, qui utilise un appel réel à un serveur web, qui charge

35:18.760 --> 35:21.000
les données et en vérifie la valeur.

35:21.010 --> 35:24.460
Cela ressemble beaucoup à ce que serait le cas d'utilisation en production ?

35:24.460 --> 35:26.950
Mais nous avons déjà parlé de certains problèmes.

35:26.980 --> 35:31.150
Est-ce que je teste mon code ou est-ce que je teste le service Web Unity qui se trouve en dessous ?

35:31.180 --> 35:35.260
Est-ce que je teste ça ou est-ce que je teste le back-end de github.com ?

35:35.260 --> 35:42.130
Et s'il s'agit d'un serveur stable, vous voulez concentrer vos tests sur votre propre code personnalisé et avoir au moins

35:42.130 --> 35:43.900
et le moins de dépendances possible.

35:43.900 --> 35:46.060
Il y a donc quelques problèmes.

35:46.090 --> 35:51.990
La première chose que j'ai faite quand je me suis penché sur la question, c'est de penser à l'injection de dépendances.

35:52.000 --> 35:58.630
Disons qu'en production, je veux avoir une façon d'appeler ceci et que cela soit implémenté, que

35:58.630 --> 36:00.480
utilise le service web Unity.

36:00.490 --> 36:04.780
Ensuite, pour les tests, j'ai peut-être besoin d'une deuxième approche.

36:04.810 --> 36:11.890
Maintenant, vous pourriez avoir un drapeau dans votre base de code qui dit quelque chose comme "debug" est égal à "true" ou "production".

36:11.890 --> 36:12.790
est égal à faux ?

36:12.790 --> 36:17.360
Et dans votre code de production, faites certaines choses en mode test et d'autres non.

36:17.380 --> 36:21.930
Je vois beaucoup de cela dans les bases de code, mais ce n'est généralement pas une bonne pratique.

36:21.940 --> 36:27.880
Vous polluez votre code de production avec des choses qui ne sont vraiment que pour les tests, donc ce n'est pas aussi approprié.

36:27.910 --> 36:29.320
C'est une meilleure solution.

36:29.320 --> 36:30.700
Voyons ce que nous faisons.

36:31.270 --> 36:37.450
Dans l'exemple de base précédent, je n'avais pas la notion de service réseau, et je n'avais pas non plus passé

36:37.450 --> 36:38.220
ici.

36:38.230 --> 36:41.560
Nous l'avons simplement créé et il a toujours fonctionné d'une seule manière.

36:41.560 --> 36:45.760
Mais l'injection de dépendance ici, c'est moi qui décide.

36:45.760 --> 36:49.170
Voici une façon personnalisée de procéder.

36:49.180 --> 36:53.380
Voici une partie de la logique que je pourrais modifier de différentes façons.

36:53.380 --> 36:56.020
Je le déclare ici en une ligne, puis je le passe.

36:56.020 --> 36:59.560
On peut donc imaginer avoir plusieurs services réseau différents.

36:59.560 --> 37:04.120
Je pourrais en avoir un pour les tests, un autre pour la production, un autre qui écrirait simplement à

37:04.120 --> 37:08.680
un disque local, un qui est approprié pour un serveur backend particulier.

37:08.680 --> 37:09.460
ET cetera.

37:09.490 --> 37:12.160
Il existe également des cas d'utilisation en production.

37:12.160 --> 37:14.060
Cette idée d'injection de dépendance.

37:14.080 --> 37:16.360
Pourquoi l'appelons-nous injection de dépendances ?

37:16.360 --> 37:26.080
C'est parce qu'au lieu que mon chargeur de données avancé fasse toujours une chose, je passe des informations qui décident

37:26.080 --> 37:27.610
comment il va fonctionner.

37:27.610 --> 37:34.090
Donc, plutôt que la classe elle-même sache tout ici, je passe une dépendance dans ce cas à

37:34.090 --> 37:36.250
le service Unity Web Request Network.

37:36.250 --> 37:42.610
Jetons un coup d'œil à la structure de ce service, puis nous verrons pourquoi il est utile pour nous lorsque nous faisons notre

37:42.610 --> 37:43.300
tests.

37:43.390 --> 37:47.140
Voici donc le code source complet du chargeur My Data avancé.

37:47.170 --> 37:49.420
Maintenant, deux choses sur lesquelles je veux me concentrer ici.

37:49.420 --> 37:53.530
La première est que dans son constructeur, je passe cette dépendance.

37:53.560 --> 38:01.060
Maintenant, l'injection de dépendance et comment créer des classes flexibles à partir de ce concept d'injection de dépendance

38:01.060 --> 38:03.700
sont vraiment en dehors du champ d'application de ce cours.

38:03.730 --> 38:06.220
C'est une très bonne chose pour vous d'aller voir.

38:06.220 --> 38:12.730
Vous pourriez googler quelque chose comme D I pour unity ou dependency injection pour unity, ou même dependency

38:12.730 --> 38:17.410
dans la programmation orientée objet, et voir un peu plus de ces concepts généraux.

38:17.410 --> 38:23.160
Mais en supposant que vous avez une certaine familiarité, en particulier compte tenu de mon explication, je viens de donner là,

38:23.170 --> 38:24.460
allons de l'avant.

38:24.490 --> 38:31.810
Maintenant que je passe cela comme une dépendance ici et que je le stocke, alors chaque fois que j'appelle notre fonctionnalité de base

38:31.840 --> 38:38.560
de load async, ce que je fais c'est que je dis, ok, quand je suis prêt à charger async, il suffit de dire à mon service réseau

38:38.560 --> 38:39.730
de charger async.

38:39.730 --> 38:47.020
Maintenant, vous pouvez imaginer si j'ai passé un service réseau qui fait un chargement asynchrone pour un serveur dorsal

38:47.020 --> 38:48.820
d'une technologie particulière.

38:48.850 --> 38:50.410
C'est ce que ferait cette ligne.

38:50.650 --> 38:56.920
Si je passe quelque chose d'autre qui fait une écriture sur le disque ou une lecture du disque d'un type différent

38:56.920 --> 38:59.980
de service réseau, c'est cette ligne qui changerait vraiment.

38:59.980 --> 39:06.130
Ainsi, je n'ai pas besoin d'avoir 2 ou 3 versions différentes de mon chargeur de données avancé ici.

39:06.130 --> 39:11.130
Au lieu de cela, je passe une implémentation personnalisée qui gère ce détail particulier d'une manière unique.

39:11.140 --> 39:15.130
C'est un moyen très puissant de rendre votre code plus flexible.

39:15.130 --> 39:23.410
Maintenant que nous avons parlé du passage d'une dépendance et de la façon dont elle est capable d'envelopper la fonctionnalité

39:23.410 --> 39:26.650
ici, regardons quelle est la source de cette dépendance particulière.

39:26.650 --> 39:31.240
Ici, dans le même fichier de classe, j'ai deux ou trois choses à dire.

39:31.240 --> 39:33.580
Premièrement, j'ai créé une interface.

39:33.700 --> 39:41.230
Cette interface ici de I service de réseau déclare ok, toute personne qui veut être considérée comme viable

39:41.230 --> 39:47.020
dépendance viable à passer ici doit avoir une ou plusieurs méthodes disponibles.

39:47.020 --> 39:51.970
Et dans ce cas, il suffit d'avoir le chargement asynchrone et de prendre une chaîne d'URL.

39:51.970 --> 39:52.720
C'est tout.

39:52.750 --> 39:56.620
Maintenant, si vous n'êtes pas trop familier avec les interfaces.

39:56.940 --> 39:58.560
Allez voir les interfaces.

39:58.560 --> 40:04.290
Vous pouvez regarder quelque chose comme les interfaces par rapport aux classes en C-sharp ou en unity, et vous verrez beaucoup de choses.

40:04.290 --> 40:05.130
d'exemples.

40:05.130 --> 40:11.970
Mais une distinction importante ici est que l'interface définit ce qu'est l'API publique, mais elle ne le fait pas

40:11.970 --> 40:13.980
se préoccupe pas de l'implémentation.

40:14.100 --> 40:17.530
L'implémentation est déclarée ici dans une classe publique.

40:17.560 --> 40:19.710
Maintenant, les classes vous sont probablement plus familières.

40:20.010 --> 40:24.570
Et ce que nous faisons ici, c'est que nous implémentons une saveur particulière de cette classe.

40:24.600 --> 40:30.360
Dans cette version particulière, le service réseau devrait vous sembler très familier, si vous vous reportez à la vidéo précédente.

40:30.390 --> 40:32.760
Il s'agit exactement de la même implémentation.

40:33.030 --> 40:40.130
Nous utilisons simplement unity web request et appliquons la méthodologie d'envoi de requête web.

40:40.140 --> 40:45.510
Maintenant que nous avons regardé le code source, nous pouvons voir, ok, nous créons juste

40:45.510 --> 40:48.270
une classe personnalisée qui gère un peu de la fonctionnalité.

40:48.270 --> 40:50.520
Et nous passons cette classe personnalisée à l'intérieur.

40:50.520 --> 40:55.010
Mais nous avons maintenant une classe avancée de chargeur de données qui est beaucoup plus flexible.

40:55.020 --> 40:59.720
Maintenant, pourquoi l'injection de dépendances est-elle pertinente dans le monde des tests ?

40:59.730 --> 41:05.370
Eh bien, nous avons un merveilleux utilitaire que nous pouvons utiliser dans unity pour nos tests unitaires.

41:05.370 --> 41:10.800
Il s'agit d'une bibliothèque appelée N substitute qui a été incluse dans le projet d'exemple.

41:10.800 --> 41:13.980
Jetons un coup d'œil à une autre méthode de test, juste en dessous de l'autre.

41:13.980 --> 41:17.880
Cette méthode va utiliser ce que l'on appelle un simulacre de classe.

41:17.880 --> 41:23.280
Nous avons donc ici une création très similaire du chargeur My Data avancé.

41:23.280 --> 41:29.070
Au lieu de passer la version de la requête web unity, nous allons faire quelque chose qui ressemble beaucoup à ce que nous avons fait.

41:29.100 --> 41:29.880
étrange ici.

41:29.880 --> 41:32.940
Nous allons utiliser la bibliothèque de substitution.

41:32.940 --> 41:40.260
Et ce que nous allons faire ici, c'est que nous allons dire hey on the fly dans ces deux lignes, allez créer

41:40.260 --> 41:45.000
une classe qui peut gérer la fonctionnalité dont j'ai besoin.

41:45.000 --> 41:51.990
Mais comme il s'agit d'une classe fictive, elle ne doit pas nécessairement appeler le serveur.

41:51.990 --> 41:57.450
Ce qu'elle va faire à la place, c'est, à des moments clés, nous renvoyer une valeur prévisible.

41:57.450 --> 42:06.660
Rappelez-vous, notre flux ici est que le test dit au chargeur de données d'aller charger une URL à l'intérieur des données

42:06.660 --> 42:10.740
Le chargeur de données dit au service réseau de charger une URL.

42:10.770 --> 42:17.430
Cette dernière étape prend une demi-seconde, se charge à partir du serveur et renvoie l'information.

42:17.460 --> 42:18.870
une chaîne de caractères.

42:18.870 --> 42:23.760
Tout ce dont j'ai besoin dans une situation fictive, c'est de ne pas appeler de serveur.

42:23.760 --> 42:27.330
Quand j'appelle ceci, vous me renvoyez une chaîne de caractères.

42:27.330 --> 42:36.750
Donc je dis ici avec ce langage que je veux qu'à chaque fois que j'appelle load async et que je passe n'importe quelle chaîne de caractères

42:36.750 --> 42:41.460
pour l'URL, alors je retourne le mot "mocked data".

42:41.760 --> 42:48.060
Ensuite, je pourrais m'assurer que j'obtiens le résultat attendu, au lieu de vérifier

42:48.060 --> 42:52.020
qu'il y a doctype dans le retour comme je l'ai fait précédemment.

42:52.020 --> 42:55.740
Je peux vérifier les données fictives ici.

42:55.740 --> 43:04.380
Ce que nous voyons ici est un exemple très simple, et cela peut ne pas sembler utile, mais imaginez dans un cas de

43:04.380 --> 43:11.580
exemple plus complexe où nous ne nous contenterions pas de charger des données, mais où nous les chargerions, les lirions, les écririons, les transformerions, etc.

43:11.580 --> 43:14.850
les données, en faisant pas mal de choses, peut-être 5 ou 6 méthodes différentes.

43:14.850 --> 43:21.150
Toutes ces méthodes pourraient pointer vers des systèmes très différents, mais lorsque nous voulons vraiment tester uniquement les

43:21.150 --> 43:30.330
nous voulons passer des capacités simulées pour ces autres systèmes afin qu'ils soient juste temporaires.

43:30.330 --> 43:34.230
ignorées afin que nous puissions nous concentrer sur ce que nous avons à portée de main ici.

43:34.260 --> 43:36.450
Voyons maintenant ce qui se passerait.

43:36.450 --> 43:38.940
J'appelle donc le chargement asynchrone.

43:38.940 --> 43:46.050
Ce qui va se passer, c'est que le système va renvoyer la valeur prédite.

43:46.050 --> 43:50.220
Et le chargeur de données va alors appeler Chargé.

43:50.220 --> 43:56.160
Et sa valeur de résultat sera celle que nous attendons.

43:56.160 --> 44:00.330
Exécutons cette commande dans l'éditeur unity.

44:00.330 --> 44:01.800
Nous allons donc cliquer sur run all ici.

44:04.100 --> 44:05.480
Et cela fonctionne assez rapidement.

44:05.480 --> 44:11.270
Comparons même si j'exécute load async, qui appelle en fait un serveur.

44:15.200 --> 44:16.220
C'était rapide.

44:16.250 --> 44:20.690
Ensuite, si j'appelle le mock load async qui n'appelle aucun serveur.

44:24.630 --> 44:29.840
Ce n'est peut-être pas évident dans la vidéo, mais il est beaucoup plus rapide d'appeler le MOC.

44:29.850 --> 44:35.150
Et c'est logique, car nous n'appelons pas un serveur et n'attendons pas de résultat.

44:35.160 --> 44:38.640
Ce n'est donc pas seulement pour gagner quelques secondes.

44:38.670 --> 44:42.270
C'est encore une fois pour nous permettre de nous concentrer sur la conception de nos tests.

44:42.300 --> 44:44.790
Que voulons-nous réellement tester ?

44:44.790 --> 44:46.920
Et ensuite, nous voulons l'isoler.

44:46.920 --> 44:51.160
Nous ne testons donc pas une classe Unity Web Services.

44:51.180 --> 44:53.610
Nous ne testons pas un back-end GitHub.

44:53.700 --> 44:57.470
Tester plusieurs systèmes ensemble s'appelle un test d'intégration.

44:57.480 --> 44:59.550
C'est un type de test approprié.

44:59.550 --> 45:03.660
Mais il ne correspond pas à ce dont nous parlons ici, à savoir les tests unitaires.

45:03.660 --> 45:08.430
Encore une fois, il s'agit de réduire au maximum les dépendances et les lignes de code.

45:08.430 --> 45:09.450
On peut y réfléchir.

45:09.450 --> 45:17.880
Voilà, nous avons vu comment utiliser la bibliothèque de substitution et comment nous pouvons faire un mock de

45:17.880 --> 45:19.710
un appel au serveur dorsal.

45:19.710 --> 45:20.550
Merci donc.

45:26.450 --> 45:29.420
Bonjour et bienvenue à Unit testing for unity.

45:29.450 --> 45:30.710
Nous sommes dans l'atelier.

45:30.710 --> 45:34.850
Et dans celui-ci, nous allons examiner le personnage dans sa forme de base.

45:34.850 --> 45:37.070
Nous allons en examiner plusieurs.

45:37.100 --> 45:39.800
Nous commencerons par les bases, puis nous passerons à quelque chose de plus avancé.

45:39.800 --> 45:41.480
Jetons un coup d'œil à cette démo en action.

45:41.480 --> 45:42.920
A l'intérieur de l'éditeur unity.

45:42.920 --> 45:45.830
Nous allons ouvrir unity, ouvrir notre projet d'exemple.

45:45.830 --> 45:49.760
Nous allons ensuite jouer une ou plusieurs scènes en rapport avec le sujet traité ici.

45:49.760 --> 45:55.670
La scène sera le personnage de base, et je parlerai du Monobehaviour comme étant quelque chose de

45:55.670 --> 46:01.160
qui peut ou ne peut pas être testé, ainsi que du mode de jeu par rapport au mode d'édition, quelque chose que j'ai déjà mentionné.

46:01.160 --> 46:02.450
plus tôt dans le cours.

46:02.450 --> 46:04.010
Nous en reparlerons ici.

46:04.010 --> 46:06.380
Nous voici dans le projet, en train d'examiner le caractère de base.

46:06.380 --> 46:07.760
Exécutons la scène.

46:13.120 --> 46:20.020
Alors que la plupart des ateliers que nous avons réalisés comportaient déjà une scène assez ennuyeuse dans laquelle il n'y avait absolument rien

46:20.050 --> 46:22.830
rien d'intéressant ne se passait ici, nous avons un peu plus.

46:22.840 --> 46:28.470
Lorsque nous appuyons sur play, nous voyons un cube blanc qui se crée au centre de l'écran.

46:28.480 --> 46:31.030
Je peux utiliser les touches fléchées pour me déplacer.

46:31.030 --> 46:37.930
Bien qu'il s'agisse d'un exemple très simple, il s'agit ici de parler de certains aspects plus complexes de l'utilisation de l'ordinateur.

46:37.930 --> 46:40.600
aspects plus complexes des tests dans unity.

46:40.630 --> 46:45.730
Dans les scènes précédentes, nous ne nous sommes pas préoccupés du rendu des graphiques ou de la prise en compte des données.

46:45.970 --> 46:52.840
Lors du dernier atelier, nous avons parlé de la différence entre tester plusieurs dépendances différentes

46:52.840 --> 46:53.590
ensemble.

46:53.590 --> 46:58.780
Par exemple, une méthode qui appelle à l'intérieur une deuxième méthode qui appelle à l'intérieur une troisième.

46:58.810 --> 47:00.490
Ce sont des dépendances.

47:00.520 --> 47:06.790
Ici, nous parlons d'un aspect similaire, sauf qu'à chaque fois que je veux déplacer mon personnage, je commence par

47:06.790 --> 47:13.750
demander à écouter le système d'entrée d'Unity, puis utiliser le mouvement de transformation Monobehaviour d'Unity.

47:13.750 --> 47:14.190
Bien sûr.

47:14.200 --> 47:18.820
Nous utilisons donc plusieurs dépendances ou classes différentes.

47:21.360 --> 47:24.630
Ici, je peux utiliser les touches fléchées pour me déplacer.

47:25.750 --> 47:27.190
Et c'est à peu près tout.

47:29.010 --> 47:32.100
Mais l'idée est d'en faire un peu plus qu'avant.

47:32.190 --> 47:34.650
Parlons des implications de ce test.

47:34.650 --> 47:41.190
Ici, dans le programme de test, la catégorie est réglée sur notre caractère de base, ce qui est très bien.

47:41.220 --> 47:46.800
Ensuite, je peux basculer pour voir les tests en mode lecture ainsi que les tests en mode édition.

47:46.830 --> 47:53.100
Nous pouvons voir que nous avons un peu des deux, mais parce qu'il y a un monobehaviour impliqué, je vais faire

47:53.100 --> 47:54.600
me concentrer davantage sur le mode de jeu.

47:54.630 --> 48:01.230
Dans chacun des ateliers, j'ai inclus au moins un test en mode édition et au moins un test en mode lecture.

48:01.260 --> 48:03.420
pour la scène en question.

48:03.450 --> 48:09.030
Je l'ai refait ici, mais en fonction de ce que vous testez réellement, vous devez vous demander si c'est bien cela

48:09.030 --> 48:13.470
plus approprié pour le mode édition ou plus approprié pour le mode lecture ?

48:13.500 --> 48:18.510
Il y a un art et une science dans la manière d'aborder cela, et dans la manière de concevoir votre code pour qu'il soit plus

48:18.510 --> 48:19.170
testable.

48:19.200 --> 48:26.010
Mais une façon générale de voir les choses, qui est pertinente ici, est que si vous utilisez la fonctionnalité Monobehaviour,

48:26.010 --> 48:32.460
qui ressemble plus à un test de mode de jeu, plus il y a de bibliothèques unity, en particulier au moment de l'exécution, plus vous êtes en mesure d'utiliser les bibliothèques unity.

48:32.460 --> 48:36.840
vous utilisez dans votre production, vous devez penser à ces tests en mode lecture.

48:36.870 --> 48:40.410
Ce n'est pas une règle absolue, mais c'est une bonne façon de commencer à y penser.

48:40.650 --> 48:42.490
Lançons donc nos tests.

48:42.510 --> 48:45.300
J'ai le mode lecture et je vais tous les exécuter.

48:48.880 --> 48:49.210
D'accord.

48:49.240 --> 48:52.060
L'exécution a pris quelques secondes, mais nous les avons tous.

48:52.090 --> 48:58.060
Ce qui se passe en fait lorsque vous exécutez un test en mode lecture, c'est qu'il crée une toute nouvelle scène vide et

48:58.060 --> 49:01.840
exécute un seul test à l'intérieur, et la détruit.

49:01.840 --> 49:09.040
Et il crée une toute nouvelle scène garantissant que nous disposons de l'espace mondial fourni par une scène.

49:09.040 --> 49:16.000
Mais la fraîcheur d'une nouvelle scène qui n'a pas de dépendances ou d'informations périmées susceptibles d'influencer l'espace mondial.

49:16.000 --> 49:16.630
le test.

49:16.630 --> 49:18.230
Nous aimons donc la façon dont cela est mis en place.

49:18.250 --> 49:25.030
Maintenant, les choses que je fais sont le déplacement, le déplacement par code clé et le déplacement vers un endroit particulier.

49:25.030 --> 49:27.640
Jetons un coup d'œil à ce déplacement vers le test.

49:29.650 --> 49:31.990
En fait, regardons d'abord le code de production.

49:31.990 --> 49:34.960
Donc si je vais ici et que je regarde l'exemple de base.

49:36.760 --> 49:38.560
Voici le code de production.

49:38.560 --> 49:40.720
Regardons-le avant de passer aux tests.

49:40.720 --> 49:43.960
Ici, tout ce que je fais, c'est créer une primitive.

49:43.990 --> 49:49.030
On peut aussi imaginer charger un préfabriqué ici si on veut le faire.

49:49.030 --> 49:54.010
Mais je voulais nous faire entrer lentement dans toutes les complexités du runtime et de unity.

49:54.010 --> 49:56.140
Je n'utilise donc pas de prefab ici.

49:56.140 --> 50:00.130
Je crée un tout nouveau cube à partir de zéro avec une ligne de code.

50:00.130 --> 50:06.820
Je lui donne un nom pour des raisons d'organisation, puis j'ajoute le composant du monobehaviour

50:06.820 --> 50:08.620
que je veux tester.

50:08.650 --> 50:14.770
L'une des choses que je fais est de le déplacer jusqu'au point 000, puis de montrer que

50:14.770 --> 50:16.300
sur l'écran.

50:16.300 --> 50:18.850
Jetons un coup d'œil au code source.

50:21.530 --> 50:22.960
Voici le caractère de base.

50:22.970 --> 50:24.770
Ceci étend le Monobehaviour.

50:24.800 --> 50:32.730
Maintenant, si vous êtes familier avec unity, vous utilisez probablement les Monobehaviours tout le temps comme une bonne pratique.

50:32.750 --> 50:35.600
Vous voulez commencer à réfléchir consciencieusement.

50:35.600 --> 50:40.660
Quand est-il approprié d'utiliser un comportement unique et quand puis-je utiliser quelque chose de différent ?

50:40.670 --> 50:46.580
En tant que développeurs débutants, nous créons tout comme un enfant de monobehaviour, mais avec le temps et l'expérience

50:46.580 --> 50:49.900
on se rend compte qu'il y a des avantages et des inconvénients à utiliser des monobehaviours.

50:49.910 --> 50:54.620
L'un des inconvénients est que, historiquement, il était plus difficile d'effectuer des tests en cours de route.

50:54.620 --> 50:56.570
Unity a fourni ces tests de mode de jeu.

50:56.570 --> 51:00.950
Nous pouvons donc maintenant tester Playmode et Monobehaviours.

51:00.950 --> 51:03.630
C'est très bien, mais il y a encore quelques inconvénients.

51:03.650 --> 51:08.330
Encore une fois, Monobehaviour va s'appuyer sur plus de systèmes d'unité sous le capot.

51:08.330 --> 51:13.700
Et lorsque nous essayons de tester notre code personnalisé, il se peut que nous ne soyons pas sûrs de l'origine du problème.

51:13.730 --> 51:15.720
Est-ce notre code ou celui d'Unity ?

51:15.740 --> 51:18.110
Encore une fois, il y a quelques dépendances.

51:18.140 --> 51:22.280
Ce n'est pas grave, mais c'est quelque chose auquel vous devez penser lorsque vous concevez vos classes et que vous avez besoin d'aide.

51:22.280 --> 51:23.690
vous concevez vos tests.

51:24.110 --> 51:27.080
Nous avons donc une vitesse de déplacement.

51:27.110 --> 51:28.460
Nous avons un type de mouvement.

51:28.460 --> 51:31.390
Il s'agit simplement de la direction de la touche fléchée sur laquelle j'appuie.

51:31.400 --> 51:33.680
Nous utilisons ensuite la mise à jour de Unity.

51:33.710 --> 51:36.530
Maintenant, permettez-moi de revérifier.

51:38.720 --> 51:39.230
C'est vrai.

51:39.230 --> 51:44.960
La boucle de mise à jour est la seule fonctionnalité majeure du monobehaviour que j'utilise.

51:44.990 --> 51:49.130
Le reste du code n'a pas nécessairement besoin d'être dans un monobehaviour.

51:49.220 --> 51:53.560
J'utilise aussi le système d'entrée de Unity, donc c'est une deuxième dépendance.

51:53.570 --> 51:56.760
Voyons ce que je fais à chaque image de la mise à jour.

51:56.780 --> 51:59.360
J'appelle cette méthode ici move by input.

51:59.390 --> 52:04.340
Je vérifie si l'utilisateur appuie sur une ou plusieurs touches du clavier.

52:04.340 --> 52:08.360
Ensuite, j'appelle le déplacement par code de touche ici.

52:09.710 --> 52:16.220
Tout ce que nous faisons, c'est dire, si nous nous déplaçons actuellement vers la gauche, alors déplaçons-nous dans un vecteur pour la direction gauche.

52:16.220 --> 52:19.820
Si nous nous déplaçons actuellement vers la droite, et ainsi de suite pour le haut et le bas.

52:19.820 --> 52:24.860
Cela vous permet donc de vous déplacer dans les quatre directions à l'aide des quatre touches fléchées.

52:24.860 --> 52:26.420
Le code est donc assez simple.

52:26.420 --> 52:30.440
Si vous avez déjà créé votre propre personnage personnalisé, vous savez que vous devez définir quelque chose comme

52:30.440 --> 52:30.980
ceci.

52:34.010 --> 52:35.870
Ici, nous avons deux méthodes.

52:35.870 --> 52:41.240
Une qui nous permet de nous déplacer vers un point particulier et une qui nous permet de nous déplacer d'une unité.

52:41.240 --> 52:44.090
Supposons que je veuille déplacer la droite d'une unité.

52:44.090 --> 52:48.490
Je pourrais passer d'une unité à l'autre d'une unité à l'autre d'une unité à l'autre.

52:48.500 --> 52:53.740
Si je veux me déplacer directement vers un point particulier de l'espace, ce sera le déplacement vers.

52:53.750 --> 52:59.810
Ce ne sont pas nécessairement les seules méthodes dont vous aurez besoin dans une classe de personnage personnalisée, mais il y a aussi

52:59.810 --> 53:01.100
quelques méthodes assez courantes.

53:01.100 --> 53:07.850
Nous terminerons donc cette leçon avec ceci comme moyen de base, approprié, pour tester certaines fonctionnalités.

53:07.850 --> 53:13.340
Si vous voulez jeter un coup d'œil au mode édition ou aux autres tests qui sont ici en mode lecture, allez-y

53:13.340 --> 53:14.230
et faites-le.

53:14.240 --> 53:15.830
Je passe à la vidéo suivante.

53:15.830 --> 53:16.580
Je vous remercie.

53:22.920 --> 53:26.060
Bonjour et bienvenue à Unit Testing for unity.

53:26.070 --> 53:30.060
Dans cet atelier, nous examinons la classe de personnage dans une version avancée.

53:30.060 --> 53:31.980
Regardons cette démo en action.

53:31.980 --> 53:32.310
Ici.

53:32.310 --> 53:33.990
Nous allons ouvrir notre unité.

53:34.020 --> 53:36.000
Nous allons ouvrir notre projet d'exemple.

53:36.000 --> 53:41.190
Et nous allons jeter un coup d'œil à une scène à l'intérieur de la situation avancée du personnage ici.

53:41.190 --> 53:44.310
Je voudrais parler un peu de la séparation des codes.

53:44.340 --> 53:49.110
Plus tôt dans l'un des ateliers, j'ai parlé des différentes dépendances que l'on peut avoir.

53:49.110 --> 53:51.360
Par exemple, si vous appelez un serveur d'arrière-plan.

53:51.360 --> 53:58.530
Dans ce cas, nous avons utilisé une bibliothèque de substitution pour nous moquer et ne pas avoir à appeler le serveur dorsal.

53:58.560 --> 54:04.890
Il s'agit d'une discussion similaire ici, où nous examinons les dépendances impliquées par une bibliothèque particulière.

54:04.890 --> 54:11.640
scénario de test particulier, et comment sommes-nous conscients de ces différentes dépendances, et que voulons-nous faire à ce sujet ?

54:11.640 --> 54:12.240
ici ?

54:12.240 --> 54:14.400
Nous n'allons pas utiliser la bibliothèque de substitution.

54:14.430 --> 54:18.960
Nous allons penser à séparer notre monobehaviour du reste du code et à y jeter un coup d'œil.

54:19.170 --> 54:20.940
Nous voici donc à l'intérieur de unity.

54:21.270 --> 54:22.440
Nous avons une classe de production.

54:22.440 --> 54:23.250
Jetons-y un coup d'œil.

54:23.250 --> 54:23.850
En cours d'exécution.

54:27.540 --> 54:30.510
Ici, nous voyons que nous pouvons nous déplacer à l'aide des touches fléchées.

54:30.510 --> 54:34.050
Comme dans l'exemple de base, l'expérience de l'utilisateur final est la même.

54:34.050 --> 54:39.330
Il s'agit là d'un exemple intéressant : certains des changements que nous apportons au code

54:39.330 --> 54:44.250
qualité du code et la testabilité de nos systèmes n'ont pas nécessairement d'impact sur l'utilisateur final.

54:44.280 --> 54:45.350
C'est un point positif.

54:45.360 --> 54:48.270
Jetons un coup d'œil au code de production.

54:48.270 --> 54:50.340
Nous allons ouvrir l'exemple de caractère avancé.

54:50.340 --> 54:51.890
Voici un exemple complet.

54:51.900 --> 54:57.830
Ce que nous faisons dans le sillage de cette classe d'exemple, c'est que nous créons une primitive pour le cube.

54:57.840 --> 55:00.270
Nous lui donnons un nom pour des raisons d'organisation.

55:00.390 --> 55:08.010
Ensuite, au lieu d'une ligne ici où nous ajoutons simplement un composant qui a toutes nos fonctionnalités, nous faisons

55:08.010 --> 55:09.180
deux étapes.

55:09.450 --> 55:14.700
Cela me rappelle un peu l'injection de dépendance que nous avons vue dans l'exemple du chargeur de données.

55:14.700 --> 55:17.970
Mais il s'agit d'un cas d'utilisation différent avec des dépendances différentes.

55:17.970 --> 55:22.920
Donc, au lieu d'une seule ligne d'ajout de composant, nous faisons l'ajout de composant.

55:22.920 --> 55:28.260
Puis nous créons notre propre classe avancée de caractère non monobehaviour.

55:28.260 --> 55:30.540
Et nous passons le Monobehaviour.

55:30.540 --> 55:35.370
Nous passons donc la dépendance que le caractère avancé va utiliser.

55:35.400 --> 55:41.910
Maintenant, le caractère avancé n'est pas un comportement unique, et nous avons donc plus de flexibilité sur la façon dont nous voulons qu'il soit utilisé.

55:41.910 --> 55:42.480
de le tester.

55:42.510 --> 55:45.780
Nous pourrions le tester en mode édition, par exemple, plus facilement.

55:45.930 --> 55:51.000
Encore une fois, lorsque vous utilisez des Monobehaviours, c'est plus approprié pour les tests en mode lecture.

55:51.030 --> 55:53.940
Ce n'est pas une règle absolue, mais c'est une façon de voir les choses.

55:53.940 --> 56:00.660
Ici, en séparant notre monobehaviour de notre non-monobehaviour, nous avons un peu plus d'options.

56:00.690 --> 56:06.060
Nous sommes toujours dans un environnement en mode "play play" car il s'agit du code de production.

56:06.060 --> 56:08.970
Entrons et voyons comment notre code source est modifié.

56:08.970 --> 56:11.010
Nous voici donc dans le caractère avancé.

56:11.040 --> 56:13.220
Vous verrez que cela nous est assez familier.

56:13.230 --> 56:17.790
La majeure partie du code ici sera identique à l'exemple de base précédent.

56:17.800 --> 56:19.080
Les quelques exceptions.

56:19.090 --> 56:25.710
L'une d'entre elles est que le caractère avancé va prendre une référence dans son constructeur vers le Monobehaviour.

56:25.710 --> 56:30.900
C'est parce qu'il a besoin de savoir certaines choses sur le Monobehaviour, en particulier en ce qui concerne sa transformation

56:30.900 --> 56:31.710
position.

56:31.830 --> 56:38.400
Il y a également une situation où nous devons utiliser la deuxième ligne et indiquer une référence au Monobehaviour

56:38.400 --> 56:40.830
qui nous renvoie à l'avancement du caractère.

56:40.860 --> 56:47.460
C'est juste pour que le Monobehaviour, à chaque fois qu'il appelle la mise à jour, puisse nous dire de faire le mouvement approprié.

56:47.490 --> 56:52.950
Il y a d'autres façons d'organiser cela, mais pour des raisons de simplicité, nous passons dans le monobehaviour

56:52.950 --> 56:54.360
et nous le traitons de cette manière.

56:54.660 --> 56:57.150
Voyons quels sont les autres changements dans la base de code.

56:58.510 --> 57:00.820
Le type de déplacement est identique à celui de la base.

57:00.850 --> 57:03.040
Le déplacement par entrée est le même.

57:03.940 --> 57:08.260
Ici, le déplacement par code de clé est très similaire, voire identique.

57:09.300 --> 57:15.630
Et ici, dans le déplacement vers et le déplacement par, vous pouvez remarquer que nous obtenons et définissons la position

57:15.630 --> 57:18.300
sur la transformation du Monobehaviour.

57:18.300 --> 57:25.260
Encore une fois, nous avons une classe qui n'est pas un monobehaviour et qui fait ce qu'elle peut faire sans dépendre de

57:25.260 --> 57:30.810
monobehaviour et ce n'est que dans les endroits les plus nécessaires qu'elle s'adresse au monobehaviour.

57:30.840 --> 57:36.840
Cette séparation commence à nous aider à réfléchir à la façon dont nous pourrions tester uniquement le monobehaviour si nous le pouvions,

57:36.840 --> 57:39.910
comment pourrions-nous tester uniquement le comportement non monobloc si nous le pouvions ?

57:39.930 --> 57:45.240
Maintenant, ce n'est pas un exemple parfait parce qu'il s'agit d'une sorte d'étape intermédiaire au fur et à mesure que nous apprenons à propos de

57:45.240 --> 57:47.040
comment les séparer correctement.

57:47.040 --> 57:48.600
Mais je pense que c'est un bon apprentissage.

57:48.600 --> 57:52.500
Regardez donc le code source ici pour le caractère avancé.

57:52.500 --> 57:56.550
Comparez-le à character basic sur votre propre temps et voyez les différences.

57:56.730 --> 57:59.580
Regardons ensuite l'exemple que nous faisons.

57:59.580 --> 57:59.970
Encore une fois.

57:59.970 --> 58:01.500
Voici l'exemple que nous avons vu.

58:01.500 --> 58:02.670
Il s'agit donc de ces deux lignes.

58:02.670 --> 58:03.900
C'est vraiment la clé.

58:03.930 --> 58:09.960
Nous allons ajouter un composant du Monobehaviour avancé sur notre objet de jeu.

58:09.960 --> 58:12.270
Puis nous allons créer un nouveau personnage avancé.

58:12.270 --> 58:13.440
C'est une étape distincte.

58:13.440 --> 58:17.010
On peut donc imaginer qu'il est possible de tester ces deux choses de manière isolée.

58:17.010 --> 58:19.320
Or, elles sont très dépendantes l'une de l'autre.

58:19.350 --> 58:24.000
Il y a des moyens de masser cela pour que l'un ne dépende pas directement de l'autre.

58:24.000 --> 58:30.330
Ou nous pourrions faire quelque chose comme nous l'avons fait dans l'exemple du chargeur de données et utiliser une bibliothèque de substitution de sorte que

58:30.330 --> 58:32.730
nous nous moquons de la dépendance à la place.

58:32.730 --> 58:38.400
Mais encore une fois, pour simplifier l'apprentissage de la séparation d'un monobehaviour, je pense que nous avons fait

58:38.400 --> 58:39.210
le cas ici.

58:39.210 --> 58:44.100
Vous pouvez exécuter ces tests avec le mode édition et le mode lecture à votre guise et jeter un coup d'oeil à ceci.

58:44.370 --> 58:50.460
Mais pour moi, je pense que nous avons fini de parler des différences entre les comportements monoblocs et les comportements non monoblocs.

58:50.490 --> 58:51.120
Merci.

58:57.320 --> 58:59.600
Bonjour et bienvenue à Unit Testing for unity.

58:59.630 --> 59:02.630
Voici notre atelier consacré à la physique des personnages.

59:02.660 --> 59:09.110
Dans les ateliers précédents, nous sommes lentement passés d'un exemple de personnage très simple, se déplaçant à l'aide d'une flèche

59:09.110 --> 59:14.960
jusqu'à l'exemple avancé séparant les préoccupations monobéhavioristes et non monobéhavioristes.

59:14.960 --> 59:20.900
Et ici, dans cet exemple, nous allons parler de ce qui se passe si nous dépendons d'un autre système d'unité comme la physique.

59:20.900 --> 59:26.720
Et lorsque nous utilisons la physique dans cet exemple particulier, notre mouvement devient plus flou.

59:26.720 --> 59:30.890
Cela signifie que je ne clique pas à gauche et qu'il se met immédiatement en position.

59:30.890 --> 59:32.930
Il se déplace lentement au fil du temps.

59:32.930 --> 59:37.100
Comment pourrions-nous tester la valeur qui change lentement au fil du temps ?

59:37.100 --> 59:40.220
Nous allons donc aborder quelques-unes de ces questions dans le code source.

59:40.220 --> 59:45.290
Pour jeter un coup d'œil à cette démo, nous ouvrons notre éditeur unity et le projet d'exemple.

59:45.290 --> 59:48.020
La scène ici va être la scène physique du personnage.

59:48.020 --> 59:51.720
L'une des choses que nous allons étudier est la manière de tester ces valeurs floues.

59:51.740 --> 59:58.640
Pour moi, les valeurs floues sont des valeurs qui ne sont pas nécessairement instantanées, passant de

59:58.640 --> 1:00:05.960
A à B, elles s'animent lentement dans le temps, comme la position d'un objet ou un score qui s'anime progressivement.

1:00:05.960 --> 1:00:06.890
compte à rebours.

1:00:06.920 --> 1:00:12.110
Il s'agit là de domaines dans lesquels il est souhaitable de pouvoir tester quelque chose au fil du temps, et nous disposons d'une approche facile à mettre en œuvre

1:00:12.110 --> 1:00:13.250
pour le faire.

1:00:13.250 --> 1:00:17.750
Ce n'est pas la seule façon de résoudre le problème, mais je pense qu'elle nous aide à apprendre en cours de route.

1:00:17.750 --> 1:00:18.770
Jetons donc un coup d'œil.

1:00:18.770 --> 1:00:20.420
Nous voici donc dans le projet unity.

1:00:20.420 --> 1:00:22.940
Nous avons ouvert l'exemple de physique des personnages.

1:00:22.940 --> 1:00:24.500
Exécutons la scène.

1:00:30.610 --> 1:00:33.520
Ici, je peux me déplacer à l'aide des touches fléchées.

1:00:37.390 --> 1:00:42.970
Et dans les exemples précédents, ici dans l'atelier, nous avons vu qu'il cliquait sur chaque clic que je faisais sur la gauche

1:00:42.970 --> 1:00:48.430
la position changeait instantanément, mais ici, le mouvement est plus régulier.

1:00:49.060 --> 1:00:54.250
Je peux toujours utiliser toutes les touches fléchées pour diriger les différents trafics dans la direction souhaitée, mais l'idée est la suivante

1:00:54.250 --> 1:00:58.030
d'un mouvement lent dans le temps est vraiment la nouvelle situation actuelle.

1:00:58.030 --> 1:01:03.790
Il y a beaucoup de façons de faire cela dans unity, mais j'ai choisi d'utiliser le système de physique pour parler de ce qui suit.

1:01:03.790 --> 1:01:08.920
un peu de ce qui se passe si nous avons plus de systèmes unity impliqués.

1:01:08.920 --> 1:01:10.960
Vous vous souvenez de ce que nous avons étiré ?

1:01:10.960 --> 1:01:18.130
L'idée est que, dans un monde idéal, les tests unitaires testent le moins de lignes possible de ce qui suit

1:01:18.130 --> 1:01:21.760
dépendance, le moins de lignes de code possible à la fois.

1:01:21.760 --> 1:01:25.600
Mais bien souvent, notre code de production n'est pas aussi simpliste.

1:01:25.600 --> 1:01:27.520
Nous dépendons de différentes choses.

1:01:27.520 --> 1:01:33.370
Avec mon chargeur de données et les exemples de caractères précédents, nous avons vu quelques façons de gérer les éléments suivants

1:01:33.370 --> 1:01:35.080
ces différentes dépendances.

1:01:35.200 --> 1:01:38.260
Voici un autre exemple un peu plus complexe que les autres.

1:01:38.290 --> 1:01:40.240
Jetons un coup d'œil au code de production.

1:01:40.240 --> 1:01:43.120
Nous allons donc examiner ici l'exemple de la physique des personnages.

1:01:44.530 --> 1:01:45.790
On l'ouvre ?

1:01:47.210 --> 1:01:50.570
Et ici, nous avons créé une primitive de personnage.

1:01:51.320 --> 1:01:59.840
Ici, nous créons d'abord l'objet de jeu avec le cube en apparence pour la primitive, puis nous ajoutons

1:01:59.840 --> 1:02:03.500
le composant du monobehaviour physique du personnage.

1:02:03.500 --> 1:02:07.070
Et puis nous avons une classe de physique des personnages séparée que nous prenons là-dedans.

1:02:07.070 --> 1:02:12.740
Nous nous séparons donc déjà d'une classe monolithique de comportement unique en deux classes.

1:02:12.740 --> 1:02:18.350
C'est donc un bon moyen de rendre notre code plus simpliste et de ne faire qu'une seule chose à la fois.

1:02:18.350 --> 1:02:25.640
Nous avons vu dans l'exemple précédent que la plupart des fonctionnalités du Monobehaviour dont nous avions besoin étaient juste la mise à jour.

1:02:25.640 --> 1:02:27.680
C'est la seule chose dont nous devions vraiment nous occuper.

1:02:27.710 --> 1:02:33.110
Donc, en déplaçant toutes les choses qui ne sont pas des mises à jour dans la deuxième classe, nous avons maintenant quelque chose qui est plus facile à mettre en place.

1:02:33.110 --> 1:02:33.740
test.

1:02:36.450 --> 1:02:39.570
Dans cet exemple simple, nous nous sommes déplacés vers une position particulière.

1:02:39.600 --> 1:02:43.710
Exécutons maintenant les tests et jetons un coup d'œil au code de production.

1:02:43.740 --> 1:02:46.500
Voyons maintenant l'exécution de la sélection.

1:02:48.580 --> 1:02:49.830
Tout fonctionne ici.

1:02:49.850 --> 1:02:50.850
Tout passe.

1:02:50.870 --> 1:02:52.640
Il ne reste plus que le test du mode lecture.

1:02:52.640 --> 1:02:57.110
Mais nous avons aussi des tests en mode édition si vous voulez creuser et jeter un coup d'œil à nouveau, parce que nous sommes en train de faire des tests en mode édition.

1:02:57.110 --> 1:02:58.950
nous avons affaire à des comportements monoblocs.

1:02:58.970 --> 1:03:01.340
Il semble plus approprié d'utiliser un mode de jeu.

1:03:01.340 --> 1:03:02.990
C'est donc l'approche que j'ai adoptée ici.

1:03:02.990 --> 1:03:06.470
Mais c'est à vous et à votre projet de décider quels systèmes vous voulez tester.

1:03:06.500 --> 1:03:08.230
Mode édition et ceux que vous voulez tester.

1:03:08.240 --> 1:03:08.840
Mode lecture.

1:03:15.570 --> 1:03:21.000
Maintenant que nous avons vu ces tests, jetons un coup d'oeil rapide au code source de la classe.

1:03:21.000 --> 1:03:22.660
Ensuite, nous regarderons certains des tests par-dessus.

1:03:22.710 --> 1:03:22.860
Très bien.

1:03:22.860 --> 1:03:24.780
Nous voici donc dans la physique des personnages.

1:03:24.810 --> 1:03:28.870
Nous allons voir que c'est assez similaire au personnage avancé que nous avons vu la dernière fois.

1:03:28.890 --> 1:03:32.850
Nous avons à nouveau séparé la classe Monobehaviour et la classe non monobehaviour.

1:03:32.850 --> 1:03:36.630
Voici donc la classe non monobehaviour qui fait le plus gros du travail.

1:03:36.660 --> 1:03:42.840
Remarquez qu'à l'intérieur de son constructeur, elle prend une référence au Monobehaviour et la stocke, puis

1:03:42.840 --> 1:03:47.670
transmet également au Monobehaviour une référence à cette classe.

1:03:47.670 --> 1:03:51.900
C'est pour pouvoir appeler le move by à chaque fois qu'il fait une mise à jour.

1:03:51.930 --> 1:03:53.970
Il y a différentes façons d'organiser cela.

1:03:53.970 --> 1:03:57.810
Vous pourriez même supprimer la dépendance codée en dur que nous avons l'un envers l'autre ici.

1:03:57.810 --> 1:04:01.350
Mais pour des raisons de simplicité dans cet exemple, c'est tout à fait approprié.

1:04:01.740 --> 1:04:02.790
On descend dans le code.

1:04:02.790 --> 1:04:05.820
Encore une fois, c'est comme l'avancé dans la plupart des parties.

1:04:05.850 --> 1:04:08.670
Je tiens à signaler les endroits où la physique est utilisée.

1:04:08.670 --> 1:04:16.920
Donc ici dans le mouvement, au lieu de simplement se déplacer par la position codée en dur sur une instance Taneous update,

1:04:16.950 --> 1:04:20.340
nous allons utiliser la position de déplacement ici.

1:04:20.340 --> 1:04:25.890
Et puis sous Add force, qui est une nouvelle méthode que j'ai créée et qui va se déplacer en se basant sur la physique

1:04:25.890 --> 1:04:26.580
forces.

1:04:26.580 --> 1:04:30.630
Imaginons qu'il s'agisse d'un bloc et que nous exercions une poussée d'un côté.

1:04:30.630 --> 1:04:36.390
Et en se basant sur la friction, la masse et la gravité, on sait qu'il y a une sorte de conséquence qui tend à

1:04:36.390 --> 1:04:39.240
à être une réaction plus floue ici en utilisant la force ajoutée.

1:04:39.240 --> 1:04:45.570
Et nous nous déplaçons en ajoutant une force ici, en haut du même fichier de classe, nous voyons le monobehaviour physique

1:04:45.600 --> 1:04:46.590
est déclaré.

1:04:46.590 --> 1:04:52.560
C'est assez familier dans la mesure où le même caractère avancé que nous avons vu dans le dernier atelier est assez similaire,

1:04:52.560 --> 1:04:55.350
mais nous avons ici un corps rigide que nous stockons.

1:04:55.350 --> 1:05:02.010
Et lorsque cette classe se réveille, nous attachons le corps rigide et définissons la physique.

1:05:02.010 --> 1:05:02.670
valeurs.

1:05:02.670 --> 1:05:09.450
Donc, si nous pensons à une sorte de récapitulation au lieu d'avoir un monobehaviour qui fait toute la physique

1:05:09.450 --> 1:05:14.220
et le mouvement ensemble, nous avons séparé le monobehaviour du non-monobehaviour.

1:05:14.250 --> 1:05:20.520
Ensuite, à l'intérieur du monobehaviour, nous effectuons la boucle de mise à jour et nous nous occupons également de certains aspects physiques.

1:05:20.610 --> 1:05:26.550
Ensuite, à partir de l'autre, le non-monobehaviour, nous sommes capables de nous déplacer comme nous le voulons et de prendre en compte l'entrée du personnage,

1:05:26.580 --> 1:05:28.470
donc de saisir des données au clavier et des choses comme ça.

1:05:28.470 --> 1:05:32.940
Il s'agit donc d'une bonne séparation qui nous permet d'aller de l'avant avec ce dont nous avons besoin.

1:05:34.100 --> 1:05:37.820
Laissez-moi réfléchir à haute voix s'il y a quelque chose d'autre que je voudrais mentionner à ce sujet.

1:05:38.330 --> 1:05:40.430
Euh, oui.

1:05:40.430 --> 1:05:42.620
J'ai donc évoqué l'idée ici.

1:05:42.620 --> 1:05:50.720
Si vous vouliez réduire la dépendance codée en dur que nous avons chaque classe dépendant de l'autre et

1:05:50.720 --> 1:05:56.270
obtenir plus de flexibilité comme nous l'avons vu dans l'exemple du chargeur My Data, vous pourriez certainement déclarer

1:05:56.270 --> 1:05:58.670
et l'aborder de cette façon.

1:05:58.970 --> 1:06:00.680
Mais nous n'avons pas besoin de le faire ici.

1:06:00.680 --> 1:06:03.370
Nous allons simplement revenir en arrière et exécuter l'exemple une fois de plus.

1:06:03.380 --> 1:06:07.700
Ici, dans unity, nous sommes en cours d'exécution et nous avons les touches fléchées qui se déplacent.

1:06:07.730 --> 1:06:13.130
Dans les dernières vidéos, nous avons vu des exemples de réduction de la complexité.

1:06:13.130 --> 1:06:17.870
En réduisant les différentes dépendances, on obtient une certaine flexibilité qui permet de séparer notre code.

1:06:17.870 --> 1:06:23.480
Donc, pour cet exemple, en utilisant l'entrée et la physique et les monobehaviours ou des choses comme ça, j'ai

1:06:23.480 --> 1:06:24.620
Je pense que nous avons terminé.

1:06:24.650 --> 1:06:25.340
Merci.

1:06:31.470 --> 1:06:31.730
Bonjour.

1:06:31.740 --> 1:06:37.470
Cela couvre une grande partie des différents sujets que je voulais aborder dans l'atelier jusqu'à présent, mais il y a

1:06:37.470 --> 1:06:39.990
beaucoup de place pour d'autres sujets à l'avenir.

1:06:39.990 --> 1:06:42.390
Nous avons vu dans les ateliers couverts jusqu'à présent.

1:06:42.390 --> 1:06:49.350
Cet exemple le plus simple nous permet d'apprendre à utiliser le test runner, de voir comment nous pouvons faire des tests en mode lecture, des tests en mode édition,

1:06:49.380 --> 1:06:54.870
apprendre un peu sur les différences entre le mode lecture et le mode édition, et pourquoi vous voudriez tester

1:06:54.870 --> 1:06:57.350
dans l'un ou l'autre, ou dans les deux.

1:06:57.360 --> 1:07:03.510
Nous avons également vu quelques-unes des options dont nous disposons lorsque nous avons une fonctionnalité asynchrone, ou lorsque nous sommes

1:07:03.510 --> 1:07:05.460
dépendons d'autres systèmes.

1:07:05.460 --> 1:07:09.990
Que pourrions-nous faire pour réduire cette dépendance dans l'intérêt du test ?

1:07:10.020 --> 1:07:15.180
En cours de route, nous apprenons différentes choses sur l'injection de dépendance et la séparation

1:07:15.180 --> 1:07:16.650
les préoccupations de notre code.

1:07:16.680 --> 1:07:22.710
Ces principes sont de toute façon utiles dans le code de production, et nous commençons à voir certains des moyens

1:07:22.710 --> 1:07:29.850
que lorsque vous préparez votre code pour qu'il soit plus testable, nous créons également un code qui est bien conçu

1:07:29.850 --> 1:07:31.080
pour la production.

1:07:31.080 --> 1:07:37.710
L'injection de dépendances permet donc une flexibilité que l'on peut utiliser au moment de l'exécution, ce qui réduit la complexité.

1:07:37.710 --> 1:07:44.370
de vos systèmes en passant par des variétés flexibles de différentes dépendances lorsque vous en avez besoin.

1:07:44.400 --> 1:07:51.960
Nous avons également constaté qu'en séparant un grand comportement monolithique en seulement ce dont nous avons besoin du comportement monolithique

1:07:51.960 --> 1:07:58.620
et en déplaçant le reste du code dans une classe non monobehaviour plus légère, nous obtenons à nouveau une certaine flexibilité.

1:07:58.620 --> 1:08:03.570
qui est utile en production et qui nous aide également dans le monde des tests.

1:08:03.570 --> 1:08:10.170
Je pense qu'en général, certains des défis que nous voyons sont ce qui se passe lorsque vous avez des dépendances multiples.

1:08:10.200 --> 1:08:14.670
ou de nombreux systèmes appelés à partir d'une méthode particulière.

1:08:15.060 --> 1:08:20.700
Cela peut être le signe que cette méthode est surchargée et qu'elle en fait trop, ou bien qu'elle est

1:08:20.700 --> 1:08:23.130
une méthode allégée et bien conçue.

1:08:23.130 --> 1:08:28.800
Mais nous devons avoir quelques réflexions et considérations supplémentaires lorsque nous testons cette fonctionnalité.

1:08:28.800 --> 1:08:31.050
J'espère que cela vous a été utile.

1:08:31.050 --> 1:08:38.130
J'ai hâte d'aborder d'autres sujets dans cette série, et ils seront ajoutés au fur et à mesure.

1:08:38.130 --> 1:08:38.610
temps.

1:08:38.610 --> 1:08:39.750
Merci encore.
