WEBVTT

00:00.410 --> 00:03.080
Bonjour et bienvenue à l'Intelligence Artificielle.

00:03.080 --> 00:07.700
Ici, nous utilisons l'intelligence artificielle pour nous aider à créer un code de test unitaire.

00:07.700 --> 00:12.530
L'intégration de l'intelligence artificielle dans le développement d'un jeu permet de rationaliser le développement et les tests.

00:12.530 --> 00:17.480
Certains de ces avantages sont présentés ici, et nous allons nous concentrer sur les tests automatisés.

00:17.780 --> 00:23.060
L'IA peut rapidement identifier et corriger vos bogues, et elle peut réduire le temps de création des tests.

00:23.060 --> 00:28.580
L'approche traditionnelle sans IA consisterait à créer le code de production.

00:28.580 --> 00:34.040
Et ensuite, si vous adoptez les tests unitaires, de créer manuellement ces tests au fur et à mesure.

00:34.070 --> 00:40.430
Nous avons vu dans la vidéo précédente comment l'IA peut nous aider à créer notre code de production pour une partie ou la totalité d'un projet.

00:40.430 --> 00:41.060
système de jeu.

00:41.060 --> 00:47.000
Voyons maintenant comment l'IA peut nous aider à automatiser le processus de création de nos tests unitaires.

00:47.000 --> 00:52.160
Nous avons un chat GPT existant, ouvert avec la façon dont nous avons créé le code de production.

00:52.160 --> 00:58.070
Il est maintenant très important que je continue dans ce même chat lorsque je commencerai à poser les questions suivantes.

00:58.070 --> 00:59.450
sur les tests unitaires.

01:00.370 --> 01:06.670
Si, par exemple, je voulais créer un tout nouveau chat ici, je devrais réintroduire le contexte,

01:06.670 --> 01:12.190
peut-être en disant, hey, pouvez-vous me créer des tests unitaires pour cette classe et ensuite coller la classe ou

01:12.190 --> 01:13.440
classes qui sont liées ?

01:13.450 --> 01:16.030
Mais comme nous avons déjà un contexte ici, je vais utiliser ceci.

01:16.030 --> 01:23.680
Dans la section précédente, j'ai créé un exemple d'utilisation d'une classe de gestionnaire de produit, en ajoutant

01:23.680 --> 01:24.820
quelques produits.

01:24.820 --> 01:31.390
On peut imaginer qu'il s'agit d'un produit vendu dans un magasin de jeu, ou d'un personnage PNJ qui a un magasin

01:31.390 --> 01:35.590
qui peut vous donner des objets ou les mettre dans votre inventaire, quelque chose comme ça.

01:35.590 --> 01:40.870
Et au-dessus de cela, dans le même chat, nous avons le I create us the product manager lui-même.

01:40.870 --> 01:44.490
Le chef de produit a donc créé un I et l'exemple par-dessus.

01:44.500 --> 01:46.680
Demandons-lui maintenant de nous fournir des tests.

01:46.690 --> 01:51.880
Ce que je vais faire, c'est coller un test de mode d'édition que j'ai déjà pour qu'il connaisse l'espace de noms

01:51.880 --> 01:56.200
et les noms que j'aime, puis lui demander de le remplir avec des tests pertinents.

01:56.200 --> 01:57.700
Voyons ce qu'il en est ici.

01:57.700 --> 02:02.080
Dans unity, j'ai un test I et un test playmode.

02:02.110 --> 02:04.660
Faisons le test du mode d'édition ici.

02:04.660 --> 02:05.740
Le voici.

02:05.740 --> 02:09.610
Ici, nous pouvons voir qu'il y a un test appelé mon test.

02:09.640 --> 02:11.620
Nous ouvrons le code source et nous le voyons ici.

02:11.620 --> 02:13.480
Il contient l'espace de noms que j'aime.

02:13.480 --> 02:16.090
Il y a des utilisations, je suppose la catégorie.

02:16.090 --> 02:21.640
Donc, plutôt que de demander à ChatGPT de nous créer quelque chose à partir de zéro, je vais lui donner ceci

02:21.640 --> 02:22.180
ici.

02:24.160 --> 02:26.620
Je pense que je vais me débarrasser du nom ici.

02:27.370 --> 02:29.290
Pour ne pas suggérer cette partie.

02:29.320 --> 02:32.710
Ici, dans ChatGPT, je vais dire great.

02:32.740 --> 02:40.150
Maintenant, je veux des tests unitaires sur la classe Product Manager.

02:40.600 --> 02:49.540
Créez une nouvelle réponse avec une classe de test et une ou plusieurs méthodes de test.

02:52.090 --> 02:54.490
Commencez par ce code.

02:55.490 --> 02:57.050
Jetons un coup d'œil à la réponse.

02:57.050 --> 03:02.630
Pour créer des tests unitaires pour la classe Product Manager, vous pouvez utiliser n'importe quel framework de tests unitaires.

03:02.630 --> 03:02.780
pour.

03:02.990 --> 03:03.500
Net.

03:03.530 --> 03:05.930
Voici un exemple de la classe de test.

03:07.070 --> 03:13.730
On voit qu'elle utilise l'espace de noms, les commentaires, le nom de la catégorie test, toutes choses que j'ai données...

03:13.730 --> 03:14.060
il.

03:14.090 --> 03:16.850
Puis il fait le reste tout seul.

03:16.880 --> 03:19.880
Je remarque qu'il en crée un.

03:20.900 --> 03:26.270
Il crée une variable ici qui va être remplie dans l'installation et peut-être détruite plus tard.

03:26.270 --> 03:27.800
En fait, il n'y a pas de décomposition.

03:28.100 --> 03:33.470
Ensuite, ce qu'il fait dans chacun des tests, c'est qu'il utilise arrange, act et assert, ce qui se produit

03:33.470 --> 03:35.090
de correspondre à ma préférence particulière.

03:35.090 --> 03:41.390
J'aime donc le fait qu'il s'agisse d'une solution générale basée sur la popularité, si d'une manière ou d'une autre

03:41.390 --> 03:45.140
J'avais une autre façon de procéder, je pouvais l'indiquer.

03:45.140 --> 03:46.550
Mais pour l'instant, j'aime bien.

03:46.550 --> 03:52.970
Il met donc en place le produit de test, ajoute le produit, puis s'assure que le produit obtenu est renvoyé

03:52.970 --> 03:54.410
ce produit particulier.

03:54.410 --> 03:55.760
Cela semble donc correct.

03:55.760 --> 03:57.740
Ensuite, il teste la façon de retirer un produit.

03:57.740 --> 04:01.100
Il s'agit donc de créer un produit et de l'ajouter.

04:01.100 --> 04:06.170
Puis de le supprimer, et enfin de s'assurer qu'il a bien fonctionné.

04:06.170 --> 04:11.540
Et qu'il ne contient pas ce produit comme ça.

04:11.570 --> 04:13.790
Get products, renvoie tous les produits.

04:13.790 --> 04:16.130
Il fait donc deux et connaît deux.

04:16.130 --> 04:21.230
Maintenant, ce serait une bonne étape pour moi de coller ceci dans unity et de m'assurer que cela fonctionne.

04:21.230 --> 04:22.280
C'est ce que je vais faire.

04:22.280 --> 04:27.800
Et puis je reviendrai et je me demanderai s'il y a un autre test que l'on pourrait ajouter, ou s'il y a un refactor

04:27.800 --> 04:30.500
au code que nous pourrions faire juste pour jouer avec lui un peu plus ?

04:30.500 --> 04:31.820
Mais j'aime bien la direction que nous prenons.

04:31.820 --> 04:33.200
Collons donc cela dans unity.

04:33.230 --> 04:37.820
Sauvegardons-le dans unity, on dirait qu'il compile et dans unity, on dirait qu'il tourne.

04:37.820 --> 04:38.990
Exécutons le test.

04:40.910 --> 04:42.200
Tous les tests sont réussis.

04:42.230 --> 04:43.010
Maintenant.

04:43.730 --> 04:45.590
Les noms des tests qu'il nous a donnés.

04:45.590 --> 04:45.890
Très bien.

04:45.890 --> 04:51.110
Il se trouve qu'il ne correspond pas à mon style particulier et je peux décider à ce stade, adopter ce qui me donne

04:51.110 --> 04:52.730
ou suggérer une différence.

04:52.730 --> 04:58.040
Pour jouer avec l'idée, je vais suggérer d'utiliser un schéma de dénomination légèrement différent.

04:58.040 --> 05:01.610
Mais j'aime le test que cela m'a donné et j'aime qu'ils réussissent tous.

05:01.610 --> 05:03.530
Nous nous en sortons très bien jusqu'à présent.

05:03.530 --> 05:08.390
Revenons en arrière et jouons avec l'idée de donner une petite suggestion et voyons l'itération une fois de plus.

05:08.390 --> 05:08.780
temps.

05:08.780 --> 05:11.900
Alors disons-lui ce qui fonctionne bien.

05:11.900 --> 05:16.960
Cela fonctionne, se compile et tous les tests sont réussis.

05:16.970 --> 05:25.790
Cependant, je n'aime pas le nom de la méthode de test, alors changez le format d'ajout de produit.

05:25.790 --> 05:28.880
Ajouter des produits à la liste à un nouveau format comme Ajouter un produit.

05:28.910 --> 05:32.510
Obtenir des produits contenant des produits lorsque des produits sont ajoutés.

05:33.080 --> 05:38.930
J'aime généralement suivre quelque chose comme la méthode testée, le résultat attendu, et ensuite quand

05:38.930 --> 05:43.970
cette chose particulière se produit, parfois la dénomination devient un peu longue comme on le voit ici.

05:43.970 --> 05:45.650
Parfois, ce n'est pas très clair.

05:45.650 --> 05:47.240
Cela dépend vraiment du contexte.

05:47.240 --> 05:52.100
Mais en plus, ce que je montre ici, c'est que j'aime la plupart de ce que ChatGPT m'a donné.

05:52.100 --> 05:53.990
Mais je voudrais suggérer un changement.

05:53.990 --> 05:57.200
Jouons donc avec ce changement et voyons quel résultat nous obtenons.

05:57.230 --> 05:58.520
Voyons le résultat.

05:58.520 --> 06:01.040
Le résultat indique que le renommage a l'air bon.

06:01.070 --> 06:06.110
Il mentionne qu'il déduit la méthode, le nom, la condition et le résultat attendu.

06:06.230 --> 06:09.530
Je pense en fait résultat attendu puis condition.

06:09.530 --> 06:11.660
Mais regardons les résultats ici.

06:11.660 --> 06:14.270
Encore une fois, j'admets que c'est assez long.

06:14.270 --> 06:18.170
Mais add product get products contient le produit.

06:18.170 --> 06:20.480
Lorsque le produit est ajouté, c'est parfait.

06:20.510 --> 06:21.710
En voici une encore plus longue.

06:21.710 --> 06:23.240
Obtenir le produit ne le fait pas.

06:23.270 --> 06:28.100
On pourrait arguer que ce n'est pas le meilleur système de dénomination, car je vois ce long nom ici,

06:28.100 --> 06:32.690
Je me dis que ce n'est peut-être pas le meilleur, mais ce que nous avons vu, c'est que nous sommes capables de rebondir...

06:32.690 --> 06:37.790
et de donner une petite suggestion et de voir que ChatGPT fonctionne bien.

06:37.790 --> 06:41.300
Nous allons donc copier ceci dans l'unité et voir comment cela fonctionne.

06:41.300 --> 06:42.110
Nous y voilà.

06:42.110 --> 06:42.800
C'est dans unity.

06:42.800 --> 06:43.520
C'est compilé.

06:43.520 --> 06:44.810
Et lançons les tests.

06:47.350 --> 06:48.850
Et tout semble bien se passer.

06:48.850 --> 06:54.490
Nous avons donc vu un cas fantastique d'utilisation de l'intelligence artificielle, non seulement pour rendre le code de production aussi efficace que le code de test, mais aussi pour le rendre plus efficace.

06:54.490 --> 06:59.200
comme nous l'avons fait dans la leçon précédente, mais aussi pour créer de nouveaux tests unitaires au-dessus de ce code de production.

06:59.200 --> 07:05.440
Ici, au moins dans notre démo simple, nous avons vu que unity compilait le code à chaque fois sans aucun problème,

07:05.440 --> 07:07.350
et tous nos tests ont été réussis.

07:07.360 --> 07:11.110
Si vous constatez que le code ne se compile pas, vous pouvez le dire à ChatGPT.

07:11.410 --> 07:16.720
Hey, c'était pas mal, mais j'ai eu cette erreur et vous aideriez à l'éduquer et à vous donner

07:16.720 --> 07:17.590
une meilleure réponse.

07:17.590 --> 07:19.000
Nous n'avions pas besoin de faire cela ici.

07:19.000 --> 07:24.460
De plus, si certains ou tous les tests ont échoué, vous pourriez dire à l'unité que je ne vois généralement pas que les

07:24.460 --> 07:26.350
mais c'est possible.

07:26.350 --> 07:27.490
C'est donc ici que ça se passe.

07:27.490 --> 07:31.000
Nous avons vu un cas d'utilisation fantastique de l'IA dans les tests unitaires.

07:31.030 --> 07:31.750
Merci à tous.
