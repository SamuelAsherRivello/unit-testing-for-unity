WEBVTT

00:02.840 --> 00:04.730
Warum also Unit-Tests durchführen?

00:04.880 --> 00:06.200
Ich beginne gerne mit diesem Zitat.

00:06.200 --> 00:07.050
Ich werde es hier vorlesen.

00:07.070 --> 00:14.150
Jede Entscheidung, die wir treffen, sei es eine Technologie, ein Verfahren oder ein Mensch, kann als eine Form der Investition betrachtet werden.

00:14.510 --> 00:19.040
Diese Investitionen sind mit Kosten verbunden, und wir vertrauen darauf, dass sie sich auszahlen werden.

00:19.250 --> 00:24.950
Wenn Sie also bereits mit der Entwicklung von Spielen vertraut sind und einige der Funktionen übernehmen können

00:24.950 --> 00:29.480
in die Projekte einzubauen und sie mit den Spielern zu teilen,

00:29.480 --> 00:32.520
Es ist vielleicht nicht ganz klar, was der Wert von Unit-Tests ist.

00:32.540 --> 00:38.060
Unit-Tests sollten in erster Linie als eine optionale Aktivität betrachtet werden, die man zusätzlich hinzufügen kann

00:38.060 --> 00:39.640
zu Ihrem Produktionscode hinzufügen können.

00:39.650 --> 00:47.210
In gewisser Weise sehen Ihre Endbenutzer diese Funktionalität nie, aber die Idee und die Vorteile, die sich aus

00:47.210 --> 00:53.960
Unit-Tests, insbesondere der testgesteuerten Entwicklung, werden sich hoffentlich für die Investition auszahlen.

00:53.990 --> 01:01.010
Wir werden Klassen und Systeme haben, die zuverlässiger arbeiten, die robuster sind, aber die

01:01.010 --> 01:08.330
weniger fehleranfällig sind und die es Ihnen ermöglichen, mehr Funktionen für Ihre Benutzer schneller und sicherer hinzuzufügen

01:08.330 --> 01:11.670
mit Unit Testing als eine Ihrer Fähigkeiten.

01:11.690 --> 01:15.190
In der Welt der Unit-Tests gibt es so viele verschiedene Begriffe.

01:15.200 --> 01:18.320
Einige der Begriffe, die wir hier sehen, werde ich einfach mal vorlesen.

01:18.320 --> 01:23.660
Komposition und Abstraktion, die sich auf die Art und Weise beziehen, wie Ihre Klassen und Ihre Architekturen zusammenpassen können

01:23.660 --> 01:24.470
zusammenpassen.

01:24.710 --> 01:29.120
Klassen und Methoden sind einfach die Grundlagen der objektorientierten Programmierung.

01:29.120 --> 01:34.630
Dann Dinge wie Mock und Assertion und Range Act und ebenfalls Assert.

01:34.640 --> 01:37.850
Das sind Dinge, die sich speziell auf Unit-Tests beziehen.

01:37.850 --> 01:42.500
Wir werden alle Begriffe, die wir hier sehen, auf eine informelle Art und Weise behandeln.

01:42.500 --> 01:44.810
Wahrscheinlich werden wir sie jetzt im letzten Teil behandeln.

01:44.810 --> 01:46.040
Berufliche Entwicklung.

01:46.040 --> 01:52.010
Wenn du als Spieleentwickler in Unity anfängst, lernst du das Unity-Tool, lernst die Theorie

01:52.010 --> 01:56.840
hinter Unity und natürlich die C-Sharp-Programmierung, merkt man, dass man seinen Abschluss macht.

01:56.840 --> 02:01.700
Die Konzepte werden immer komplexer, während man die verschiedenen Themen durchgeht.

02:01.730 --> 02:06.050
Dinge wie Klassen in OOP, die man früh in der Entwicklung lernt.

02:06.050 --> 02:13.340
Später in Ihrer Karriere werden Sie sich mehr darauf konzentrieren, Ihre Projekte modularer und wiederverwendbar zu gestalten, indem Sie

02:13.370 --> 02:18.800
Testen, was hier der Kern ist, und dann wird man viel über die Architektur der Projekte sprechen.

02:18.830 --> 02:25.460
Ein Zeichen für ein gut architektonisches Projekt ist es, wenn man das 101ste Feature hinzufügt, ohne dass es

02:25.460 --> 02:26.900
nicht alles andere kaputt macht, was man hat.

02:26.930 --> 02:33.050
Hier sehen wir einen möglichen Karrierepfad eines Nachwuchsentwicklers.

02:33.050 --> 02:38.600
Und es ist besonders interessant, dass die Fähigkeiten, über die wir hier sprechen, wirklich das sind, was einen

02:38.600 --> 02:42.890
von einem angehenden Entwickler über einen Junior zu einem Senior.

02:42.890 --> 02:49.070
Es sind wirklich diese Arten von praktischem Wissen, die Sie zu Ihren Fähigkeiten hinzufügen, die Ihnen helfen werden

02:49.070 --> 02:55.040
eine Beförderung in Ihrer derzeitigen Position zu erhalten oder neue Rollen und Möglichkeiten zu finden, um in anderen Bereichen einen Beitrag zu leisten

02:55.040 --> 02:55.790
Teams.

02:55.820 --> 03:02.030
Nicht jedes Team verwendet Unit-Tests in der Programmierwelt, und ich denke, besonders in der Spieleentwicklung,

03:02.030 --> 03:07.670
findet man es nicht so oft wie bei anderen Programmierplattformen und Paradigmen, aber es ist

03:07.670 --> 03:08.870
hier genauso wichtig.

03:08.870 --> 03:11.150
Schauen wir uns an, warum Unit-Tests wichtig sind.

03:11.150 --> 03:12.460
Ich werde hier mitlesen.

03:12.470 --> 03:19.100
Wenn Ihr Projekt mit mehr Skripten, Klassen und Methoden wächst, wird es schwierig für Sie, sicherzustellen

03:19.100 --> 03:23.810
dass eine Änderung in einem Teil Ihres Codes nicht irgendwo anders etwas kaputt macht.

03:23.900 --> 03:28.850
Mit automatisierten Tests können Sie überprüfen, ob Ihr Code wie erwartet funktioniert.

03:29.150 --> 03:35.870
Testen spart Zeit, da es Probleme sofort nach ihrer Einführung in der Entwicklung aufspürt und feststellt, wo und wann sie auftreten,

03:35.870 --> 03:42.290
anstatt sich auf manuelle Tests zu verlassen, oder sogar auf das teurere Warten auf Ihre Endbenutzer, Ihre

03:42.290 --> 03:47.030
Spielern, einen Fehler zu melden, lassen Sie uns ein wenig über den Wert einer frühen Fehlererkennung sprechen.

03:47.030 --> 03:54.410
Viele von uns Entwicklern denken, dass es bei der Spieleentwicklung nur darum geht, neue Funktionen hinzuzufügen

03:54.410 --> 03:59.540
und denken, je schneller man sie hinzufügt, desto mehr Wert bietet man dem Endnutzer.

03:59.570 --> 04:05.300
Das ist zwar eine schöne Art, ein Projekt zu beginnen, aber wir alle kennen die Ergebnisse, die sich aus dem Hinzufügen von Funktionen ergeben

04:05.300 --> 04:13.160
zu schnell in der Entwicklung, vor allem auf einer Code-Basis, die nicht gut gestaltet ist, gut architektonisch

04:13.160 --> 04:14.210
oder gut getestet ist.

04:14.210 --> 04:21.620
Die Forschung in der Spieleentwicklungsindustrie zeigt eine Art 80-zu-20-Regel: 80% der

04:21.620 --> 04:25.250
Entwicklungsfehler von nur 20% der Funktionen stammen.

04:25.250 --> 04:29.780
Die Kernkomplexität befindet sich oft in einer engen Ecke der Codebasis.

04:29.780 --> 04:36.080
Projekt, Organisation oder ein Mangel daran können enorme, wiederkehrende Probleme verursachen.

04:36.110 --> 04:42.050
Am Ende kämpft man immer wieder mit denselben alten Bränden, weil man nicht über das Design und die

04:42.050 --> 04:46.070
Tests, um zu beweisen, dass das Gebiet sicher erschlossen ist.

04:47.120 --> 04:49.770
80% der Entwicklungszeit wird für die Wartung des Codes verwendet.

04:49.790 --> 04:55.190
Es ist erschreckend, das zu hören, aber das ist es, was wir bei großen Codebasen sehen.

04:55.220 --> 05:01.100
Stellen Sie sich vor, Sie könnten ein Spiel in sechs Monaten auf den Markt bringen und es noch 1 oder 2 Jahre lang unterstützen, während Sie sich um Bugs kümmern

05:01.100 --> 05:03.210
behebt und neue Funktionen hinzufügt.

05:03.230 --> 05:05.800
Das ist ein Beispiel für ein sehr einfaches Spiel.

05:05.810 --> 05:12.020
Selbst in diesem Prozess stellen wir fest, dass 80% der Zeit, die man als Entwickler verbringt, nicht für das Hinzufügen von

05:12.020 --> 05:12.890
neuen Funktionen.

05:12.890 --> 05:20.030
In den ersten sechs Monaten geht es darum, Fehler in alten Systemen zu finden und sie zu überarbeiten.

05:20.060 --> 05:24.050
Die Architektur passt vielleicht nicht in die zweiten sechs Monate der Architektur.

05:24.080 --> 05:29.300
Ihr Projekt wird wachsen und Ihr Team wird lernen, also werden Sie Änderungen vornehmen

05:29.300 --> 05:30.150
auf dem Weg.

05:30.170 --> 05:31.430
Das ist kein Problem.

05:31.460 --> 05:33.950
Diese Änderungen werden oft als Refactoring bezeichnet.

05:33.950 --> 05:39.860
Refactoring bedeutet, den Code effizienter zu machen und den Endverbrauchern den gleichen Nutzen zu bieten.

05:39.890 --> 05:45.530
Jeder Refactor ermöglicht es Ihnen, einen neuen Ausgangspunkt zu haben, um neue Funktionen hinzuzufügen.

05:45.530 --> 05:52.460
Was wir hier sehen, ist, dass die Einführung guter Praktiken für das Testen dazu beitragen wird, dass

05:52.460 --> 05:56.450
Code-Wartung, die 80 %, auf die wir einen Großteil unserer Zeit verwenden.

05:56.450 --> 06:02.480
Und wie ich bereits angedeutet habe, sollten wir uns ansehen, dass die Kosten für Softwarefehler mit der Zeit steigen.

06:02.480 --> 06:08.420
Nun, dieses spezielle Stück Forschung zeigt, dass, wenn Sie sich mit einem Kollegen über

06:08.420 --> 06:13.250
über ein Spiel-Feature unterhält und einer von euch auf etwas hinweist, das ein Problem sein könnte, dann wird das Problem behoben,

06:13.280 --> 06:15.420
diese Unterhaltung ist super billig.

06:15.440 --> 06:22.340
Sagen wir mal, das ist ein x-facher Aufwand, der sehr gering ist, wenn man da durchgeht und das implementiert

06:22.340 --> 06:28.430
Projekt implementiert, ist es schwieriger, denselben Fehler zu finden, nachdem man ihn programmiert hat, und schwieriger

06:28.430 --> 06:30.860
zu beheben und sicherzustellen, dass man ihn behebt.

06:30.860 --> 06:36.860
Wenn Sie dann Ihre Tests durchgeführt haben, geben Sie diese an Ihre Kunden weiter, damit diese sie testen, und dann liefern Sie

06:36.860 --> 06:38.400
an die Endverbraucher.

06:38.420 --> 06:41.000
Stellen Sie sich vor, ein Spieler findet das gleiche Problem.

06:41.030 --> 06:44.330
Sie werden darüber enttäuscht sein müssen.

06:44.330 --> 06:47.510
Vielleicht wirkt sich das negativ darauf aus, wie sie über das Spiel denken.

06:47.510 --> 06:50.060
Sie verlieren sie vielleicht sogar als Spieler.

06:50.060 --> 06:55.400
Aber wenn sie eine stimmgewaltige Person sind und du einen guten Kanal für den Kundensupport hast und sie das einsenden,

06:55.430 --> 07:00.950
geht es in dein Bug Ticketing System, wird eventuell zugewiesen, wird eventuell behoben, vielleicht wird es

07:00.950 --> 07:06.950
behoben oder auch nicht, und dann geben Sie das Update an die Endbenutzer aus, in der Hoffnung, dass der Benutzer die

07:06.980 --> 07:08.270
Bedürfnisse befriedigt worden sind.

07:08.300 --> 07:09.590
Es ist viel teurer.

07:09.590 --> 07:10.210
Am Ende.

07:10.220 --> 07:15.480
Wir werden sehen, dass Unit-Tests es uns ermöglichen, vor allem unsere Software besser zu gestalten.

07:15.500 --> 07:22.550
Zweitens können Sie Tests in Ihr Projekt einbauen, damit diese automatisierten Tests den Fehler früher finden.

07:22.550 --> 07:28.130
Vielleicht ist es in der Integrationsphase, wie wir hier sehen, nicht so gut, wie es in der ersten Phase zu beheben

07:28.130 --> 07:32.240
Konversation, aber es ist viel besser, als zu warten, bis das Projekt freigegeben wird.

07:32.480 --> 07:38.090
Einige der besten Praktiken, die hier hervorgehoben werden, sind die Erstellung von wartbarem Code, die Erhöhung der

07:38.090 --> 07:44.150
die Automatisierung und das Testen Ihres Codes, das frühzeitige und häufige Auffinden von Fehlern und das Beheben dieser

07:44.150 --> 07:46.490
Fehler beheben, bevor Sie neue Funktionen hinzufügen.
