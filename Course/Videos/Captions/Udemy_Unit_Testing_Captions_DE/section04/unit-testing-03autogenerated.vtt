WEBVTT

00:00.020 --> 00:03.440
Erstellen von Einheitstests, Testklassen und Testmethoden.

00:03.440 --> 00:07.100
Hier ist der Code für eine Testklasse mit einer Testmethode.

00:07.100 --> 00:12.370
Darin folgen wir dem optionalen Paradigma von arrange, act, and assert.

00:12.380 --> 00:14.870
Das ist die Konvention, die ich für alle meine Tests verwende.

00:14.870 --> 00:18.980
Wir haben also gesehen, wie ein Test aussieht und wie man einen bestehenden Test ausführt.

00:19.010 --> 00:20.620
Jetzt wollen wir unseren eigenen Test erstellen.

00:20.630 --> 00:22.550
Wir öffnen ein leeres Projekt.

00:22.580 --> 00:29.690
Öffnen Sie das Test-Runner-Fenster, erstellen Sie einen Testordner, eine Testklasse und eine Methode in diesem Test.

00:29.720 --> 00:31.610
Dann führen wir den Test aus und sehen uns das Ergebnis an.

00:31.610 --> 00:33.920
Hier sind wir in einem ziemlich leeren Projekt.

00:33.920 --> 00:37.310
Ich habe das Unity Test Framework bereits hinzugefügt.

00:37.310 --> 00:39.470
Öffnen wir das Test Runner Fenster.

00:39.470 --> 00:46.370
Da das Projekt keine Tests im Bearbeitungsmodus und keine Tests im Abspielmodus hat, bietet jede dieser Registerkarten einige Optionen

00:46.370 --> 00:47.540
hier, um den Anfang zu machen.

00:47.540 --> 00:53.480
Als Erstes erstellen wir einen Ordner für die Testanordnung im Bearbeitungsmodus, indem wir auf die Schaltfläche klicken, die einen neuen Ordner erstellt

00:53.480 --> 00:59.930
in unserem Projektfenster, einschließlich einer Baugruppeneinrichtung zum Testen von Unity-Baugruppen und der Baugruppendefinition

00:59.930 --> 01:07.220
Datei ist außerhalb des Rahmens dieses Kurses, aber kurz gesagt, signalisiert dies Unity, dass Dinge innerhalb dieser

01:07.220 --> 01:11.630
gegebenen Ordner kompiliert werden sollten, und zwar auf eine einzigartige Weise.

01:11.630 --> 01:16.310
Nachdem wir nun den Ordner für die Testbaugruppe eingerichtet haben, können wir unsere erste Testklasse erstellen.

01:16.310 --> 01:21.290
Jeder dieser Schritte kann manuell durchgeführt werden, ohne das Fenster zu benutzen, aber ich fahre fort, indem ich auf die Schaltfläche

01:21.290 --> 01:26.390
klicken, um ein Testskript im aktuellen Ordner des Projektfensters zu erstellen, das

01:26.420 --> 01:29.460
eine neue Testklasse und gibt uns zwei Testmethoden.

01:29.480 --> 01:32.350
Beachten Sie, dass im Fenster des Testläufers alles angezeigt wird.

01:32.360 --> 01:33.770
Ich führe alle diese Tests aus.

01:33.770 --> 01:35.040
Alle Tests sind erfolgreich.

01:35.060 --> 01:37.160
Werfen wir einen Blick auf den generierten Code.

01:37.160 --> 01:41.990
An dieser Stelle können Sie die Klasse und die Methoden nach Belieben umbenennen.

01:41.990 --> 01:45.530
Und dann können Sie natürlich durch Kopieren und Einfügen weitere Methoden hinzufügen.

01:45.530 --> 01:50.840
Es gibt keine Begrenzung für die Anzahl der Testmethoden, die Sie in einer Testklasse haben können, aber im Allgemeinen verwenden Sie

01:50.840 --> 01:57.890
die Klasse, um bestimmte Themen zu organisieren, vielleicht eine Testklasse für jede Produktionsklasse, und dann eine

01:57.890 --> 02:00.440
Testmethode für jede Methode.

02:00.440 --> 02:03.290
In der Produktion wollen Sie so etwas testen.

02:03.290 --> 02:07.010
Diese Kommentare werden automatisch von Unity generiert und sind sehr hilfreich.

02:07.520 --> 02:10.310
Ich werde die Highlights hier anhand des Tests durchgehen.

02:10.640 --> 02:15.740
Mit dem Testattribut können wir einen normalen Test im Bearbeitungsmodus durchführen.

02:15.740 --> 02:22.100
Mit dem Attribut unity test können wir einen Test über mehrere Bilder durchführen.

02:22.100 --> 02:26.630
Ich habe bereits erwähnt, dass die Verwendung von unity test am besten für den Spielmodus geeignet ist.

02:26.660 --> 02:31.160
Man hat viel mehr Möglichkeiten, welche Art von asynchroner Funktionalität man dort machen kann.

02:31.160 --> 02:38.060
Hier ist es in der Tat möglich, und wie der Kommentar andeutet, können Sie yield return null verwenden, um einen Frame zu überspringen.

02:38.060 --> 02:42.920
Zum Beispiel, indem man das Setup macht, dann einen Frame wartet und den Test macht.

02:42.920 --> 02:43.910
So etwas in der Art.

02:43.910 --> 02:46.220
Zum Beispiel den Setup-Code ausführen.

02:46.220 --> 02:47.660
Warten auf einen Frame.

02:48.220 --> 02:52.240
Und dann die Behauptung, so etwas wie das hier, zurück in Unity.

02:52.240 --> 02:54.580
Ich werde mit der Tabulatortaste auf die.

02:55.200 --> 02:57.720
Play-Modus und folge den gleichen Schritten.

02:57.720 --> 03:03.870
Zuerst erstellen wir einen Testordner für den Wiedergabemodus, und dann erstelle ich ein Testskript.

03:03.870 --> 03:04.710
In diesem Ordner.

03:04.710 --> 03:09.840
Im Testrunner können wir sehen, dass wir eine Testklasse haben, die zwei Testmethoden enthält.

03:10.350 --> 03:13.250
Ich führe alle Tests aus und wir sehen, dass alles funktioniert.

03:13.260 --> 03:15.230
Werfen wir einen Blick auf den generierten Code.

03:15.240 --> 03:21.870
Der hier generierte Code ist sowohl im Spiel- als auch im Bearbeitungsmodus identisch.

03:21.900 --> 03:24.120
Sie bieten sehr ähnliche Ausgangspunkte.

03:24.120 --> 03:25.050
Das war's.

03:26.390 --> 03:31.910
Wir fangen an zu sehen, dass wir mit dem Testläufer-Fenster und nur ein bisschen mehr C-Schärfe

03:31.910 --> 03:35.110
mehr Dinge mit unseren Unity-Projekten machen können als bisher.

03:35.120 --> 03:40.490
Wenn Sie neu im Bereich Unit Testing sind, sind Sie mit der Verwendung von Unity zur Erstellung von Laufzeitcode vertraut.

03:40.490 --> 03:42.740
Aber das Testen von Code ist etwas anderes.

03:43.300 --> 03:46.660
Er wird nie direkt von den Endbenutzern erlebt.

03:47.110 --> 03:52.200
Dieser Code läuft nur im Testmodus und ist noch nicht einmal in den End-Build integriert.

03:52.210 --> 03:58.790
Wir fangen jetzt an, Tests als ein kleines Fenster zu einem bestimmten Zeitpunkt in einer größeren Anwendung zu betrachten.

03:58.810 --> 04:02.930
Testen mit einem engen Fokus, um sicherzustellen, dass wir konsistente Ergebnisse erhalten.

04:02.950 --> 04:08.200
Bis jetzt haben wir hauptsächlich über das Hinzufügen neuer Tests zu bestehendem Code gesprochen.

04:08.230 --> 04:13.300
Als Nächstes werden wir uns ansehen, wie wir Tests hinzufügen können, während wir Code mit testgetriebener Entwicklung entwickeln.

04:13.330 --> 04:14.110
Danke!
