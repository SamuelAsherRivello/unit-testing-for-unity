WEBVTT

00:00.020 --> 00:03.440
Creating unit tests, test class and test methods.

00:03.440 --> 00:07.100
Here's the code for a test class containing one test method.

00:07.100 --> 00:12.370
Inside we follow the optional paradigm of arrange, act, and assert.

00:12.380 --> 00:14.870
That's the convention I use for all of my testing.

00:14.870 --> 00:18.980
So we've seen what a test looks like and how to run an existing test.

00:19.010 --> 00:20.620
Now let's create our own test.

00:20.630 --> 00:22.550
We'll open up an empty project.

00:22.580 --> 00:29.690
Open the test Runner window, create a test folder, a test class, and a method inside that test.

00:29.720 --> 00:31.610
Then we'll run the test and see the result.

00:31.610 --> 00:33.920
Here we are in a fairly empty project.

00:33.920 --> 00:37.310
I do have the unity test framework added already.

00:37.310 --> 00:39.470
Let's open up the test runner window.

00:39.470 --> 00:46.370
Since the project has no edit mode tests and no play mode tests, each of those tabs offers some options

00:46.370 --> 00:47.540
here to get us started.

00:47.540 --> 00:53.480
First, we'll create an edit Mode test assembly folder by clicking the button that creates a new folder

00:53.480 --> 00:59.930
in our project window, including an assembly setup for testing unity assemblies and the assembly definition

00:59.930 --> 01:07.220
file is outside the scope of this course, but in brief, this signals unity that things within this

01:07.220 --> 01:11.630
given folder should be compiled, should be compiled in a unique way.

01:11.630 --> 01:16.310
So now that we have that test assembly folder set up, we can create our first test class.

01:16.310 --> 01:21.290
Each of these steps can be done manually without using the window, but I'll continue by clicking the

01:21.290 --> 01:26.390
next button here to create a test script in the current folder in the project window, that creates

01:26.420 --> 01:29.460
a new test class, and it gives us two test methods.

01:29.480 --> 01:32.350
Notice in the test runner window everything shows up.

01:32.360 --> 01:33.770
I'll run all those tests.

01:33.770 --> 01:35.040
All the tests pass.

01:35.060 --> 01:37.160
Let's take a look at the code that's generated.

01:37.160 --> 01:41.990
At this point, you're free to rename the class and these methods however you see fit.

01:41.990 --> 01:45.530
And then of course copy and paste to add more methods within.

01:45.530 --> 01:50.840
There's no limit to the number of test methods you can have in a test class, but generally you use

01:50.840 --> 01:57.890
the class to organize certain topics, perhaps one test class for each production class, and then one

01:57.890 --> 02:00.440
test method within for each method.

02:00.440 --> 02:03.290
In production, you want to test something like that.

02:03.290 --> 02:07.010
These comments are automatically generated by unity and are quite helpful.

02:07.520 --> 02:10.310
I'll go over the highlights here using the test.

02:10.640 --> 02:15.740
Using the test attribute sets us up for a normal edit mode test.

02:15.740 --> 02:22.100
Using the unity test attribute allows us to execute a test over multiple frames.

02:22.100 --> 02:26.630
Now, I mentioned before that using unity test is best fit for play mode.

02:26.660 --> 02:31.160
You have much more options at what type of asynchronous functionality you can do there.

02:31.160 --> 02:38.060
It is indeed possible here, and as the comment suggests, you can use yield return null to skip a frame.

02:38.060 --> 02:42.920
For example, doing the setup, then waiting a frame and doing the test.

02:42.920 --> 02:43.910
Something like that.

02:43.910 --> 02:46.220
For example doing the setup code.

02:46.220 --> 02:47.660
Waiting a frame.

02:48.220 --> 02:52.240
And then doing the assertion, something like that here, back into unity.

02:52.240 --> 02:54.580
I will tab over to the.

02:55.200 --> 02:57.720
Play mode and follow the same steps.

02:57.720 --> 03:03.870
First, we'll create a play mode test assembly folder, and then I'll create a test script.

03:03.870 --> 03:04.710
In this folder.

03:04.710 --> 03:09.840
We can see in the test runner that we've got one test class that contains two test methods.

03:10.350 --> 03:13.250
I'll run all and we see that everything passes.

03:13.260 --> 03:15.230
Let's take a look at the generated code.

03:15.240 --> 03:21.870
The code generated here is actually identical in both play mode and edit mode.

03:21.900 --> 03:24.120
They give you very similar starting points.

03:24.120 --> 03:25.050
That's it.

03:26.390 --> 03:31.910
We're beginning to see that with the test runner window and just a little bit of added C-sharp, we

03:31.910 --> 03:35.110
can do more things with our unity projects than we have before.

03:35.120 --> 03:40.490
If you're new to unit testing, you're familiar with using unity to create runtime code.

03:40.490 --> 03:42.740
But testing code is something different.

03:43.300 --> 03:46.660
It's never directly experienced by your end users.

03:47.110 --> 03:52.200
This code only runs in test mode and it's not even packaged into your end build.

03:52.210 --> 03:58.790
We start to look at tests now as a small window into moments in time in a larger application.

03:58.810 --> 04:02.930
Testing with a narrow focus to ensure we get consistent results.

04:02.950 --> 04:08.200
Up to now, we've been talking mostly about adding new tests to existing code.

04:08.230 --> 04:13.300
Next, we'll look at how to add tests while we're developing code with test driven development.

04:13.330 --> 04:14.110
Thanks.
