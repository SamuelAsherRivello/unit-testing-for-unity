WEBVTT

00:00.590 --> 00:02.660
Hallo und willkommen zu Unit Testing für Unity.

00:02.690 --> 00:03.860
Die Workshops.

00:03.860 --> 00:09.590
In diesem Workshop-Abschnitt werden wir viele verschiedene kleine Beispiele behandeln, die uns jeweils einige

00:09.590 --> 00:11.030
Eigenschaften von Unit-Tests zeigen.

00:11.030 --> 00:12.800
Werfen wir einen Blick auf die Inhalte hier.

00:12.800 --> 00:16.730
Zuerst gebe ich diesen Überblick, den ich jetzt in diesem Abschnitt Einleitung durchführe.

00:16.730 --> 00:19.070
Und dann werden wir die einzelnen Workshops durchgehen.

00:19.070 --> 00:24.320
Typischerweise bezieht sich jeder Workshop auf eine Szene in unserem einen Beispielprojekt.

00:24.320 --> 00:28.370
Wenn Sie also das Beispielprojekt herunterladen, können Sie die einzelnen Szenen nachvollziehen.

00:28.370 --> 00:35.270
Wir werden mein mathematisches System behandeln, das ein sehr einfaches Beispiel ist, nur um uns wieder mit dem Unit-Testing vertraut zu machen

00:35.270 --> 00:36.500
in Unity ist.

00:36.500 --> 00:42.230
Dann werden wir zu meinem Datenlader-Beispiel übergehen, und das werde ich in einer einfachen Version zeigen und dann

00:42.230 --> 00:48.740
eine fortgeschrittene Version mit einigen zusätzlichen Funktionen, die optional sind, aber unglaublich mächtig

00:48.740 --> 00:50.390
Unity für Einheitstests.

00:50.420 --> 00:54.920
Dann werden wir ein Beispiel durchgehen, bei dem ich etwas mit gerenderten Grafiken machen wollte.

00:54.920 --> 01:00.530
Ich habe also einen Würfel, den wir mit den Pfeiltasten oder mit einem Gamepad bedienen können, und das nennen wir dann unseren

01:00.530 --> 01:01.340
Figur.

01:01.400 --> 01:06.950
Wir werden nun einige Beispiele durchgehen und uns immer komplexere Anwendungsfälle für Tests ansehen,

01:06.950 --> 01:13.520
Schließlich werden wir eine physikbasierte Bewegung durchführen, die Eingaben entgegennimmt und unseren Charakter mit einem starren Körper bewegt,

01:13.520 --> 01:17.990
und zu schauen, wie und warum wir Unit-Tests um das herum machen wollen.

01:18.020 --> 01:25.340
Allgemein gesagt, je mehr Unity-Funktionen man benutzt und je mehr Laufzeitanimationen man macht, desto

01:25.340 --> 01:27.440
mehr Herausforderungen an den Testprozess.

01:27.440 --> 01:28.880
Wir werden also ein wenig darüber sprechen.

01:28.880 --> 01:31.670
Es gibt immer eine Möglichkeit für mich, hier mehr Inhalt hinzuzufügen.

01:31.670 --> 01:34.160
Wir werden also auch einige fortgeschrittene Themen behandeln.

01:34.160 --> 01:38.990
Und dieser Workshop wird es uns ermöglichen, tiefer in einige spezielle Unterthemen einzutauchen.

01:38.990 --> 01:43.580
Der gesamte Quellcode ist im heruntergeladenen Quellcode für das Projekt selbst verfügbar.

01:43.580 --> 01:44.720
Das kannst du dir also schnappen.

01:44.720 --> 01:48.950
Und das Format hier wird eine improvisierte Bildschirmfreigabe sein.

01:48.980 --> 01:53.750
Ich werde längere Takes als normal machen, und einfach laut denken, wenn es verschiedene Dinge gibt

01:53.750 --> 01:58.520
die ich mit Ihnen besprechen und über die Fähigkeiten und Herausforderungen von Unit-Tests teilen möchte.

01:58.820 --> 02:03.320
Ich werde einige bestehende Codes überprüfen und hier und da neue Codes erstellen.

02:03.320 --> 02:09.590
Eine gute Möglichkeit, dies zu betrachten und die Informationen zu nutzen, ist, das Beispielprojekt herunterzuladen und mitzumachen

02:09.590 --> 02:10.400
hier und dort.

02:10.400 --> 02:16.190
Ich werde Sie ermutigen, eine neue Produktionsmethode hinzuzufügen, die getestet werden soll, oder neue Testmethoden, die das abdecken, was Sie

02:16.190 --> 02:17.540
im Produktionscode haben.

02:17.540 --> 02:21.200
Sie können auf den vorhandenen Beispielen, die ich hier habe, aufbauen.

02:21.200 --> 02:23.720
Oder Sie können natürlich auch Ihre eigenen Beispielszenen erstellen.

02:23.720 --> 02:27.230
Und als Rekapitulation lesen wir hier die Vorteile von Unit-Tests.

02:27.230 --> 02:33.560
Einige davon sind die Erhöhung des Vertrauens in den Code und die Möglichkeit, den Code in größerem Umfang umzugestalten

02:33.560 --> 02:39.560
Basis mit mehr Bewusstsein vor und nach dem Refactor für den Status Ihres Projekts.

02:39.560 --> 02:44.990
Und insgesamt wird das Zeit sparen, weil wir gesehen haben, dass wir zwar immer das Gefühl haben, dass wir

02:45.020 --> 02:50.210
neue Funktionen hinzuzufügen, haben wir aus der Forschung gelernt, dass Softwareentwicklung

02:50.210 --> 02:55.220
hauptsächlich darum geht, einen bestehenden Code zu pflegen, und das ist der Punkt, an dem Unit-Tests ansetzen

02:55.220 --> 02:55.640
zu glänzen.

02:55.640 --> 02:58.700
Es wird uns also über die gesamte Dauer des Projekts Zeit sparen.

02:58.730 --> 03:04.130
Die Ergebnisse, die wir von diesem Kurs und von der Anwendung von Unit-Tests erwarten, sind mehr Vertrauen und

03:04.130 --> 03:05.990
Robustheit in unserer Codebasis.

03:06.020 --> 03:12.680
Wir werden mehr Einzweck-Klassen und -Methoden haben, was ein großartiges Designprinzip ist, um sich auf

03:12.680 --> 03:14.930
und hilft uns sicherlich bei der Testbarkeit.

03:14.930 --> 03:17.450
Und wir werden mehr einfache Lösungen fördern.

03:17.450 --> 03:19.550
Und darüber werden wir in einigen dieser Beispiele sprechen.

03:19.550 --> 03:21.650
Um das einfachste Beispiel zu rekapitulieren.

03:21.650 --> 03:24.380
Dies ist auch der erste der Workshops, in die wir eintauchen werden.

03:24.410 --> 03:30.290
Wenn wir eine Mind-Math-System-Klasse haben, und sie hat zwei Methoden, um zu addieren und zu subtrahieren.

03:30.320 --> 03:35.090
Sie können sich vorstellen, dass Sie, sobald Sie sehen, dass diese Codebasis funktioniert, Ihre eigene Methode zum Multiplizieren hinzufügen können

03:35.090 --> 03:38.300
oder dividieren, und dann noch ein paar Unit-Tests darauf aufbauen.

03:38.310 --> 03:39.800
Hier kann man gut üben.

03:39.800 --> 03:43.220
Dies ist absichtlich die einfachste der Szenen, die wir durchgehen werden.

03:43.220 --> 03:48.560
Wenn du dich also noch an die Grundlagen gewöhnst und sichergehen willst, dass du sie wirklich verinnerlichst,

03:48.560 --> 03:53.300
Ich schlage vor, ein bisschen mehr Zeit mit diesem Teil des Videos und diesem Teil der Codebasis zu verbringen, bis

03:53.300 --> 03:55.340
Sie ein gutes Gefühl haben, und dann machen Sie weiter.

03:55.340 --> 03:59.450
Und hier ist wieder ein Beispiel für die Art von Unit-Tests, die wir erstellen werden.

03:59.450 --> 04:04.100
Dies ist ein einfacher, vollständiger und angemessener Test, der mein mathematisches System abdeckt.

04:04.100 --> 04:08.690
Hier folgen wir also dem Paradigma von "arrange, act and assert".

04:08.720 --> 04:14.540
Dies ist ein optionaler Weg, um Ihre Unit-Tests anzugehen, nur um Ihre eigenen Gedanken zu organisieren, während Sie gehen.

04:14.720 --> 04:18.740
Manchmal kann es vorkommen, dass Sie asynchrone Codeentwicklung betreiben.

04:18.740 --> 04:23.990
In dieser Methodik würde ich also arrange, act, await und assert verwenden.

04:23.990 --> 04:29.840
Und wenn Sie nicht genau wissen, was ein wait ist, schauen wir uns die await und async Methodik an, um

04:29.870 --> 04:32.120
asynchrone Kodierung als Teil des Workshops.

04:32.120 --> 04:37.760
Während der Arbeit am Quellcode für das Projekt und für diesen Kurs, was

04:37.760 --> 04:40.330
Ich habe mir jede der Abhängigkeiten angesehen.

04:40.340 --> 04:47.990
Unity hat bestimmte Bibliotheken im Unity-Paketmanager verfügbar, damit wir die offizielle Unity-Lösung machen können

04:47.990 --> 04:49.550
für Unit-Tests.

04:49.550 --> 04:55.820
Nun, was ich hier gemacht habe, ist, dass ich statt der Version x, die in der Veröffentlichung ist, eine experimentelle Version verwende.

04:55.820 --> 04:59.900
Sie werden feststellen, dass der Testläufer, den ich im Video vorführe, so aussieht.

05:00.050 --> 05:04.940
etwas anders aussieht als einige Screenshots, die Sie im Internet gesehen haben, oder wenn Sie Erfahrung haben

05:04.940 --> 05:06.400
mit dem Test-Runner selbst haben.

05:06.410 --> 05:08.630
Was ich heute zeige, könnte ein wenig anders aussehen.

05:08.660 --> 05:13.370
Das Beispielprojekt, das Sie herunterladen werden, wird dem Aussehen dieses Videos entsprechen, denn ich habe

05:13.400 --> 05:15.020
diese Abhängigkeit mit eingebaut.

05:15.050 --> 05:16.340
Es gibt Gründe, warum ich das gemacht habe.

05:16.340 --> 05:21.020
Es geht nicht nur darum, dass der Testrunner anders aussieht und stabiler ist, was meiner Meinung nach der Fall ist.

05:21.050 --> 05:26.870
Es ist auch die Bibliothek dahinter, die es uns erlaubt, ein paar zusätzliche Dinge zu tun, insbesondere um einige asynchrone

05:26.870 --> 05:28.370
Entwicklung und Testen.

05:29.730 --> 05:33.060
Sie können einen Blick auf die Textdatei der Version werfen, die im Projekt enthalten ist.

05:33.060 --> 05:37.790
Wenn Sie sehen wollen, wie und wo und warum jede dieser Abhängigkeiten enthalten ist.

05:37.800 --> 05:43.020
Das Beispielprojekt, mit dem wir uns beschäftigen werden, enthält eine Readme-Datei, die wir anklicken können, um zu sehen

05:43.020 --> 05:44.390
dieses schöne Menü auf der rechten Seite.

05:44.400 --> 05:49.950
Es ist ein einfacher Weg, um sich an einige beliebte Links zu erinnern, und um direkt in jede der

05:49.950 --> 05:51.690
Beispiele, die Sie sich ansehen möchten.

05:51.960 --> 05:57.270
Ich habe ein bestimmtes Layout, das ich hier verwende, um den Testläufer in der Mitte zu halten

05:57.270 --> 05:59.930
damit er für die Zwecke des Videos schön groß ist.

05:59.940 --> 06:04.710
In der Entwicklung würde mein Test-Runner oft auf der rechten Seite sitzen, aber ich habe ihn gerne

06:04.710 --> 06:08.280
vorne und in der Mitte, vor allem, um die Tests zu besprechen.

06:08.370 --> 06:13.290
Sie können die Größe dieser Fenster und Layouts natürlich nach Belieben ändern, aber einige der wichtigsten sind

06:13.290 --> 06:18.150
sind das Projektfenster, der Test Runner und der Inspektor, den wir

06:18.150 --> 06:19.020
anschauen werden.

06:19.020 --> 06:23.310
Wir tauchen jetzt ein und sehen uns den ersten der Workshops an.

06:23.370 --> 06:27.870
Ich habe ihn in mehrere Abschnitte aufgeteilt, die sich wiederum auf verschiedene Unterthemen konzentrieren.

06:27.870 --> 06:35.130
Ich habe auch daran gedacht, sie mehr oder weniger von eins bis zur höchsten Zahl zu ordnen, beginnend mit

06:35.130 --> 06:39.840
mit dem einfachsten und am wenigsten komplexen, und dann auf diesen Konzepten aufzubauen.

06:40.140 --> 06:42.810
Jede der Demoszenen läuft für sich allein.

06:42.810 --> 06:44.880
Du drückst einfach auf Play im Konsolenfenster.

06:44.910 --> 06:47.070
Du siehst dann einige Anzeigen und so weiter.

06:47.070 --> 06:52.050
Du kannst das Geschehen mitverfolgen, und in einigen Szenen gibt es etwas zu tun, wenn du auf Play drückst.

06:52.080 --> 06:56.610
Manchmal gibt es keine Benutzeroberfläche, es ist ganz einfach und man sieht sich nur ein paar Debug-Log-Anweisungen an.

06:56.610 --> 07:00.110
Daher freue ich mich, diese Workshops als eine großartige Möglichkeit zum Eintauchen zu nutzen.

07:00.120 --> 07:01.140
Fangen wir also an.

07:01.140 --> 07:02.970
Wir werden den Unity-Editor öffnen.

07:02.970 --> 07:07.680
Ich habe den Quellcode bereits heruntergeladen, wie in den Kursressourcen weiter oben beschrieben.

07:07.680 --> 07:12.540
Wir öffnen das Beispielprojekt aus dem Kurs und öffnen und spielen eine oder mehrere Szenen ab

07:12.540 --> 07:13.680
in jedem der Workshops.

07:13.680 --> 07:18.360
Zuerst schauen wir uns die Readme-Datei an, die uns eine Orientierung im Projekt gibt.

07:18.390 --> 07:23.700
Wir werden auch einen Blick auf den Paketmanager werfen, die Projektstruktur erkunden und dann einen Blick auf den Test werfen

07:23.700 --> 07:24.630
Läufer-Fenster.

07:24.630 --> 07:29.610
Hier geben wir also nur einen Überblick über das Beispielprojekt und die Workshops

07:29.610 --> 07:30.270
formatiert sind.

07:30.270 --> 07:33.090
Und dann werden wir die einzelnen Workshops durchgehen.

07:33.090 --> 07:35.190
Hier sind wir also in der Einheit.

07:35.190 --> 07:39.960
Ich werde mein Bestes tun, um meinen Webcam-Kopf aus dem Geschehen hier herauszuhalten.

07:39.960 --> 07:45.360
Und was wir uns ansehen werden, ist die Readme, die an einigen Stellen verfügbar ist, wir

07:45.360 --> 07:48.810
können hier hochgehen und diese Menüoption erkunden, um die Readme zu öffnen.

07:49.440 --> 07:54.060
Wir können auch durch das Projektfenster blättern und hier unten einfach auf die Readme klicken.

07:54.180 --> 07:56.900
In beiden Fällen wird die Readme im Inspektor geöffnet.

07:56.910 --> 07:58.650
Werfen wir einen Blick auf das, was wir hier haben.

08:00.900 --> 08:05.490
Zur Orientierung haben wir einige Links zum Kurs und zum Beispielprojekt, wo diese Informationen

08:05.490 --> 08:06.060
verfügbar sind.

08:06.060 --> 08:08.670
Wenn Sie auf diese Links klicken möchten, können Sie sie sich ansehen.

08:11.450 --> 08:13.220
Und dann der Abschnitt "Erste Schritte".

08:13.220 --> 08:18.650
Es gibt einen schnellen Weg, um zu einigen der beliebten Beispiele zu gelangen, also können Sie sicherlich durch die

08:18.650 --> 08:20.060
Projektfenster durchsuchen und sie finden.

08:20.060 --> 08:22.140
Aber dies ist eine gute Möglichkeit, sich zu orientieren.

08:22.160 --> 08:25.190
Etwas anderes, das ich mir ansehen wollte, ist der Paketmanager hier.

08:25.220 --> 08:29.360
Wenn du dieses Projekt herunterlädst, wirst du hier die gleichen Pakete sehen.

08:29.360 --> 08:35.510
Aber wenn Sie sich entscheiden, zum Zweck des Lernens hier oder in der Zukunft diese Lektionen mitzubringen

08:35.510 --> 08:40.640
in ein anderes Projekt einzubringen, werden Sie Ihren Paketmanager ähnlich gestalten wollen, wenn Sie wollen

08:40.640 --> 08:42.230
hier die gleiche Erfahrung machen wollen.

08:42.230 --> 08:46.160
Beachten Sie, dass ich das Paket end substitute habe.

08:46.400 --> 08:52.130
Ich habe auch das Paket für die Codeabdeckung, das Testframework.

08:52.130 --> 08:56.990
Und für den Zweck dieses Kurses habe ich eine Vorabversion, die uns einige zusätzliche Funktionen bietet.

08:56.990 --> 08:57.940
Funktionalität bietet.

08:57.950 --> 09:00.050
Dies ist optional für Unit-Tests.

09:00.050 --> 09:04.730
Man braucht es sicherlich nicht für den Großteil der Funktionen von Unit-Tests, aber ich denke, es hat einige

09:04.730 --> 09:06.020
cooles, innovatives Zeug.

09:06.020 --> 09:10.040
Darauf werden wir uns also konzentrieren, und ich empfehle Ihnen, es auszuprobieren.

09:10.070 --> 09:11.420
Hier ist noch etwas anderes zu beachten.

09:11.420 --> 09:14.750
Diese Versionsdatei, die ich ausgewählt habe, wird sich damit befassen.

09:14.750 --> 09:19.430
Das sind nur ein paar Notizen, die ich auf dem Weg gemacht habe, um ein bisschen über die Abhängigkeiten zu sprechen, die ich

09:19.430 --> 09:20.390
gewählt habe und warum.

09:22.530 --> 09:24.420
Wir werden hier also nicht näher darauf eingehen.

09:24.450 --> 09:26.080
Auch das kann sich im Laufe der Zeit ändern.

09:26.100 --> 09:30.210
Aber schauen Sie sich einfach diese Datei an, wenn Sie wissen wollen, wie und warum ich die einzelnen Abhängigkeiten verwendet habe, und

09:30.210 --> 09:33.450
warum ich die Vorabversion verwende, die ich dort ausdrücklich erwähnt habe.

09:33.480 --> 09:37.110
Und schließlich, ganz vorne und in der Mitte, sehen wir uns das Fenster des Testläufers an.

09:37.140 --> 09:42.480
Dieses Fenster ist jetzt über Fenster Allgemein und Test Runner verfügbar.

09:42.480 --> 09:47.160
Und es ist, wie bereits erwähnt, in jeder Standardinstallation von Unity enthalten.

09:47.190 --> 09:51.600
Ich habe die Vorabversion eines bestimmten Pakets hinzugefügt, daher könnte das Layout meines etwas anders aussehen

09:51.600 --> 09:54.150
als der Standard hier in diesem Layout.

09:54.180 --> 10:01.260
Was wir hier haben, ist die Möglichkeit, Tests im Bearbeitungsmodus ein- und auszuschalten und Tests im Wiedergabemodus ein- und auszuschalten.

10:01.260 --> 10:03.570
Sie werden hier auf der gleichen Registerkarte angezeigt.

10:03.720 --> 10:04.840
Das ist wirklich großartig.

10:04.860 --> 10:07.800
Dann kann ich die verschiedenen Kategorien durchsuchen.

10:07.800 --> 10:13.140
Jetzt habe ich alle Tests erstellt, die wir uns ansehen, und ich habe sie jeweils einer bestimmten Kategorie zugeordnet.

10:13.140 --> 10:18.360
Wenn ich mir also nur einen bestimmten Test ansehen möchte, wie z.B. mein Mathematiksystem, dann filtert er einfach die Ansicht

10:18.390 --> 10:23.970
und es werden nur die Bearbeitungen oder nur die Spiele und eine bestimmte Kategorie angezeigt.

10:24.000 --> 10:25.230
Das hilft dir wirklich.

10:25.260 --> 10:31.170
Wenn ich zum Beispiel nur die Bearbeitung ausgewählt habe, kann ich alle Tests sehen

10:31.170 --> 10:31.770
die dort sind.

10:31.770 --> 10:36.600
Und hier unten kann ich ausgewählte Tests ausführen oder alle ausgewählten Tests ausführen, zum Beispiel.

10:36.600 --> 10:40.950
Damit wird der gesamte Testcode durchlaufen und ausgeführt.

10:41.040 --> 10:48.270
Das ist sozusagen der Kern der Methodik, an die wir uns hier annähern, dass man in regelmäßigen Abständen in der Entwicklung

10:48.270 --> 10:50.270
Ihre eigene Codebasis testen wollen.

10:50.280 --> 10:55.190
Sie kommen zu diesem Fenster und klicken manuell auf die Schaltfläche "Ausgewählte ausführen" oder "Alles ausführen".

10:55.200 --> 10:59.340
Wir sehen hier oben alles grün, was den Erfolg anzeigt.

10:59.340 --> 11:02.970
Es gibt eine kleine Zusammenfassung, dass 100 Tests erfolgreich waren.

11:02.970 --> 11:07.550
Null Tests sind fehlgeschlagen, und null wurden übersprungen oder ignoriert.

11:07.560 --> 11:13.530
Eine gute Praxis bei der Durchführung von Unit-Tests ist es also, sicherzustellen, dass alle Tests erfolgreich sind.

11:13.560 --> 11:18.570
Lassen Sie einen fehlgeschlagenen Test nicht lange in Ihrem Projekt.

11:18.570 --> 11:19.680
Das sollten Sie angehen.

11:19.680 --> 11:20.520
Schaffen Sie es aus dem Weg.

11:20.520 --> 11:23.280
Auch wenn Sie wissen, dass in der Zukunft eine Migration ansteht.

11:23.280 --> 11:29.280
Die beste Praxis ist also, die Tests mit den Codeänderungen zu aktualisieren und sie immer

11:29.280 --> 11:30.030
passieren.

11:30.030 --> 11:32.700
Hier zeigen wir also die beste Praxis in der Praxis.

11:33.690 --> 11:36.690
Im nächsten Workshop werden wir uns den Quellcode genauer ansehen.

11:36.690 --> 11:41.850
Das war's dann aber auch schon mit der Betrachtung der Workshops und des Beispielprojekts.

11:46.910 --> 11:47.900
Hallo und herzlich willkommen.

11:47.900 --> 11:53.990
In diesem Workshop werden wir einen Blick auf das System My Math werfen und uns mit einem ziemlich

11:54.020 --> 11:58.250
einfaches Beispiel, das uns wieder mit den Grundlagen des Unit-Testens vertraut macht.

11:58.250 --> 12:01.640
In dieser Demo können Sie das Core Sample Projekt verwenden, um mitzumachen.

12:01.640 --> 12:06.440
Wir öffnen den Unity-Editor, öffnen das Core Sample Projekt, und dann werden wir

12:06.440 --> 12:08.060
öffnen und einige Szenen abspielen.

12:08.060 --> 12:13.310
Wir werden uns das My-Math-System und den Test dahinter ansehen und eine Zusammenfassung machen

12:13.340 --> 12:18.920
von Unit-Tests und sprechen einfach über alle grundlegenden Konzepte, die ich dort sehe und die ich erwähnen möchte.

12:18.920 --> 12:25.370
Und wir werden auch über parametrisierte Werte sprechen, was ein Zwischenweg ist, den man gehen kann

12:25.370 --> 12:25.880
Testen.

12:25.880 --> 12:29.540
Und es ist eine gute zusätzliche Fähigkeit, die man haben sollte, wenn man sich dem Unit-Testing nähert.

12:29.570 --> 12:30.560
Lassen Sie uns eintauchen.

12:30.770 --> 12:35.330
Hier bin ich also im Unity-Editor und habe das Beispiel für mein mathematisches System geöffnet.

12:35.330 --> 12:37.970
Lasst uns einfach die Szene selbst ausprobieren.

12:38.000 --> 12:41.630
Manchmal ist in diesen Workshops die Szene spannender.

12:41.630 --> 12:43.220
Diese hier ist nicht so spannend.

12:43.220 --> 12:48.680
Wir machen weiter und drücken hier unten im Fenster auf Play, wir sehen einen einfachen Text, der uns hilft

12:48.680 --> 12:53.960
wir verstehen, dass wir uns in der Unit-Testing-Demo befinden, und wir werden einfach die Szene abspielen und die Konsole anzeigen.

12:53.960 --> 12:55.430
Schauen wir uns also die Konsole an.

12:55.520 --> 12:58.520
Die Konsole sagt, dass diese Szene keine Benutzeroberfläche hat.

12:58.550 --> 13:01.430
Siehe die Unity-Konsole hier sind wir in der Konsole.

13:01.430 --> 13:02.090
Wirklich.

13:02.090 --> 13:06.830
Es wird uns nur ein Wert angezeigt, der nach einer erfolgreichen Operation ausgespuckt wurde.

13:06.830 --> 13:12.290
In echtem Produktionscode wäre dies also eine viel interessantere Szene.

13:12.290 --> 13:17.540
Vielleicht findet hier tatsächlich das Spielmenü oder der Spielablauf statt.

13:17.780 --> 13:22.730
Dies ist eine recht magere Szene, in der es nicht viel zu sehen gibt, aber man kann sich vorstellen, dass das

13:22.730 --> 13:23.150
sein.

13:23.720 --> 13:28.880
Es ist nicht besonders wichtig, dass es eine Laufzeitszene für den Test gibt.

13:28.880 --> 13:34.520
Ich möchte nur oft über die Balance zwischen dem Produktionscode und der Produktion sprechen.

13:34.520 --> 13:35.150
Sache.

13:35.150 --> 13:38.480
Und hier drüben ist der Testcode, der sein Test-Ding macht.

13:38.480 --> 13:44.330
Den Produktionscode erleben wir immer, wenn wir auf "Play" in einer Unity-Szene drücken, so wie hier.

13:44.330 --> 13:47.750
Und um unsere Unit-Tests durchzuführen, machen wir etwas anderes.

13:47.780 --> 13:50.990
Was wir hier machen, ist, dass wir uns das Test-Runner-Fenster anschauen.

13:51.530 --> 13:55.340
Wir erkunden die Kategorie, die dem entspricht, was wir uns hier ansehen wollen.

13:55.340 --> 13:57.470
Wir schauen uns nur das System "Mein Mathe" an.

13:58.560 --> 14:01.020
Und dann klicken wir auf "Let's see".

14:01.020 --> 14:02.280
Lass uns einfach den Test im Bearbeitungsmodus machen.

14:02.430 --> 14:06.780
Wir führen alle hier aus und alle Tests laufen einfach so.

14:06.810 --> 14:09.050
Jetzt wurde die Szene nicht wirklich ausgeführt.

14:09.060 --> 14:15.420
Es läuft nur etwas abseits in seinem eigenen kleinen Universum und führt diese Tests innerhalb einer

14:15.420 --> 14:16.290
Bearbeitungsmodus.

14:16.290 --> 14:19.790
Also Tests im Bearbeitungsmodus, um ein wenig über den Unterschied zu sprechen.

14:19.800 --> 14:25.050
Die Tests im Bearbeitungsmodus laufen im Bearbeitungsmodus, den es in Unity in zwei primären Modi gibt.

14:25.050 --> 14:30.630
Im Grunde genommen, von dem Moment an, in dem du den Play-Button drückst, bis zu dem Moment, in dem du den Play-Button drückst, also

14:30.630 --> 14:31.290
Wiedergabemodus.

14:31.320 --> 14:35.440
Das ist im Allgemeinen der Moment, in dem der Benutzer das Unity-Gameplay erlebt.

14:35.610 --> 14:38.430
Immer wenn wir nicht in diesem Modus sind, sind wir im Bearbeitungsmodus.

14:38.430 --> 14:40.170
Wenn wir hier sitzen, sind wir im Bearbeitungsmodus.

14:40.200 --> 14:46.260
Diese Tests werden im Bearbeitungsmodus ausgeführt, weil sie nicht unbedingt die ganze Komplexität einer Laufzeitumgebung benötigen

14:46.260 --> 14:46.800
Szene.

14:46.800 --> 14:52.110
Das hilft uns, einen einfachen kleinen isolierten Bereich zu haben, in dem diese Codes laufen.

14:52.110 --> 14:57.780
Nun braucht man manchmal die Annehmlichkeiten von Monobehaviour und Laufzeitfunktionalität.

14:57.780 --> 15:01.680
Hier kommt der Spielmodus ins Spiel.

15:01.680 --> 15:04.260
Und hier haben wir auch einige Tests für den Spielmodus.

15:04.260 --> 15:09.480
Jedes Mal, wenn ich eines dieser Kontrollkästchen anklicke, werden uns leicht unterschiedliche Listen angezeigt

15:09.510 --> 15:10.740
von dem, was wir zur Verfügung haben.

15:10.740 --> 15:13.140
Hier im Spielmodus drücke ich also auf "run all".

15:13.950 --> 15:18.090
Und hier wird tatsächlich eine brandneue Szene erstellt.

15:18.090 --> 15:24.420
Ausführen einer Laufzeitszene, die nur zu Demonstrationszwecken dient, mit dem Testcode, den ich habe, und dann zurückgibt

15:24.420 --> 15:26.880
zur ursprünglichen Szene zurück, in der wir uns befanden.

15:26.880 --> 15:31.110
Wenn wir die Szene nicht gespeichert hätten, würde es uns sagen: Hey, du bist dabei, einen Spielmodus zu starten

15:31.140 --> 15:31.620
Test.

15:31.650 --> 15:33.360
Wir werden Ihre Szene vorübergehend verlassen.

15:33.390 --> 15:35.040
Willst du deine Szene zuerst speichern?

15:35.040 --> 15:37.500
Im Allgemeinen ist das eine gute Idee, also achten Sie darauf.

15:37.530 --> 15:39.300
Schauen wir uns nun den Quellcode an.

15:39.330 --> 15:43.020
Schauen wir uns zuerst den Produktionscode zur Laufzeit an.

15:43.020 --> 15:45.810
Wir öffnen also das My Math System Beispiel.

15:45.810 --> 15:52.740
Jeder dieser Workshops hat, allgemein gesprochen, ein Spielobjekt mit einem Beispielskript, das folgende Schritte ausführt

15:52.740 --> 15:53.580
alles in Gang setzt.

15:53.580 --> 15:59.490
Wenn wir uns das also ansehen, sind wir hier im Code-Editor und können das komplette my math-System sehen

15:59.490 --> 16:00.180
Beispiel.

16:00.180 --> 16:05.670
Dies ist ein Monobehaviour, weil ich die Annehmlichkeiten von Code in einem Spielobjekt haben möchte.

16:05.670 --> 16:10.380
Und dann werde ich innerhalb des await hier etwas Produktionscode simulieren.

16:10.380 --> 16:16.140
Jetzt ist es sehr schlank, es gibt nicht viel zu tun, und es sieht genauso aus wie der Test, den wir gerade machen

16:16.140 --> 16:21.780
anschauen werden, weil ich die Klasse von Grund auf neu erzeuge und dann eine Methode aufrufe, und dann zeige ich

16:21.780 --> 16:22.530
die Ergebnisse.

16:22.530 --> 16:28.320
Aber es ist wichtig zu wissen, dass in einem Produktionsbeispiel, in einem echten Spielprojekt, dieses Äquivalent

16:28.320 --> 16:33.600
viele Klassen und all die Szenen und all die Prefabs und all die Komplexität, die man normalerweise hat

16:33.600 --> 16:34.530
in Ihrem Projekt haben.

16:34.530 --> 16:37.230
Aber hier halte ich es absichtlich sehr schlank.

16:37.230 --> 16:38.910
Beachten Sie also, was wir hier tun.

16:38.910 --> 16:40.920
Wir erstellen das my math-System.

16:40.920 --> 16:45.750
Wir nehmen ein paar Ints und füllen sie mit den Werten fünf und zehn.

16:45.750 --> 16:47.940
Und dann rufen wir das my Math System auf.

16:47.940 --> 16:50.550
Und wir geben die Fünf und die Zehn zusammen ein.

16:50.550 --> 16:52.500
Und dann zeigen wir hier das Ergebnis.

16:52.500 --> 16:54.030
Machen wir also weiter und tun das.

16:54.030 --> 16:55.470
Hier drücke ich also auf Play.

16:59.430 --> 17:03.560
Und hier unten im Konsolenfenster sehen wir, dass das Ergebnis 15 ist.

17:03.570 --> 17:09.240
Mir gefällt die Einfachheit dieses Beispiels, weil es uns dazu bringt, über eine Welt nachzudenken, in der

17:09.240 --> 17:14.540
in der es keine Unit-Tests gäbe, wie würde ich dann sicherstellen, dass dieser Code funktioniert?

17:14.550 --> 17:21.570
Nun, vielleicht wird dieser Code meines mathematischen Systems an vielen, vielen Stellen in deinem Spiel verwendet, und du einfach,

17:21.570 --> 17:26.970
jedes Mal, wenn du sehen und überprüfen willst, ob dieses System gut funktioniert, spielst du einfach das Spiel und

17:26.970 --> 17:31.110
Ihr Spiel kann mehrere Minuten oder auch mehrere Stunden dauern.

17:31.110 --> 17:37.140
Und dieses spezielle System, das gerade getestet wird, könnte an so vielen verschiedenen Orten eingesetzt werden, je nachdem

17:37.140 --> 17:40.320
von unterschiedlichem Benutzerverhalten, Eingaben und Situationen.

17:40.320 --> 17:42.660
Vielleicht würde die Tageszeit eine Rolle spielen.

17:42.660 --> 17:47.970
Und so ist es schwierig für Sie zu wissen, ob ich es wirklich isoliert teste?

17:47.970 --> 17:56.490
Ein erster Schritt, den ich tun könnte, wenn ich eine Validierung durchführen möchte, ist, dies hier zu kopieren und einzufügen

17:56.490 --> 17:57.360
hier einfügen.

17:59.710 --> 18:02.220
Und dies hier aufrufen und testen.

18:02.230 --> 18:03.790
Nun, was wäre, wenn es sechs wären?

18:03.790 --> 18:05.680
Und was wäre, wenn es 11 wäre?

18:07.710 --> 18:09.360
A bis, B bis.

18:14.010 --> 18:20.000
Jetzt teste ich also keinen Einheitstest, sondern ich überprüfe hier nur zwei verschiedene Beispiele.

18:20.010 --> 18:22.770
Also mache ich das hier als erstes und das hier als zweites.

18:22.800 --> 18:29.760
Das nennt man Benutzertest oder Test im Spielmodus oder Integrationstest, wo ich tatsächlich

18:29.760 --> 18:30.900
Produktionscode.

18:30.900 --> 18:37.710
Und ich probiere es einfach als Benutzer aus, in der Hoffnung, dass ich es versehentlich auffordere, eine Reihe von verschiedenen

18:37.740 --> 18:40.620
Operationen ausführe und sehe, dass keine von ihnen fehlschlägt.

18:40.650 --> 18:44.790
Aber Sie können sich vorstellen, dass ich hier Dinge hinzufüge, die ich am Ende gar nicht haben will

18:44.790 --> 18:46.140
Benutzererfahrung.

18:46.140 --> 18:52.650
Ich versuche nur, mir ein bisschen mehr Vertrauen in meinen eigenen Code zu geben, indem ich einige Funktionen aufrufe

18:52.650 --> 18:53.910
zusätzliche Zeiten.

18:53.940 --> 19:00.510
Sie könnten auch irgendwo in Ihrem Projekt einen Booleschen Wert setzen, der besagt, dass der Debug-Modus wahr ist, und dann

19:00.510 --> 19:02.280
Sie Ihren gesamten Produktionscode.

19:02.280 --> 19:05.730
Wenn das der Fall ist, werden Sie ein paar zusätzliche Tests durchführen.

19:05.730 --> 19:07.140
Das ist nicht schlecht.

19:07.140 --> 19:12.150
In bestimmten Situationen kann das durchaus hilfreich sein, aber sehen wir uns mal an, wie viel besser die Situation ist

19:12.150 --> 19:12.720
sein kann.

19:12.720 --> 19:15.960
Wenn ich stattdessen Unit-Tests durchführe.

19:15.960 --> 19:18.780
Hier ist also der Code für dieses Projekt.

19:18.780 --> 19:23.010
In diesem Projekt haben wir das My Math System, My Math System Beispiel, das wir uns angeschaut haben.

19:23.700 --> 19:29.580
Die Struktur dieses Systems und die Art und Weise, wie sie zusammenarbeiten, haben wir schon früher in diesem Kurs besprochen.

19:29.580 --> 19:34.350
Aber wir haben einen Editor-Test und einen Laufzeit-Test, über die wir sprechen werden.

19:34.350 --> 19:40.980
Nochmals, jeder Editor-Test wird einen Bearbeitungsmodus ausführen, und er ist im Allgemeinen ideal für Dinge, die nicht

19:40.980 --> 19:44.310
Unity-spezifische Klassen wie Monobehaviour verwenden.

19:44.310 --> 19:49.440
Monobehaviour ist nur dafür gedacht, im Spielmodus in vollem Umfang zu funktionieren.

19:49.440 --> 19:51.390
Hier ist es also nicht so gut geeignet.

19:51.390 --> 19:51.870
So.

19:51.870 --> 19:54.810
Aber für einfache Tests wie den, den wir hier haben, ist es großartig.

19:54.840 --> 19:59.580
Der Laufzeitbereich hier, wo wir den Spielmodus-Test haben, wäre ein großartiger Ort.

19:59.580 --> 20:05.130
Und von jedem dieser Workshops mache ich einen, damit Sie die Unterschiede sehen können.

20:05.130 --> 20:09.960
Aber es ist wichtig zu bedenken, dass man in bestimmten Situationen, je nachdem, was man testet, wahrscheinlich

20:09.960 --> 20:14.010
ein Unit-Test im Bearbeitungsmodus in dieser Situation besser geeignet ist.

20:14.010 --> 20:18.630
Das ist auf jeden Fall später der Fall, wenn es darum geht, sich mit der Eingabe zu bewegen und etwas zu tun mit

20:18.630 --> 20:24.750
Physik, vielleicht ist da der Spielmodus-Test erforderlich, weil Eingabe und Physik wirklich darauf ausgelegt sind

20:24.750 --> 20:26.220
als Erfahrungen im Spielmodus.

20:26.220 --> 20:28.650
Es ist also wichtig, diesen Unterschied zu kennen.

20:28.650 --> 20:30.030
Und ich werde es hier und da erwähnen.

20:30.270 --> 20:32.760
Schauen wir uns also den Test zum mathematischen Denkvermögen an.

20:36.190 --> 20:39.130
Und sehen Sie, wie das organisiert ist.

20:40.710 --> 20:45.990
Hier sehen Sie, dass der My-Math-Systemtest ein paar Unterschiede aufweist.

20:51.350 --> 20:53.180
Er hat einige verschiedene Methoden darunter.

20:53.330 --> 20:57.500
Jeder der Namen, die wir hier sehen, sind die Namen der Testmethoden.

20:57.500 --> 20:59.000
Fangen wir also mit der ersten an.

20:59.600 --> 21:04.970
Die Konvention, die ich gerne verwende, wird hier befolgt, und wir werden sie in dem Code, den ich normalerweise einfüge, weiter ausführen

21:04.970 --> 21:10.460
zuerst, welche Methode wir testen, was wir erwarten und dann, wie die Situation ist.

21:10.460 --> 21:13.400
Hier steht also, dass wir die Add-Methode testen.

21:13.400 --> 21:18.080
Wir erwarten, dass das Ergebnis 15 sein wird, wenn wir fünf und zehn eingeben.

21:18.320 --> 21:23.750
Eine nette Abkürzung ist, dass man beim Ausführen eines Tests einfach doppelt darauf klicken kann, um ihn erneut auszuführen.

21:24.800 --> 21:26.540
Und dann kann ich mit der rechten Maustaste darauf klicken.

21:28.490 --> 21:29.360
Entschuldigung, ich war im Spielmodus.

21:29.810 --> 21:31.850
Doppelklick darauf und es läuft wieder.

21:31.880 --> 21:32.330
Sehr gut.

21:32.330 --> 21:33.230
Immer noch grün.

21:33.230 --> 21:36.560
Und ich kann mit der rechten Maustaste darauf klicken und Open Source Code wählen.

21:37.720 --> 21:41.800
Das ist ein einfacher Weg, um direkt zur richtigen Klasse und zur richtigen Methode zu gelangen.

21:41.830 --> 21:44.320
Hier ist wieder der Methodenname, den wir gesehen haben.

21:44.350 --> 21:47.860
Wieder ist das Ergebnis 15, wenn man fünf und zehn addiert.

21:47.890 --> 21:54.070
Der Grund, warum das wichtig ist, ist, dass wenn man viele Testklassen mit vielen Testmethoden hat,

21:54.070 --> 22:01.600
und ich hoffe, dass Sie das in Ihrem Projekt tun, um herauszufinden, was in einem Test Runner was im Code ist

22:01.600 --> 22:04.610
Basis hier, es ist schön, diese konsistente Benennung zu haben.

22:04.630 --> 22:09.910
Was wir hier also tun, ist die Methodik arrange, act und assert.

22:09.910 --> 22:10.720
In der Anordnung.

22:10.720 --> 22:15.310
Als erstes erstellen wir eine neue Instanz von dem, was wir testen wollen.

22:15.310 --> 22:19.420
Auf diese Weise wissen wir, dass sie nicht herumgelegen hat und keine alten Daten in ihr enthalten sind.

22:19.430 --> 22:20.770
Das ist immer eine gute Praxis.

22:20.770 --> 22:22.480
Dann werden wir danach handeln.

22:22.480 --> 22:26.140
Das ist wie, was ist die eine Methode, wenn man damit durchkommen kann?

22:26.140 --> 22:28.690
Vielleicht zwei Methoden, die wirklich den Test machen.

22:28.690 --> 22:30.160
Aber eine Methode ist ideal.

22:30.190 --> 22:32.680
Hier addieren wir fünf und zehn zusammen.

22:32.680 --> 22:36.670
Und dann in der Assert-Sprache werden wir diese Assert-Sprache verwenden.

22:36.670 --> 22:43.630
Die Assert-Klasse hat eine bestimmte Struktur, in der man sagt, ich behaupte, dass etwas etwas ist.

22:43.630 --> 22:48.670
Und Sie können sich die Dokumentation dazu ansehen, um eine Vielzahl von Möglichkeiten zu sehen, wie Sie das formatieren können.

22:48.670 --> 22:54.790
Aber oft verwende ich is equal to oder is true oder is false.

22:54.790 --> 22:57.670
Das sind also die, die man hier recht häufig sieht.

22:57.970 --> 23:02.920
Wenn ich das ausführe, weil der Code korrekt läuft, addiert er fünf und zehn zu 15.

23:02.950 --> 23:03.700
Das war's.

23:03.730 --> 23:05.010
Wir sind in der Lage, das zu tun.

23:05.020 --> 23:08.620
Erinnern Sie sich jetzt an das Beispiel, das ich im Produktionscode gegeben habe.

23:08.620 --> 23:17.650
Was wäre, wenn Sie fünf und zehn testen wollten und dann sechs und 11 und dann sieben und 12 oder was auch immer

23:17.650 --> 23:18.700
Kombinationen?

23:18.700 --> 23:25.510
Je besser man beim Testen wird, desto mehr Tests braucht man, um eine angemessene Abdeckung zu erreichen.

23:25.510 --> 23:31.180
Es ist eine Kunst und eine Wissenschaft, wie viele Tests man mindestens durchführen kann, um eine ausreichende Abdeckung zu erreichen.

23:31.180 --> 23:34.720
Ihre Wirkung und die Codeabdeckung, die Sie haben, maximieren?

23:34.750 --> 23:40.030
Eines der Dinge, über die ich im Rahmen dieses Workshops sprechen wollte, sind die sogenannten

23:40.030 --> 23:41.830
parametrisierte Tests.

23:41.830 --> 23:48.460
Anstatt also einfach diesen hier zu kopieren, ihn unten einzufügen und die Werte so zu verändern, dass sie sich zu sechs addieren

23:48.460 --> 23:55.780
und 11 oder 0 und negative Zehn zu addieren, können wir Unity bitten, genau denselben Test durchzuführen, aber mit anderen

23:55.780 --> 23:56.530
Werte.

23:56.530 --> 23:58.750
Hier gibt es eine Menge verschiedener Optionen.

23:58.750 --> 24:00.340
Ich zeige hier nur eine von ihnen.

24:00.340 --> 24:02.800
Aber schauen wir mal hier unten nach.

24:03.730 --> 24:10.090
Wir sagen, und zusammen, dass wir davon ausgehen, dass das Ergebnis korrekt ist, wenn diese Werte.

24:10.090 --> 24:15.640
Also die Methodennamen sind ein bisschen vager, weil sie parametrisiert sind, ich weiß nicht unbedingt.

24:15.640 --> 24:18.430
Ist das ein Test für fünf und zehn ist 15.

24:18.460 --> 24:24.250
Beachten Sie, dass ich hier anstelle von fünf und zehn, was ich vorher gemacht habe, fünf und zehn deklariert habe.

24:24.280 --> 24:29.890
Im Hauptteil der Methode verwende ich diese besondere Sprache, ich verwende etwas, das sich Wertquelle nennt.

24:29.890 --> 24:31.210
Und dann übergebe ich es.

24:31.210 --> 24:37.090
Was Unity macht, ist, dass es diese ersten Werte hier einträgt.

24:37.090 --> 24:38.740
Sagen wir also, es sind fünf.

24:38.770 --> 24:41.290
Dann wird hier eine weitere Wertquelle geholt.

24:41.320 --> 24:48.010
Sagen wir, das eine ist zehn und es nimmt an, dass sie fünf plus zehn addiert sind.

24:48.010 --> 24:52.960
Bei jedem Durchlauf wird also das Äquivalent des letzten Tests durchgeführt, den wir gesehen haben.

24:52.960 --> 24:59.050
Aber anstatt nur auf einen Satz von Werten festgelegt zu sein, wird er sie mischen und eine Vielfalt zeigen

24:59.050 --> 24:59.560
von ihnen.

24:59.560 --> 25:02.460
Auch hier gibt es viele verschiedene Möglichkeiten, dies zu formatieren.

25:02.460 --> 25:06.670
Sie sollten sich die Dokumentation für parametrisierte Tests in Unity ansehen.

25:06.670 --> 25:08.920
Aber lassen Sie uns meinen speziellen Fall hier betrachten.

25:08.950 --> 25:11.350
Diese Wertquellen haben die Werte A und b.

25:11.350 --> 25:14.770
Sie beziehen sich einfach auf ein paar Arrays, die ich hier oben habe.

25:14.770 --> 25:20.980
Und was es tun wird, ist einfach durchzugehen und eins und eins zu testen, negativ zwei und

25:20.980 --> 25:23.530
Negativ zwei, Negativ drei und Negativ drei und leitet sie ein.

25:23.560 --> 25:30.070
Man kann sie so organisieren, wie man will, und verschiedene Szenarien testen, in denen man vielleicht sieben, 11

25:30.070 --> 25:30.670
und 12.

25:30.700 --> 25:32.230
Man kann alles testen, was man will.

25:32.260 --> 25:35.020
Jetzt muss man nicht mehr unendlich viel testen.

25:35.020 --> 25:37.450
Hier kommt die Kunst und die Wissenschaft ins Spiel.

25:37.450 --> 25:43.960
In manchen Szenarien möchte man vielleicht ein paar negative Werte mit Null und ein paar positive Werte testen.

25:43.990 --> 25:48.820
Vielleicht ist das, was du tust, nicht mathematisch begründet und du möchtest es auf eine andere Art und Weise betrachten, aber was du tust

25:48.820 --> 25:51.370
nach so genannten Eckfällen suchen.

25:51.370 --> 25:57.250
Wenn Sie zum Beispiel eine Divisionsmethode anwenden und sie mathematisch testen wollen, gibt es

25:57.250 --> 25:59.740
eine Herausforderung bei der Division durch Null.

25:59.740 --> 26:03.970
Du solltest also darauf achten, dass du die Null einfügst und das elegant handhabst.

26:03.970 --> 26:09.040
Sie müssen wirklich die spezifische Domäne kennen, in der Ihr Produktionscode liegt, um zu wissen, wie

26:09.040 --> 26:09.730
zu testen.

26:09.730 --> 26:14.020
Aber hier jeweils ein paar positive und negative und solche Sachen.

26:15.200 --> 26:17.950
Schauen wir uns mal an, wie das im Unity-Editor aussieht.

26:17.960 --> 26:19.670
Beachte, was es hier macht.

26:19.670 --> 26:24.980
Es führt tatsächlich 49 Tests durch, die auf allen Kombinationen basieren, die wir hier haben.

26:24.980 --> 26:28.850
Es zeigt Ihnen also an, wann Werte vorhanden sind, und gibt sie dann ein.

26:28.850 --> 26:30.430
Das ist wirklich schön.

26:30.440 --> 26:37.430
Wenn du dir jetzt diese Ausgabe ansiehst, wirst du vielleicht feststellen, dass es für mich wichtig ist, 100 zu testen

26:37.430 --> 26:38.800
und -100.

26:38.810 --> 26:39.320
Sehr gut.

26:39.320 --> 26:45.890
Dann gehst du einfach zurück und fügst diese Beispielwerte ein, wenn du andere Dinge tun willst, anstatt nur eine harte

26:45.890 --> 26:46.610
kodierte Liste.

26:46.610 --> 26:50.510
Wenn du einen Zufallswert auswählen willst, hast du viele andere Möglichkeiten.

26:50.510 --> 26:53.180
Recherchieren Sie noch einmal über parametrisierte Tests.

26:53.360 --> 26:57.860
Sie können sich auch mit dem Spielmodus-Test befassen, wenn Sie wollen, aber da dieser interessanter sein wird

26:57.860 --> 27:02.000
interessant ist, machen wir weiter und schließen diesen Workshop ab.

27:02.000 --> 27:02.840
Danke.

27:09.660 --> 27:13.260
Hallo und herzlich willkommen zu diesem Unity Unit Testing Workshop.

27:13.260 --> 27:16.830
Wir werden uns meinen Datenlader Basic als Beispiel ansehen.

27:16.830 --> 27:17.420
Fangen wir an.

27:17.430 --> 27:20.280
In dieser Demo werde ich also Unity öffnen.

27:20.280 --> 27:25.650
Öffne unser Kernprojekt und sieh dir die Szene meines Data Loader Basic an.

27:25.650 --> 27:31.500
Der Grund, warum ich mich entschieden habe, eine Art von Datenladen zu machen, ist, um darüber zu sprechen, nun, was

27:31.500 --> 27:39.900
wenn unsere Unit-Tests, von denen wir hoffen, dass sie sehr zuverlässig und isoliert sind und schnell laufen, zum Wohle unserer

27:39.900 --> 27:42.000
eigenen Testmethodologien?

27:42.000 --> 27:47.760
Was ist, wenn sie von anderen Systemen abhängen? Wie können wir sicher sein, dass wir nur einen Teil testen können?

27:47.790 --> 27:55.740
Im Allgemeinen wird bei Unit-Tests eine einzelne Einheit getestet, die man sich als eine Methode einer Klasse vorstellen kann.

27:55.740 --> 28:01.740
Aber oft besteht unser Code aus mehreren Klassen, die zusammenhängen, und das kann eine Herausforderung für die Entscheidung sein

28:01.740 --> 28:05.100
wie man sie trennen und isoliert testen kann.

28:05.100 --> 28:11.280
Man könnte auch ein System haben, das von etwas Asynchronem abhängt, wie das Rendern von Grafiken, das Rendern

28:11.280 --> 28:14.760
Audio, oder in diesem Fall der Aufruf eines Backend-Servers.

28:14.760 --> 28:22.380
Ich habe hier also ein sehr einfaches Beispiel erstellt, das Daten lädt, die man in einer URL angibt, es ruft einfach eine Webseite auf

28:22.380 --> 28:24.630
und bekommt den Text der Webseite zurück.

28:24.660 --> 28:31.410
Dies ist also das einfachste Beispiel, aber Sie können sich vorstellen, dass dies eine beliebige Serverlogik ist, die aufruft, um zu senden

28:31.410 --> 28:36.540
einen Highscore von deinem Spiel, einen Aufruf zum Laden von Spielerdaten, irgendetwas im Zusammenhang mit Multiplayer.

28:36.540 --> 28:41.250
Vielleicht könnten alle diese Daten von einem asynchronen Netzwerkverkehr abhängen.

28:41.340 --> 28:42.330
Schauen wir uns das mal an.

28:42.420 --> 28:44.250
Hier sind wir also im Beispiel.

28:44.250 --> 28:46.290
Wir haben meinen Data Loader Basic.

28:46.290 --> 28:46.890
Laden Sie es auf.

28:46.890 --> 28:47.940
Drücken wir auf Play.

28:50.730 --> 28:51.990
In dieser speziellen Demo.

28:52.020 --> 28:56.550
Es gibt keine wirklich interessanten Dinge in dieser speziellen Demo.

28:56.580 --> 28:58.950
Beim Gameplay gibt es keine allzu interessanten Dinge zu sehen.

28:59.220 --> 29:02.940
Wir gehen hier auf die Konsole und sehen, dass diese Szene keine Benutzeroberfläche hat.

29:02.970 --> 29:09.300
Die Unity-Konsole zeigt nur die Länge dessen, was vom Server zurückgegeben wird.

29:09.300 --> 29:13.200
Alles, was nicht Null ist, bedeutet: Hey, es wurde eine Seite geladen.

29:13.200 --> 29:14.670
Also sehr leicht.

29:14.670 --> 29:15.690
Einfacher Test.

29:15.690 --> 29:19.190
Ich habe keine Fehlerprüfung oder solche Dinge eingebaut.

29:19.200 --> 29:23.640
Der Einfachheit halber wird in dieser Demo nur der Erfolg angenommen.

29:23.670 --> 29:27.780
Wenn Sie produktiven Code machen und Server aufrufen, würden Sie viel mehr Funktionalität hinzufügen wollen

29:27.780 --> 29:28.410
hinzufügen.

29:28.410 --> 29:32.770
Das ist also die Erfahrung zur Laufzeit, die ziemlich einfach und nicht besonders interessant ist.

29:32.790 --> 29:38.550
Wenn wir uns nun den Testrunner ansehen, können wir unsere Kategorie auf meinen Datenlader basic setzen.

29:38.550 --> 29:42.360
Es werden also nur die Tests angezeigt, die sich auf diesen speziellen Code beziehen.

29:42.360 --> 29:44.160
Und dann gehen wir in den Bearbeitungsmodus.

29:44.160 --> 29:48.210
Hier haben wir wieder den Spielmodus, aber Sie können das selbst erkunden.

29:48.210 --> 29:52.230
Ich finde, dass der Bearbeitungsmodus für diese spezielle Demo interessanter ist.

29:52.230 --> 29:54.660
Ich drücke also auf "Alles ausführen".

29:56.330 --> 29:58.350
Und wir können sehen, dass wir Erfolg haben.

29:58.370 --> 30:04.520
Dies sagt, dass load async result doctype enthält, wenn es geladen wird.

30:04.520 --> 30:06.500
Schauen wir uns das mal ein bisschen an.

30:06.630 --> 30:08.780
Wir gehen hierher und öffnen unsere Quelle.

30:10.200 --> 30:11.820
Und hier ist der Test.

30:11.940 --> 30:17.640
Es zeigt, dass wir zuerst eine Instanz unseres My Data Loader basic erstellen.

30:17.940 --> 30:21.660
Dann warten wir darauf, dass sie geladen wird.

30:22.610 --> 30:25.880
Wir überprüfen die Daten, die vom Server zurückgeladen werden.

30:25.890 --> 30:30.800
Auch hier wird nur eine Webseite aufgerufen, und was auch immer der Quellcode der Webseite zurückgibt, wird als

30:30.800 --> 30:32.030
großer Klumpen Text.

30:32.030 --> 30:34.370
Es wird also wie ein HTML-Kram aussehen.

30:34.370 --> 30:39.920
Und als ich es mir anschaute, während ich das hier erstellte, bemerkte ich, dass es doctype als Teil davon sagte.

30:39.920 --> 30:45.530
Doctype ist also nichts super Wichtiges, jedenfalls nicht in der Unity-Welt, aber ich dachte einfach

30:45.530 --> 30:49.640
es ist ein kleiner Test, der mir sagt, habe ich etwas von einer Webseite zurückbekommen?

30:49.640 --> 30:53.030
Sie können sich vorstellen, dass Sie auf jede andere Teilzeichenkette testen, die für Sie sinnvoll ist.

30:53.120 --> 31:00.020
Schließlich führe ich hier die Aktion aus, die wir testen, und lade den asynchronen Aufruf dort

31:00.020 --> 31:01.340
und gebe die URL ein.

31:01.370 --> 31:05.690
Beachten Sie, dass die URL die URL der GitHub-Seite ist.

31:05.690 --> 31:07.280
Aber das ist nicht so wichtig.

31:07.430 --> 31:08.600
Hier gibt es nichts Einzigartiges.

31:08.600 --> 31:15.620
Wenn man z.B. google.com testen will, ruft es einfach google.com auf und holt sich die Quelle

31:15.620 --> 31:16.820
Code von dort zurück.

31:16.820 --> 31:22.220
Ich möchte mich nicht wirklich darauf konzentrieren, was ich hier im Produktionscode mache, denn es ist zugegebenermaßen eine

31:22.220 --> 31:23.330
einfaches Beispiel ist.

31:23.330 --> 31:28.640
Ich wollte nur, dass es eine Möglichkeit ist, etwas Asynchrones in Unity zu machen.

31:29.800 --> 31:32.500
Schauen wir uns also den Quellcode an, nur damit wir es verstehen.

31:33.520 --> 31:33.970
Hier.

31:33.970 --> 31:34.540
Was wir hier tun.

31:34.540 --> 31:38.740
Wenn ich load aufrufe, sage ich einfach, hey, stell sicher, dass die URL nicht leer ist.

31:39.130 --> 31:44.320
Dann benutze ich die Webanforderung von Unity, die eine eingebaute Funktionalität ist.

31:44.320 --> 31:51.520
Ich rufe send request auf und setze das Ergebnis auf den Text des Download-Handlers.

31:51.550 --> 31:53.830
Das ist ein super billiger, einfacher Weg.

31:53.830 --> 31:57.010
Von unity empfohlen, um einfache Daten online abzurufen.

31:57.040 --> 31:58.570
Sehr einfach und übersichtlich.

31:58.600 --> 32:02.860
Nun stellt sich die Frage, was wir hier eigentlich testen?

32:03.280 --> 32:09.580
Ich habe eine benutzerdefinierte Klasse mit dem Namen "Data Loader", aber im Inneren bin ich stark von einer bestehenden Unity abhängig

32:09.610 --> 32:12.160
Funktionalität von Unity Web Request.

32:12.190 --> 32:16.060
Dann rufe ich eine Webseite auf, in diesem Fall GitHub.

32:16.060 --> 32:17.650
Und das ist involviert.

32:17.650 --> 32:22.810
Wenn GitHub für einen Tag nicht erreichbar wäre, würde dieser Test fehlschlagen.

32:22.840 --> 32:24.100
Ist das angemessen?

32:24.100 --> 32:31.000
Wenn es bei meinem Unit-Test wirklich darum geht, meine eigene Methodik, meine eigene Funktionalität zu testen, sollte ich nicht in Betracht ziehen

32:31.000 --> 32:32.050
einen fehlgeschlagenen Test betrachten.

32:32.050 --> 32:34.840
Wenn eine nicht verwandte Abhängigkeit fehlschlägt.

32:34.840 --> 32:36.610
Aber hier ist das der Fall.

32:36.610 --> 32:38.640
Ich würde scheitern, wenn GitHub nicht verfügbar wäre.

32:38.650 --> 32:44.440
Außerdem verwende ich hier die Unity-Webanforderung, die eine von Unity eingebaute Funktionalität ist.

32:44.470 --> 32:50.920
Wir hoffen, dass es zu 100% in allen Situationen funktioniert, aber es ist möglich, dass mein Code funktioniert und

32:50.920 --> 32:52.210
sein Code nicht funktioniert.

32:52.210 --> 32:54.520
Es gibt hier also eine Grauzone.

32:54.520 --> 32:59.680
Wenn Sie darüber nachdenken, Ihre Klassen zu entwerfen und dann die Tests für diese Klassen zu entwerfen, wie machen Sie

32:59.680 --> 33:01.990
wissen Sie, worauf Sie sich tatsächlich konzentrieren sollten?

33:01.990 --> 33:04.390
Testen, im Allgemeinen.

33:04.390 --> 33:09.550
Und es gibt Bücher und Bücher, die zu diesem Thema geschrieben wurden, wie man die Kunst des Unit-Testens angeht.

33:09.550 --> 33:15.370
Aber im Allgemeinen möchte man seine Abhängigkeiten reduzieren und die Anzahl der Tests vereinfachen.

33:15.370 --> 33:17.530
von Codezeilen, die man testet.

33:17.530 --> 33:24.490
Weniger Code ist also besser, weil er einfacher und zielgerichteter ist und man genau weiß, welche

33:24.490 --> 33:26.020
Code man testet.

33:26.020 --> 33:28.000
Dies ist also ein perfektes Beispiel.

33:28.000 --> 33:32.950
Aber für uns ist es ein guter Weg, um anzufangen und einfach über asynchronen Code zu sprechen.

33:32.950 --> 33:35.020
Also beenden wir dieses Beispiel für den Moment.

33:42.300 --> 33:44.460
Hallo und willkommen zu Unit Testing für Unity.

33:44.490 --> 33:48.120
Wir werden uns hier meinen Datenlader in der erweiterten Version ansehen.

33:48.120 --> 33:54.270
Um diese Demo in Aktion zu sehen, öffnen wir den Unity Download und verwenden das Source Beispielprojekt für

33:54.270 --> 33:55.020
diesen Kurs.

33:55.020 --> 33:57.120
Und wir werden uns hier eine Schlüsselszene ansehen.

33:57.120 --> 33:59.310
Das ist der erweiterte My Data Lader.

33:59.310 --> 34:05.310
Zu den Konzepten, über die ich hier sprechen werde, gehört die Injektion von Abhängigkeiten, wie wir sie sehen, und der Endersatz.

34:05.310 --> 34:11.250
Hier sind wir innerhalb von Unity, ich habe die Szene für den My Data Loader fertig und bereit, hier loszulegen.

34:11.250 --> 34:16.170
Also werden wir diese Szene für eine ganze Reihe von Szenen im Workshop ausführen.

34:16.170 --> 34:20.940
Die Produktionsszene zu spielen ist nicht das Interessante, aber ich ermutige Sie immer dazu, es einfach zu tun

34:20.940 --> 34:21.990
als Ausgangspunkt.

34:21.990 --> 34:28.410
Hier sehen wir also ein einfaches Konsolenprotokoll, das die Länge der geladenen Daten anzeigt.

34:28.440 --> 34:32.220
Dieser Wert ist nicht sehr wichtig, aber Sie können sich die Beispielklasse ansehen, wenn Sie wollen

34:32.220 --> 34:32.550
ansehen wollen.

34:32.550 --> 34:34.290
Führen wir den Test dazu aus.

34:36.660 --> 34:40.200
Hier oben habe ich meine Kategorie auf den Datenlader Advanced eingestellt.

34:40.200 --> 34:44.430
Wir sehen also nur die Tests, die damit zusammenhängen, und nur im Bearbeitungsmodus.

34:44.460 --> 34:47.430
Es gibt auch einen Test im Spielmodus, den ihr euch in Ruhe anschauen könnt.

34:47.430 --> 34:49.710
Aber ich denke, dass der Bearbeitungsmodus hier interessanter ist.

34:49.710 --> 34:51.600
Also werde ich alle Läufe machen.

34:57.250 --> 35:01.540
Und hier sehen wir, dass wir zwei Tests haben, und beide bestehen mit einem grünen Haken, was großartig ist.

35:01.570 --> 35:06.590
Schauen wir uns sowohl den Load Async als auch den Mock Load Async an und sehen wir uns an, wie sie funktionieren.

35:06.610 --> 35:08.350
Hier sind wir also im Beispielcode.

35:08.350 --> 35:11.260
Wenn Sie dem letzten Video gefolgt sind, und ich hoffe, das sind Sie.

35:11.290 --> 35:18.760
Wir haben die Methode besprochen, die wir uns hier ansehen, die einen tatsächlichen Aufruf an einen Webserver verwendet, der lädt

35:18.760 --> 35:21.000
die Daten zurück und prüft den Wert der Daten.

35:21.010 --> 35:24.460
Dies kommt dem Anwendungsfall in der Produktion sehr nahe?

35:24.460 --> 35:26.950
Aber wir haben schon über einige der Probleme gesprochen, die damit verbunden sind.

35:26.980 --> 35:31.150
Teste ich meinen Code oder teste ich den darunter liegenden Unity Web Service?

35:31.180 --> 35:35.260
Teste ich das oder teste ich das Backend von github.com?

35:35.260 --> 35:42.130
Und wenn es sich um einen stabilen Server handelt, sollten Sie Ihre Tests auf Ihren eigenen Code konzentrieren und mindestens

35:42.130 --> 35:43.900
und so wenig Abhängigkeiten wie möglich haben.

35:43.900 --> 35:46.060
Es gibt also einige Probleme damit.

35:46.090 --> 35:51.990
Das erste, was ich gemacht habe, als ich mich mit diesem Thema beschäftigt habe, war, über Dependency Injection nachzudenken.

35:52.000 --> 35:58.630
Nehmen wir an, dass ich in der Produktion eine Möglichkeit haben möchte, dass ich dies aufrufe und dass es implementiert wird, dass

35:58.630 --> 36:00.480
ist die Verwendung des Unity Web Service.

36:00.490 --> 36:04.780
Dann möchte ich zum Testen vielleicht eine zweite Möglichkeit haben, wie ich es angehen kann.

36:04.810 --> 36:11.890
Nun, man könnte ein Flag in der Codebasis haben, das sagt, dass Debug gleich true oder production ist

36:11.890 --> 36:12.790
gleich falsch ist?

36:12.790 --> 36:17.360
Und in Ihrem Produktionscode machen Sie bestimmte Dinge im Testmodus und bestimmte Dinge nicht.

36:17.380 --> 36:21.930
Ich sehe das oft in Codebasen, aber das ist generell keine gute Praxis.

36:21.940 --> 36:27.880
Sie verunreinigen Ihren Produktionscode mit Dingen, die eigentlich nur für Tests gedacht sind, also ist es nicht so sinnvoll.

36:27.910 --> 36:29.320
Dies ist eine bessere Lösung.

36:29.320 --> 36:30.700
Schauen wir uns mal an, was wir machen.

36:31.270 --> 36:37.450
Nun, im vorigen einfachen Beispiel hatte ich weder ein Konzept für einen Netzdienst, noch habe ich

36:37.450 --> 36:38.220
es hier ein.

36:38.230 --> 36:41.560
Wir haben es einfach erstellt und es hat immer in eine Richtung funktioniert.

36:41.560 --> 36:45.760
Aber die Dependency Injection hier ist, dass ich entscheide.

36:45.760 --> 36:49.170
Hier ist eine benutzerdefinierte Art, wie das funktionieren könnte.

36:49.180 --> 36:53.380
Hier ist ein Teil der Logik, die ich auf verschiedene Weise auswechseln könnte.

36:53.380 --> 36:56.020
Ich deklariere es hier in einer Zeile und gebe es dann ein.

36:56.020 --> 36:59.560
Sie können sich also vorstellen, dass Sie mehrere verschiedene Netzwerkdienste haben.

36:59.560 --> 37:04.120
Ich könnte einen haben, der nur zum Testen ist, einen, der nur für die Produktion ist, einen, der nur auf

37:04.120 --> 37:08.680
eine lokale Festplatte, eine, die für einen bestimmten Backend-Server geeignet ist.

37:08.680 --> 37:09.460
et cetera.

37:09.490 --> 37:12.160
Auch hier gibt es Anwendungsfälle in der Produktion.

37:12.160 --> 37:14.060
Diese Idee der Dependency Injection.

37:14.080 --> 37:16.360
Warum nennen wir es nun Dependency Injection.

37:16.360 --> 37:26.080
Das liegt daran, dass ich, anstatt dass mein fortgeschrittener Datenlader immer nur eine Sache macht, eine Information eingebe, die entscheidet

37:26.080 --> 37:27.610
wie er arbeiten wird.

37:27.610 --> 37:34.090
Anstatt dass die Klasse selbst alles weiß, übergebe ich in diesem Fall eine Abhängigkeit zu

37:34.090 --> 37:36.250
den Unity Web Request Network Dienst.

37:36.250 --> 37:42.610
Schauen wir uns also an, wie das strukturiert ist, und dann werden wir sehen, warum es für uns hilfreich ist, wenn wir unsere

37:42.610 --> 37:43.300
Testen.

37:43.390 --> 37:47.140
Hier ist also der komplette Quellcode für den My Data Loader advanced.

37:47.170 --> 37:49.420
Jetzt möchte ich mich auf zwei Dinge konzentrieren.

37:49.420 --> 37:53.530
Das eine ist, dass ich in seinem Konstruktor diese Abhängigkeit übergebe.

37:53.560 --> 38:01.060
Nun zur Dependency Injection und wie man flexible Klassen aus diesem Konzept der Dependency Injection erstellt

38:01.060 --> 38:03.700
liegen wirklich außerhalb des Rahmens dieses Kurses.

38:03.730 --> 38:06.220
Es ist eine wirklich gute Sache, die Sie sich ansehen sollten.

38:06.220 --> 38:12.730
Du könntest etwas googeln wie D I für Unity oder Dependency Injection für Unity, oder sogar Dependency

38:12.730 --> 38:17.410
Injektion in der objektorientierten Programmierung, um mehr über diese allgemeinen Konzepte zu erfahren.

38:17.410 --> 38:23.160
Aber ich gehe davon aus, dass Sie mit diesen Konzepten einigermaßen vertraut sind, vor allem angesichts meiner Erklärung, die ich gerade gegeben habe,

38:23.170 --> 38:24.460
Lassen Sie uns damit fortfahren.

38:24.490 --> 38:31.810
Jetzt, wo ich das hier als Abhängigkeit übergebe und speichere, kann ich jedes Mal, wenn ich unsere Kernfunktionalität aufrufe

38:31.840 --> 38:38.560
von load async aufrufe, sage ich, okay, wenn ich bereit bin, async zu laden, sage ich einfach meinem Netzwerkdienst

38:38.560 --> 38:39.730
async zu laden.

38:39.730 --> 38:47.020
Sie können sich nun vorstellen, dass ich einen Netzwerkdienst übergeben habe, der ein asynchrones Laden für einen Backend-Server durchführt

38:47.020 --> 38:48.820
einer bestimmten Technologie.

38:48.850 --> 38:50.410
Diese Zeile hier würde das tun.

38:50.650 --> 38:56.920
Wenn ich etwas anderes einführe, das auf die Festplatte schreibt oder von der Festplatte liest, als einen anderen Typ

38:56.920 --> 38:59.980
eines Netzwerkdienstes, würde sich diese Zeile hier wirklich ändern.

38:59.980 --> 39:06.130
Ich muss also nicht 2 oder 3 verschiedene Versionen meines Datenladers haben, der hier erweitert wurde.

39:06.130 --> 39:11.130
Stattdessen übergebe ich eine benutzerdefinierte Implementierung, die dieses spezielle Detail auf eine einzigartige Weise behandelt.

39:11.140 --> 39:15.130
Das ist eine sehr leistungsfähige Methode, um Ihren Code flexibler zu gestalten.

39:15.130 --> 39:23.410
Nun, da wir über die Übergabe einer Abhängigkeit gesprochen haben und wie sie in der Lage ist, die Funktionalität zu verpacken

39:23.410 --> 39:26.650
hier, lassen Sie uns schauen, was die Quelle für diese spezielle ist.

39:26.650 --> 39:31.240
Hier oben in der gleichen Klassendatei habe ich ein paar Dinge zu besprechen.

39:31.240 --> 39:33.580
Erstens, ich habe eine Schnittstelle erstellt.

39:33.700 --> 39:41.230
Diese Schnittstelle hier von I network service erklärt, okay, jeder, der als lebensfähig angesehen werden will

39:41.230 --> 39:47.020
Abhängigkeit betrachtet werden will, muss eine oder mehrere Methoden zur Verfügung haben.

39:47.020 --> 39:51.970
Und in diesem Fall muss es nur die Load Async haben und eine String-URL nehmen.

39:51.970 --> 39:52.720
Das war's.

39:52.750 --> 39:56.620
Wenn Sie sich nicht so gut mit Schnittstellen auskennen.

39:56.940 --> 39:58.560
Bitte sehen Sie sich Schnittstellen an.

39:58.560 --> 40:04.290
Du könntest dir so etwas wie Schnittstellen im Vergleich zu Klassen in C-Sharp oder in Unity ansehen, und du wirst viel sehen

40:04.290 --> 40:05.130
von Beispielen.

40:05.130 --> 40:11.970
Aber ein wichtiger Unterschied ist, dass die Schnittstelle definiert, was die öffentliche API ist, aber sie definiert nicht

40:11.970 --> 40:13.980
um die Implementierung kümmert.

40:14.100 --> 40:17.530
Die Implementierung wird hier unten in einer öffentlichen Klasse deklariert.

40:17.560 --> 40:19.710
Jetzt gibt es Klassen, mit denen Sie wahrscheinlich besser vertraut sind.

40:20.010 --> 40:24.570
Und was wir hier machen, ist, dass wir eine bestimmte Variante davon implementieren.

40:24.600 --> 40:30.360
Der Netzwerkdienst in dieser speziellen Variante sollte Ihnen aus dem vorherigen Video sehr vertraut vorkommen.

40:30.390 --> 40:32.760
Dies ist genau die gleiche Implementierung.

40:33.030 --> 40:40.130
Wir verwenden einfach die Unity-Webanforderung und führen dann die Send-Webanforderungsmethode aus.

40:40.140 --> 40:45.510
Jetzt, wo wir uns den Quellcode angeschaut haben, können wir sehen, dass wir nur Folgendes erstellen

40:45.510 --> 40:48.270
eine benutzerdefinierte Klasse, die einen kleinen Teil der Funktionalität übernimmt.

40:48.270 --> 40:50.520
Und wir geben diese benutzerdefinierte Klasse dort ein.

40:50.520 --> 40:55.010
Aber wir haben jetzt eine erweiterte Klasse für den Datenlader, die viel flexibler ist.

40:55.020 --> 40:59.720
Warum ist die Injektion von Abhängigkeiten gerade in der Welt des Testens relevant?

40:59.730 --> 41:05.370
Nun, wir haben ein wunderbares Dienstprogramm, das wir in Unity für unsere Unit-Tests verwenden können.

41:05.370 --> 41:10.800
Dies ist eine Bibliothek namens N substitute und sie ist hier im Beispielprojekt enthalten.

41:10.800 --> 41:13.980
Werfen wir einen Blick auf eine weitere Testmethode direkt unter der anderen.

41:13.980 --> 41:17.880
Hier wird ein so genanntes Mock einer Klasse verwendet.

41:17.880 --> 41:23.280
Hier haben wir also eine sehr ähnliche Erstellung des My Data Loader advanced.

41:23.280 --> 41:29.070
Und anstatt die Version der Unity-Webanforderung zu übergeben, werden wir etwas tun, das ziemlich ähnlich aussieht

41:29.100 --> 41:29.880
merkwürdig aussieht.

41:29.880 --> 41:32.940
Wir werden eine Ersatzbibliothek verwenden.

41:32.940 --> 41:40.260
Und was wir hier tun werden, ist, dass wir in diesen beiden Zeilen "Hey on the fly" sagen und Folgendes erstellen werden

41:40.260 --> 41:45.000
eine Klasse, die genau die Funktionalität hat, die ich brauche.

41:45.000 --> 41:51.990
Da es sich um eine Mock-Klasse handelt, muss sie nicht unbedingt den Server anrufen.

41:51.990 --> 41:57.450
Stattdessen wird sie in Schlüsselmomenten einen vorhersagbaren Wert an uns zurückgeben.

41:57.450 --> 42:06.660
Denken Sie daran, dass der Test den Datenlader anweist, eine URL innerhalb der Daten zu laden

42:06.660 --> 42:10.740
Loader sagt dem Netzwerkdienst, dass er eine URL laden soll.

42:10.770 --> 42:17.430
Dieser letzte Schritt dauert im Endergebnis eine halbe Sekunde, lädt vom Server und liefert

42:17.460 --> 42:18.870
eine Zeichenkette zurück.

42:18.870 --> 42:23.760
Alles, was ich also in einer Simulationssituation brauche, ist: Okay, rufe nicht einmal einen Server an.

42:23.760 --> 42:27.330
Nur wenn ich das aufrufe, gibst du mir einen String zurück.

42:27.330 --> 42:36.750
Ich sage hier also mit dieser Sprache, dass ich jedes Mal, wenn ich load async aufrufe und einen beliebigen String übergebe

42:36.750 --> 42:41.460
für die URL übergebe, dann das Wort mocked data zurückgeben.

42:41.760 --> 42:48.060
Dann könnte ich hier unten sicherstellen, dass ich das erwartete Ergebnis erhalte, das ich will, anstatt zu prüfen

42:48.060 --> 42:52.020
dass es doctype in der Rückgabe hat, wie ich es vorher getan habe.

42:52.020 --> 42:55.740
Hier kann ich auf die Scheindaten prüfen.

42:55.740 --> 43:04.380
Was wir hier sehen, ist also ein sehr einfaches Beispiel, und es mag nicht nützlich erscheinen, aber stellen Sie sich vor, in einem

43:04.380 --> 43:11.580
komplexeren Beispiel vor, in dem wir nicht nur Daten laden, sondern sie auch lesen, schreiben und transformieren

43:11.580 --> 43:14.850
die Daten, eine ganze Menge, vielleicht 5 oder 6 verschiedene Methoden.

43:14.850 --> 43:21.150
Sie alle könnten auf ganz unterschiedliche Systeme verweisen, aber wenn wir wirklich nur die

43:21.150 --> 43:30.330
Datenlader testen wollen, dann wollen wir Mocked-Fähigkeiten für diese anderen Systeme übergeben, um nur vorübergehend eine Art

43:30.330 --> 43:34.230
ignoriert werden, so dass wir uns auf das konzentrieren können, was wir hier vor uns haben.

43:34.260 --> 43:36.450
Schauen wir uns nun an, was passieren würde.

43:36.450 --> 43:38.940
Ich rufe also das Laden asynchron auf.

43:38.940 --> 43:46.050
Was passieren wird, ist, dass dieses System den vorhergesagten Wert zurückgeben wird.

43:46.050 --> 43:50.220
Und der Datenlader wird dann "loaded" aufrufen.

43:50.220 --> 43:56.160
Und der Ergebniswert ist der Wert, den wir erwarten.

43:56.160 --> 44:00.330
Führen wir dies also im Unity-Editor aus.

44:00.330 --> 44:01.800
Also drücken wir hier auf run all.

44:04.100 --> 44:05.480
Und es funktioniert recht schnell.

44:05.480 --> 44:11.270
Vergleichen wir auch, wenn ich nur load async ausführe, was tatsächlich einen Server aufruft.

44:15.200 --> 44:16.220
Es war schnell.

44:16.250 --> 44:20.690
Wenn ich dann mock load async aufrufe, das keinen Server aufruft.

44:24.630 --> 44:29.840
Es ist vielleicht nicht aus dem Video ersichtlich, aber es ist viel schneller, das MOC aufzurufen.

44:29.850 --> 44:35.150
Und das macht Sinn, denn wir rufen nicht wirklich einen Server an und warten auf ein Ergebnis.

44:35.160 --> 44:38.640
Es geht also nicht nur darum, ein paar Sekunden zu sparen.

44:38.670 --> 44:42.270
Auch hier geht es darum, dass wir uns bei der Entwicklung unserer Tests konzentrieren.

44:42.300 --> 44:44.790
Was wollen wir eigentlich testen?

44:44.790 --> 44:46.920
Und dann wollen wir es isolieren.

44:46.920 --> 44:51.160
Wir testen also nicht wirklich eine Unity Web Services Klasse.

44:51.180 --> 44:53.610
Wir testen kein GitHub-Backend.

44:53.700 --> 44:57.470
Das gemeinsame Testen mehrerer Systeme wird als Integrationstest bezeichnet.

44:57.480 --> 44:59.550
Das ist eine geeignete Art von Test.

44:59.550 --> 45:03.660
Aber das liegt außerhalb dessen, worüber wir hier sprechen, nämlich über Einheitstests.

45:03.660 --> 45:08.430
Nochmals, so wenige Abhängigkeiten wie möglich, wenige Zeilen Code.

45:08.430 --> 45:09.450
Man könnte darüber nachdenken.

45:09.450 --> 45:17.880
So, das war's, wir haben uns angesehen, wie man die Ersatzbibliothek benutzt und wie man einen Mock machen kann für

45:17.880 --> 45:19.710
einen Aufruf an den Backend-Server.

45:19.710 --> 45:20.550
Also danke.

45:26.450 --> 45:29.420
Hallo und willkommen zum Unit-Testing für Unity.

45:29.450 --> 45:30.710
Wir sind hier im Workshop.

45:30.710 --> 45:34.850
Und in diesem werden wir uns den Charakter in einer Grundform ansehen.

45:34.850 --> 45:37.070
Wir werden uns noch ein paar andere ansehen.

45:37.100 --> 45:39.800
Wir beginnen mit den Grundlagen und gehen dann zu etwas Fortgeschrittenem über.

45:39.800 --> 45:41.480
Schauen wir uns diese Demo in Aktion an.

45:41.480 --> 45:42.920
Innerhalb des Unity-Editors.

45:42.920 --> 45:45.830
Wir werden Unity öffnen und unser Beispielprojekt öffnen.

45:45.830 --> 45:49.760
Und dann spielen wir eine oder mehrere Szenen ab, die mit dem Thema hier zu tun haben.

45:49.760 --> 45:55.670
Die Szene wird der Grundcharakter sein, und ich werde über Monobehaviour als etwas sprechen

45:55.670 --> 46:01.160
das getestet werden kann oder nicht, sowie über den Spielmodus gegenüber dem Bearbeitungsmodus, etwas, das ich bereits erwähnt habe

46:01.160 --> 46:02.450
früher im Kurs erwähnt habe.

46:02.450 --> 46:04.010
Wir werden es hierher zurückbringen und darüber sprechen.

46:04.010 --> 46:06.380
Hier sind wir im Projekt und sehen uns das Grundzeichen an.

46:06.380 --> 46:07.760
Lassen Sie uns die Szene starten.

46:13.120 --> 46:20.020
Während also die meisten unserer Workshops, die wir gemacht haben, eine ziemlich langweilige Szene hatten, in der absolut nichts

46:20.050 --> 46:22.830
von Interesse war, haben wir hier ein bisschen mehr.

46:22.840 --> 46:28.470
Wenn wir dort auf Play drücken, sehen wir einen weißen Würfel, der in der Mitte des Bildschirms erzeugt wird.

46:28.480 --> 46:31.030
Ich kann meine Pfeiltasten benutzen und mich bewegen.

46:31.030 --> 46:37.930
Dies ist zwar zugegebenermaßen ein sehr einfaches Beispiel, aber es soll einige der komplexeren Funktionen erläutern

46:37.930 --> 46:40.600
Aspekte des Testens innerhalb von Unity.

46:40.630 --> 46:45.730
In den vorangegangenen Szenen haben wir uns nicht um das Rendern von Grafiken oder die Eingabe von Daten gekümmert.

46:45.970 --> 46:52.840
Wir haben im letzten Workshop über den Unterschied zwischen dem Testen verschiedener Abhängigkeiten gesprochen

46:52.840 --> 46:53.590
zusammen.

46:53.590 --> 46:58.780
Zum Beispiel eine Methode, die innen eine zweite Methode aufruft, die innen eine dritte aufruft.

46:58.810 --> 47:00.490
Das sind Abhängigkeiten.

47:00.520 --> 47:06.790
Hier geht es um einen ähnlichen Aspekt, nur dass ich jedes Mal, wenn ich meine Figur bewegen will, zuerst

47:06.790 --> 47:13.750
das Unity-Eingabesystem abfragen und dann Unitys Monobehaviour für Transformationsbewegungen verwenden.

47:13.750 --> 47:14.190
Richtig.

47:14.200 --> 47:18.820
Wir benutzen also verschiedene Abhängigkeiten oder verschiedene Klassen.

47:21.360 --> 47:24.630
Hier kann ich die Pfeiltasten benutzen, um mich zu bewegen.

47:25.750 --> 47:27.190
Und das war's auch schon.

47:29.010 --> 47:32.100
Aber die Idee ist, dass wir ein bisschen mehr machen als vorher.

47:32.190 --> 47:34.650
Lassen Sie uns über die Auswirkungen der Tests sprechen.

47:34.650 --> 47:41.190
Hier oben im Test-Runner habe ich die Kategorie auf unser Basiszeichen gesetzt, was großartig ist.

47:41.220 --> 47:46.800
Dann kann ich zwischen den Tests im Spiel- und im Bearbeitungsmodus umschalten.

47:46.830 --> 47:53.100
Wir können sehen, dass wir etwas von beidem haben, aber da es sich um ein Monobehaviour handelt, werde ich

47:53.100 --> 47:54.600
mehr auf den Spielmodus konzentrieren.

47:54.630 --> 48:01.230
In jedem der Workshops habe ich mindestens einen Test im Bearbeitungsmodus und mindestens einen im Spielmodus durchgeführt

48:01.260 --> 48:03.420
Test für die jeweilige Szene.

48:03.450 --> 48:09.030
Ich habe das hier noch einmal gemacht, aber je nachdem, was man gerade testet, sollte man sich überlegen, ob das

48:09.030 --> 48:13.470
eher für den Bearbeitungsmodus oder eher für den Spielmodus geeignet?

48:13.500 --> 48:18.510
Es ist eine Kunst und eine Wissenschaft, wie man das angeht, und wie man seinen Code so gestaltet, dass er mehr

48:18.510 --> 48:19.170
testbar ist.

48:19.200 --> 48:26.010
Aber eine allgemeine Betrachtungsweise, die hier relevant ist, ist, dass wenn Sie Monobehaviour-Funktionalität verwenden,

48:26.010 --> 48:32.460
das klingt eher nach einem Play-Mode-Test, desto mehr Unity-Bibliotheken, insbesondere zur Laufzeit, werden Sie

48:32.460 --> 48:36.840
Sie in Ihrer Produktion verwenden, sollten Sie darüber nachdenken, ob es sich dabei um Play-Mode-Tests handelt.

48:36.870 --> 48:40.410
Es ist keine feste Regel, aber das ist ein guter Weg, um darüber nachzudenken.

48:40.650 --> 48:42.490
Führen wir also unsere Tests durch.

48:42.510 --> 48:45.300
Ich habe den Wiedergabemodus und werde alle Tests durchführen.

48:48.880 --> 48:49.210
OK.

48:49.240 --> 48:52.060
Es hat ein paar Sekunden gedauert, aber wir haben sie alle.

48:52.090 --> 48:58.060
Was tatsächlich passiert, wenn man einen Test im Wiedergabemodus ausführt, ist, dass eine brandneue leere Szene erstellt wird und

48:58.060 --> 49:01.840
führt nur einen Test darin aus und zerstört diesen.

49:01.840 --> 49:09.040
Und er erstellt eine brandneue Szene, die garantiert, dass wir den Weltraum haben, der durch eine Szene bereitgestellt wird.

49:09.040 --> 49:16.000
Aber die Frische einer neuen Szene, die keine Abhängigkeiten oder veraltete Informationen hat, die die Welt beeinflussen könnten

49:16.000 --> 49:16.630
den Test.

49:16.630 --> 49:18.230
Das gefällt uns also.

49:18.250 --> 49:25.030
Die Dinge, die ich jetzt tue, sind das Bewegen, das Bewegen nach Schlüsselcode und das Bewegen zu einem bestimmten Ort.

49:25.030 --> 49:27.640
Schauen wir uns also diese Verschiebung zum Test an.

49:29.650 --> 49:31.990
Werfen wir zuerst einen Blick auf den Produktionscode.

49:31.990 --> 49:34.960
Wenn ich also hierher gehe und mir das Basisbeispiel ansehe.

49:36.760 --> 49:38.560
Dies ist der Produktionscode.

49:38.560 --> 49:40.720
Schauen wir uns das an, bevor ich zu den Tests komme.

49:40.720 --> 49:43.960
Hier erstelle ich also nur ein Primitiv.

49:43.990 --> 49:49.030
Man könnte sich vorstellen, dass man hier auch ein Prefab lädt, wenn man das möchte.

49:49.030 --> 49:54.010
Aber ich wollte uns langsam in die ganze Komplexität von Runtime und Unity einführen.

49:54.010 --> 49:56.140
Ich verwende hier also keine Vorabversion.

49:56.140 --> 50:00.130
Ich erstelle einfach einen brandneuen Würfel von Grund auf mit einer Zeile Code.

50:00.130 --> 50:06.820
Ich gebe ihm einen Namen, nur um ihn zu organisieren, und füge dann die Komponente des Monobehaviour hinzu

50:06.820 --> 50:08.620
die ich tatsächlich testen möchte.

50:08.650 --> 50:14.770
Dann verschiebe ich es unter anderem auf den Punkt 000 und zeige, dass

50:14.770 --> 50:16.300
Wert auf dem Bildschirm an.

50:16.300 --> 50:18.850
Schauen wir uns also den Quellcode an.

50:21.530 --> 50:22.960
Hier ist das Grundzeichen.

50:22.970 --> 50:24.770
Dies erweitert das Monobehaviour.

50:24.800 --> 50:32.730
Wenn du dich mit Unity auskennst, verwendest du wahrscheinlich ständig Monobehaviours als bewährte Methode.

50:32.750 --> 50:35.600
Sie wollen anfangen, gewissenhaft zu denken.

50:35.600 --> 50:40.660
Wann ist es angebracht, ein Monoverhalten zu verwenden und wann kann ich etwas anderes verwenden?

50:40.670 --> 50:46.580
Als angehende Entwickler erstellen wir alles als Kind eines Monobehaviour, aber mit der Zeit und Erfahrung

50:46.580 --> 50:49.900
merkt man, dass die Verwendung von Monobehaviours Vor- und Nachteile hat.

50:49.910 --> 50:54.620
Einer der Nachteile ist, dass es in der Vergangenheit schwieriger war, den Weg zu testen.

50:54.620 --> 50:56.570
Unity hat diese Tests für den Spielmodus bereitgestellt.

50:56.570 --> 51:00.950
Jetzt können wir also sicher Playmode testen und wir können Monobehaviours testen.

51:00.950 --> 51:03.630
Das ist großartig, aber es gibt immer noch ein paar Nachteile.

51:03.650 --> 51:08.330
Auch hier wird Monobehaviour auf mehr Einheitssysteme unter der Haube angewiesen sein.

51:08.330 --> 51:13.700
Und wenn wir versuchen, unseren benutzerdefinierten Code zu testen, sind wir vielleicht nicht sicher, wo ein Problem liegen könnte.

51:13.730 --> 51:15.720
Ist es unser Code oder ist es der Code von Unity?

51:15.740 --> 51:18.110
Also, auch hier gibt es ein paar Abhängigkeiten.

51:18.140 --> 51:22.280
Das ist alles in Ordnung, aber es ist etwas, worüber man nachdenken sollte, wenn man seine Klassen entwirft und als

51:22.280 --> 51:23.690
Sie Ihre Tests entwerfen.

51:24.110 --> 51:27.080
Wir haben also eine Bewegungsgeschwindigkeit.

51:27.110 --> 51:28.460
Wir haben eine Bewegungsart.

51:28.460 --> 51:31.390
Das ist nur die Richtung der Pfeiltaste, die ich drücke.

51:31.400 --> 51:33.680
Dann verwenden wir das Update von Unity.

51:33.710 --> 51:36.530
Jetzt möchte ich das Ganze noch einmal überprüfen.

51:38.720 --> 51:39.230
Wirklich.

51:39.230 --> 51:44.960
Die Aktualisierungsschleife hier ist die einzige größere Monobehaviour-Funktionalität, die ich verwende.

51:44.990 --> 51:49.130
Der Rest des Codes muss nicht unbedingt in einem Monobehaviour enthalten sein.

51:49.220 --> 51:53.560
Ich verwende auch das Eingabesystem von Unity, das ist also eine zweite Abhängigkeit.

51:53.570 --> 51:56.760
Schauen wir mal, was ich in jedem Frame der Aktualisierung mache.

51:56.780 --> 51:59.360
Ich rufe diese Methode hier move by input auf.

51:59.390 --> 52:04.340
Ich prüfe, ob der Benutzer eine bestimmte Taste oder Tasten auf der Tastatur drückt.

52:04.340 --> 52:08.360
Und dann rufe ich die Bewegung nach Tastencode hier unten auf.

52:09.710 --> 52:16.220
Alles, was wir tun, ist zu sagen, wenn wir uns gerade nach links bewegen, dann bewegen wir uns in einem Vektor in die linke Richtung.

52:16.220 --> 52:19.820
Wenn wir uns gerade nach rechts bewegen und so weiter für oben und unten.

52:19.820 --> 52:24.860
So kann man sich also mit den vier Pfeiltasten in alle vier Richtungen bewegen.

52:24.860 --> 52:26.420
Also ein ziemlich einfacher Code.

52:26.420 --> 52:30.440
Wenn du schon einmal eine eigene Spielfigur erstellt hast, kennst du die folgenden Einstellungen

52:30.440 --> 52:30.980
so einzustellen.

52:34.010 --> 52:35.870
Hier unten haben wir zwei Methoden.

52:35.870 --> 52:41.240
Eine, mit der wir uns zu einem bestimmten Punkt bewegen können, und eine, mit der wir uns um eine Einheit bewegen können.

52:41.240 --> 52:44.090
Nehmen wir also an, ich möchte mich um eine Einheit nach rechts bewegen.

52:44.090 --> 52:48.490
Ich könnte um eine Einheit nach innen gehen, um eine Einheit, um eine Einheit.

52:48.500 --> 52:53.740
Wenn ich mich direkt zu einem bestimmten Punkt im Raum bewegen möchte, wäre das die Bewegung nach.

52:53.750 --> 52:59.810
Dies sind also nicht unbedingt die einzigen Methoden, die man in einer benutzerdefinierten Zeichenklasse braucht, aber es gibt

52:59.810 --> 53:01.100
einige ziemlich übliche Methoden.

53:01.100 --> 53:07.850
Wir beenden diese Lektion hier mit einer einfachen, funktionierenden Methode, um einige Funktionen zu testen.

53:07.850 --> 53:13.340
Wenn Sie einen Blick auf den Bearbeitungsmodus oder die anderen Tests werfen wollen, die hier im Wiedergabemodus sind, nur zu

53:13.340 --> 53:14.230
und tun Sie das.

53:14.240 --> 53:15.830
Ich mache mit dem nächsten Video weiter.

53:15.830 --> 53:16.580
Danke.

53:22.920 --> 53:26.060
Hallo und willkommen zu Unit Testing für Unity.

53:26.070 --> 53:30.060
In diesem Workshop schauen wir uns die Charakterklasse in einer fortgeschrittenen Version an.

53:30.060 --> 53:31.980
Schauen wir uns diese Demo in Aktion an.

53:31.980 --> 53:32.310
Hier.

53:32.310 --> 53:33.990
Wir werden unsere Unity öffnen.

53:34.020 --> 53:36.000
Wir werden unser Beispielprojekt öffnen.

53:36.000 --> 53:41.190
Und wir werden uns eine Szene für die erweiterte Situation des Charakters ansehen.

53:41.190 --> 53:44.310
Ich möchte ein wenig über die Codetrennung sprechen.

53:44.340 --> 53:49.110
Früher in einem der Workshops habe ich über die verschiedenen Abhängigkeiten gesprochen, die man hat.

53:49.110 --> 53:51.360
Wenn man zum Beispiel einen Backend-Server aufruft.

53:51.360 --> 53:58.530
Und in dieser Situation haben wir eine Ersatzbibliothek verwendet, um zu spiegeln, dass wir das Backend nicht aufrufen müssen.

53:58.560 --> 54:04.890
Es ist eine ähnliche Diskussion wie hier, wo wir uns ansehen, welche Abhängigkeiten mit einer bestimmten

54:04.890 --> 54:11.640
Test-Szenario involviert sind, und wie wir uns dieser verschiedenen Abhängigkeiten bewusst sein können, und was wir tun wollen, um

54:11.640 --> 54:12.240
hier tun?

54:12.240 --> 54:14.400
Wir werden die Ersatzbibliothek nicht verwenden.

54:14.430 --> 54:18.960
Wir werden darüber nachdenken, unser Monobehaviour von anderem Code zu trennen und einen Blick darauf zu werfen.

54:19.170 --> 54:20.940
Hier sind wir also innerhalb von Unity.

54:21.270 --> 54:22.440
Wir haben eine Produktionsklasse.

54:22.440 --> 54:23.250
Schauen wir uns das mal an.

54:23.250 --> 54:23.850
Läuft.

54:27.540 --> 54:30.510
Hier unten sehen wir, dass wir uns mit den Pfeiltasten bewegen können.

54:30.510 --> 54:34.050
Genau wie im Basisbeispiel ist die Erfahrung des Endbenutzers die gleiche.

54:34.050 --> 54:39.330
Und das ist ein interessantes Beispiel dafür, dass einige der Änderungen, die wir am Code vornehmen

54:39.330 --> 54:44.250
Qualität und Testbarkeit unserer Systeme vornehmen, sich nicht unbedingt auf den Endbenutzer auswirken.

54:44.280 --> 54:45.350
Das ist ein Pluspunkt.

54:45.360 --> 54:48.270
Werfen wir nun einen Blick auf den Produktionscode.

54:48.270 --> 54:50.340
Wir öffnen das erweiterte Zeichenbeispiel.

54:50.340 --> 54:51.890
Hier ist ein vollständiges Beispiel.

54:51.900 --> 54:57.830
Was wir im Kielwasser dieser Beispielklasse tun, ist, ein Primitiv für den Würfel zu erstellen.

54:57.840 --> 55:00.270
Der Organisation halber geben wir ihm einen Namen.

55:00.390 --> 55:08.010
Anstelle einer Zeile, in der wir einfach eine Komponente hinzufügen, die alle unsere Funktionen enthält, machen wir

55:08.010 --> 55:09.180
zwei Schritte.

55:09.450 --> 55:14.700
Das erinnert mich ein wenig an die Dependency Injection, die wir im My Data Loader Beispiel gesehen haben.

55:14.700 --> 55:17.970
Aber dies ist ein anderer Anwendungsfall mit anderen Abhängigkeiten.

55:17.970 --> 55:22.920
Anstelle einer einzigen Zeile add component machen wir also die add component.

55:22.920 --> 55:28.260
Und dann erstellen wir unsere eigene fortgeschrittene Klasse ohne Monobehaviour-Zeichen.

55:28.260 --> 55:30.540
Und wir geben das Monobehaviour ein.

55:30.540 --> 55:35.370
Wir übergeben also die Abhängigkeit, die das erweiterte Zeichen verwenden wird.

55:35.400 --> 55:41.910
Jetzt ist das Zeichen advanced kein Monobehaviour, und dadurch haben wir mehr Flexibilität, wie wir wollen

55:41.910 --> 55:42.480
testen wollen.

55:42.510 --> 55:45.780
Wir könnten es zum Beispiel leichter im Bearbeitungsmodus testen.

55:45.930 --> 55:51.000
Nochmals, wenn Sie Monobehaviours verwenden, ist das eher für Tests im Spielmodus geeignet.

55:51.030 --> 55:53.940
Das ist keine feste Regel, aber das ist eine Möglichkeit, darüber nachzudenken.

55:53.940 --> 56:00.660
Indem wir unser Monobehaviour von unserem Nicht-Monobehaviour trennen, haben wir ein paar mehr Möglichkeiten.

56:00.690 --> 56:06.060
Jetzt sind wir immer noch in einer Spielmodusumgebung, weil dies der Produktionscode ist.

56:06.060 --> 56:08.970
Schauen wir uns an, wie sich unser Quellcode verändert hat.

56:08.970 --> 56:11.010
Hier sind wir also im erweiterten Zeichen.

56:11.040 --> 56:13.220
Sie werden sehen, dass es ziemlich vertraut aussieht.

56:13.230 --> 56:17.790
Der größte Teil des Codes hier wird genau wie im vorherigen Beispiel sein.

56:17.800 --> 56:19.080
Die wenigen Ausnahmen.

56:19.090 --> 56:25.710
Eine davon ist, dass das fortgeschrittene Zeichen in seinem Konstruktor einen Verweis auf das Monobehaviour aufnehmen wird.

56:25.710 --> 56:30.900
Das liegt daran, dass er einige Dinge über den Monobehaviour wissen muss, insbesondere über seine Transformation

56:30.900 --> 56:31.710
Position.

56:31.830 --> 56:38.400
Es gibt auch eine Situation, in der wir die zweite Zeile verwenden und dem Monobehaviour eine Referenz mitteilen müssen

56:38.400 --> 56:40.830
zurück zu uns, da das Zeichen vorgerückt ist.

56:40.860 --> 56:47.460
Dies dient nur dazu, dass das Monobehaviour uns bei jedem Aktualisierungsaufruf mitteilen kann, dass wir die richtige Bewegung ausführen sollen.

56:47.490 --> 56:52.950
Es gibt auch andere Möglichkeiten, dies zu organisieren, aber der Einfachheit halber geben wir das Monobehaviour ein

56:52.950 --> 56:54.360
und behandeln es auf diese Weise.

56:54.660 --> 56:57.150
Schauen wir mal, welche anderen Änderungen wir in der Codebasis sehen.

56:58.510 --> 57:00.820
Der Bewegungstyp ist derselbe wie in der Grundversion.

57:00.850 --> 57:03.040
Der Zug nach Eingang ist derselbe.

57:03.940 --> 57:08.260
Hier unten ist der Zug nach Tastencode sehr ähnlich, wenn nicht sogar identisch.

57:09.300 --> 57:15.630
Und hier unten in "move to" und "move by" können Sie sehen, dass wir die Position erhalten und setzen

57:15.630 --> 57:18.300
auf die Transformation des Monobehaviour.

57:18.300 --> 57:25.260
Wir haben hier also wieder eine Nicht-Monobehaviour-Klasse, die das tut, was sie tun kann, ohne dass es eine Abhängigkeit von

57:25.260 --> 57:30.810
Monobehaviour und nur an den nötigsten Stellen spricht sie das Monobehaviour an.

57:30.840 --> 57:36.840
Diese Trennung hilft uns, darüber nachzudenken, wie wir nur das Monobehaviour testen könnten, wenn wir könnten,

57:36.840 --> 57:39.910
wie könnten wir nur das Nicht-Monobehaviour testen, wenn wir das könnten?

57:39.930 --> 57:45.240
Das ist kein perfektes Beispiel, weil es eine Art Zwischenschritt ist, während wir lernen über

57:45.240 --> 57:47.040
wie wir diese richtig trennen können.

57:47.040 --> 57:48.600
Aber ich denke, es ist ein guter Lernprozess.

57:48.600 --> 57:52.500
Schauen Sie sich also den Quellcode für das erweiterte Zeichen an.

57:52.500 --> 57:56.550
Vergleiche ihn mit dem Zeichen basic in deiner eigenen Zeit und sieh dir die Unterschiede an.

57:56.730 --> 57:59.580
Schauen wir uns dann das Beispiel an, das wir machen.

57:59.580 --> 57:59.970
Wiederum.

57:59.970 --> 58:01.500
Hier ist das Beispiel, das wir gesehen haben.

58:01.500 --> 58:02.670
Es sind also diese beiden Zeilen.

58:02.670 --> 58:03.900
Das ist wirklich der Schlüssel.

58:03.930 --> 58:09.960
Wir fügen eine Komponente des Charakter Advanced Monobehaviour zu unserem Spielobjekt hinzu.

58:09.960 --> 58:12.270
Und dann werden wir einen neuen Charakter Advanced erstellen.

58:12.270 --> 58:13.440
Das ist ein separater Schritt.

58:13.440 --> 58:17.010
Sie können sich also vorstellen, dass wir diese beiden Dinge isoliert testen können.

58:17.010 --> 58:19.320
Jetzt sind sie aber ziemlich abhängig voneinander.

58:19.350 --> 58:24.000
Es gibt Möglichkeiten, das so zu ändern, dass das eine nicht direkt vom anderen abhängt.

58:24.000 --> 58:30.330
Oder wir könnten etwas tun, wie wir es im Beispiel des Datenladers getan haben, und eine Ersatzbibliothek verwenden, so dass

58:30.330 --> 58:32.730
wir stattdessen die Abhängigkeit einbinden.

58:32.730 --> 58:38.400
Aber noch einmal, der Einfachheit halber, um zu lernen, wie man ein Monobehaviour abtrennt, denke ich, dass wir das getan haben

58:38.400 --> 58:39.210
der Fall hier.

58:39.210 --> 58:44.100
Sie können diese Tests mit dem Bearbeitungsmodus und dem Wiedergabemodus in Ihrer eigenen Zeit durchführen und sich das ansehen.

58:44.370 --> 58:50.460
Aber für mich sind wir fertig damit, über die Unterschiede bei der Trennung von Monobehaviour und Nicht-Monobehaviour zu sprechen.

58:50.490 --> 58:51.120
Danke.

58:57.320 --> 58:59.600
Hallo und willkommen zu Unit Testing für Unity.

58:59.630 --> 59:02.630
Dies ist unser Workshop über die Physik der Charaktere.

59:02.660 --> 59:09.110
In früheren Workshops haben wir uns langsam von einem sehr einfachen Beispiel für einen Charakter, der sich mit einem Pfeil bewegt

59:09.110 --> 59:14.960
Tasten zu einem fortgeschrittenen Beispiel mit der Trennung von Monobehaviour und Nicht-Monobehaviour übergegangen.

59:14.960 --> 59:20.900
Und hier in diesem Beispiel werden wir darüber sprechen, was passiert, wenn wir von einem anderen Einheitssystem wie der Physik abhängig sind.

59:20.900 --> 59:26.720
Und auch wenn wir in diesem Beispiel Physik verwenden, wird unsere Bewegung unschärfer.

59:26.720 --> 59:30.890
Das heißt, ich klicke nicht links und es klickt sofort auf eine Position.

59:30.890 --> 59:32.930
Es bewegt sich langsam mit der Zeit.

59:32.930 --> 59:37.100
Wie könnten wir den Wert testen, der sich langsam über die Zeit verändert?

59:37.100 --> 59:40.220
Wir werden also ein paar dieser Dinge hier im Quellcode besprechen.

59:40.220 --> 59:45.290
Um einen Blick auf diese Demo zu werfen, öffnen wir unseren Unity-Editor und das Beispielprojekt.

59:45.290 --> 59:48.020
Die Szene hier wird die Charakterphysikszene sein.

59:48.020 --> 59:51.720
Und eines der Dinge, die wir uns ansehen werden, ist, wie man diese Fuzzy-Werte testet.

59:51.740 --> 59:58.640
Ich nenne es noch einmal, unscharfe Werte sind für mich Werte, die nicht unbedingt sofort sind, die sich ändern von

59:58.640 --> 1:00:05.960
A nach B, sie verändern sich langsam im Laufe der Zeit, wie zum Beispiel die Position eines Objekts oder eine Punktzahl, die allmählich

1:00:05.960 --> 1:00:06.890
aufwärts zählt.

1:00:06.920 --> 1:00:12.110
Dies sind alles Bereiche, in denen man etwas im Laufe der Zeit testen möchte, und wir haben einen einfachen Ansatz

1:00:12.110 --> 1:00:13.250
hier, um das zu tun.

1:00:13.250 --> 1:00:17.750
Es ist nicht die einzige Lösung, aber ich denke, dass sie uns hilft, auf dem Weg zu lernen.

1:00:17.750 --> 1:00:18.770
Schauen wir es uns also an.

1:00:18.770 --> 1:00:20.420
Hier sind wir also im Unity-Projekt.

1:00:20.420 --> 1:00:22.940
Wir haben das Beispiel der Charakterphysik geöffnet.

1:00:22.940 --> 1:00:24.500
Lassen wir die Szene ablaufen.

1:00:30.610 --> 1:00:33.520
Hier kann ich mich nun mit den Pfeiltasten bewegen.

1:00:37.390 --> 1:00:42.970
Und in früheren Beispielen hier im Workshop haben wir gesehen, dass er jeden Klick, den ich auf der linken Seite gemacht habe, übersprungen hat

1:00:42.970 --> 1:00:48.430
Pfeil geklickt habe, hat sich die Position augenblicklich verändert, aber hier ist die Bewegung sanfter.

1:00:49.060 --> 1:00:54.250
Ich kann immer noch alle Pfeiltasten benutzen, um zu bestimmen, wohin es gehen soll, aber die Idee ist

1:00:54.250 --> 1:00:58.030
dass es sich mit der Zeit langsam bewegt, ist wirklich eine neue Situation.

1:00:58.030 --> 1:01:03.790
Es gibt viele Möglichkeiten, wie man das in Unity machen kann, aber ich habe mich entschieden, das Physiksystem zu benutzen, nur um zu reden

1:01:03.790 --> 1:01:08.920
ein bisschen darüber zu reden, was passiert, wenn wir ein paar mehr Unity-Systeme involviert haben.

1:01:08.920 --> 1:01:10.960
Weißt du noch, womit wir uns gestreckt haben?

1:01:10.960 --> 1:01:18.130
Die Idee ist, dass man in einer idealen Welt seine Unit-Tests so gestaltet, dass sie die wenigsten Zeilen von

1:01:18.130 --> 1:01:21.760
Abhängigkeiten, die wenigsten Codezeilen auf einmal.

1:01:21.760 --> 1:01:25.600
Aber oft ist unser Produktionscode nicht so simpel.

1:01:25.600 --> 1:01:27.520
Wir sind von verschiedenen Dingen abhängig.

1:01:27.520 --> 1:01:33.370
Mit meinem Datenlader und den vorherigen Zeichenbeispielen hier haben wir also einige Möglichkeiten gesehen, wie man mit

1:01:33.370 --> 1:01:35.080
diese verschiedenen Abhängigkeiten.

1:01:35.200 --> 1:01:38.260
Dies ist ein weiteres Beispiel, das ein wenig komplexer ist als die anderen.

1:01:38.290 --> 1:01:40.240
Werfen wir einen Blick auf den Produktionscode hier.

1:01:40.240 --> 1:01:43.120
Hier sehen wir uns also das Beispiel der Charakterphysik an.

1:01:44.530 --> 1:01:45.790
Wir öffnen das?

1:01:47.210 --> 1:01:50.570
Und hier haben wir die Erstellung eines Charakterprimitivs.

1:01:51.320 --> 1:01:59.840
Hier erstellen wir zuerst das Spielobjekt mit dem Würfel als Primitiv, und dann fügen wir hinzu

1:01:59.840 --> 1:02:03.500
die Komponente des Charakter-Physik-Monobehaviours hinzu.

1:02:03.500 --> 1:02:07.070
Und dann haben wir eine separate Charakter-Physik-Klasse, die wir dort einbauen.

1:02:07.070 --> 1:02:12.740
Wir trennen uns also bereits von einer monolithischen Klasse von Monobehaviour in zwei.

1:02:12.740 --> 1:02:18.350
Das ist also ein guter Weg, um unseren Code zu vereinfachen und jeweils einen einzigen Zweck zu erfüllen.

1:02:18.350 --> 1:02:25.640
Im vorigen Beispiel haben wir gesehen, dass der größte Teil der Monobehaviour-Funktionalität, die wir brauchen, nur die Aktualisierung ist.

1:02:25.640 --> 1:02:27.680
Das ist das Einzige, um das wir uns wirklich kümmern mussten.

1:02:27.710 --> 1:02:33.110
Indem wir also alles, was nicht mit der Aktualisierung zu tun hat, in die zweite Klasse verlagert haben, haben wir jetzt etwas, das einfacher zu handhaben ist

1:02:33.110 --> 1:02:33.740
Test.

1:02:36.450 --> 1:02:39.570
In diesem einfachen Beispiel sind wir zu einer bestimmten Position gegangen.

1:02:39.600 --> 1:02:43.710
Führen wir nun die Tests aus und werfen wir einen Blick auf den Produktionscode.

1:02:43.740 --> 1:02:46.500
Schauen wir uns nun die Ausführung der ausgewählten Tests an.

1:02:48.580 --> 1:02:49.830
Es läuft alles dort.

1:02:49.850 --> 1:02:50.850
Alles läuft.

1:02:50.870 --> 1:02:52.640
Das ist nur der Test im Spielmodus.

1:02:52.640 --> 1:02:57.110
Aber wir haben auch Tests für den Bearbeitungsmodus, wenn Sie sich das noch einmal ansehen wollen, denn wir sind

1:02:57.110 --> 1:02:58.950
mit Monobehaviour Zeug zu tun haben.

1:02:58.970 --> 1:03:01.340
Es ist sinnvoller, einen Spielmodus zu verwenden.

1:03:01.340 --> 1:03:02.990
Das ist also der Ansatz, den ich hier verfolgt habe.

1:03:02.990 --> 1:03:06.470
Aber es liegt an Ihnen und Ihrem Projekt zu entscheiden, welche Systeme Sie testen wollen.

1:03:06.500 --> 1:03:08.230
Bearbeitungsmodus und welche Systeme Sie testen wollen.

1:03:08.240 --> 1:03:08.840
Spielmodus.

1:03:15.570 --> 1:03:21.000
Nachdem wir nun diese Tests gesehen haben, schauen wir uns kurz den Quellcode der Klasse an.

1:03:21.000 --> 1:03:22.660
Und dann schauen wir uns einige der Tests oben an.

1:03:22.710 --> 1:03:22.860
Also gut.

1:03:22.860 --> 1:03:24.780
Hier sind wir also in der Charakterphysik.

1:03:24.810 --> 1:03:28.870
Wir werden sehen, dass es dem Charakter, den wir zuletzt gesehen haben, ziemlich ähnlich ist.

1:03:28.890 --> 1:03:32.850
Wieder haben wir die Klasse Monobehaviour und die Klasse ohne Monobehaviour getrennt.

1:03:32.850 --> 1:03:36.630
Hier ist also die Nicht-Monobehaviour-Klasse, die den größten Teil der Arbeit macht.

1:03:36.660 --> 1:03:42.840
Beachten Sie, dass im Konstruktor eine Referenz auf das Monobehaviour gespeichert wird und dann

1:03:42.840 --> 1:03:47.670
übergibt dem Monobehaviour auch einen Verweis auf diese Klasse hier.

1:03:47.670 --> 1:03:51.900
Das ist, damit es den Move by jedes Mal aufrufen kann, wenn es eine Aktualisierung durchführt.

1:03:51.930 --> 1:03:53.970
Nun gibt es verschiedene Möglichkeiten, das zu organisieren.

1:03:53.970 --> 1:03:57.810
Man könnte sogar die hart kodierte Abhängigkeit, die wir hier haben, aufheben.

1:03:57.810 --> 1:04:01.350
Aber der Einfachheit halber ist dies in diesem Beispiel sehr passend.

1:04:01.740 --> 1:04:02.790
Wir gehen den Code abwärts.

1:04:02.790 --> 1:04:05.820
Wieder ist es wie bei den Fortgeschrittenen in den meisten Teilen.

1:04:05.850 --> 1:04:08.670
Ich möchte darauf hinweisen, wo Physik verwendet wird.

1:04:08.670 --> 1:04:16.920
Also hier in der Bewegung, statt nur durch die Position hardcoded über eine Instanz Taneous update,

1:04:16.950 --> 1:04:20.340
werden wir hier die Bewegungsposition verwenden.

1:04:20.340 --> 1:04:25.890
Und dann unter Kraft hinzufügen, das ist eine neue Methode, die ich gemacht habe, die sich basierend auf der Physik bewegen wird

1:04:25.890 --> 1:04:26.580
Kräfte.

1:04:26.580 --> 1:04:30.630
Stellen Sie sich also vor, dass dies ein Block ist und wir auf einer Seite einen Druck ausüben.

1:04:30.630 --> 1:04:36.390
Und dann, basierend auf Reibung, Masse und Schwerkraft, gibt es eine Art von Folge, die dazu neigt

1:04:36.390 --> 1:04:39.240
zu einer unschärferen Reaktion, wenn man die zusätzliche Kraft benutzt.

1:04:39.240 --> 1:04:45.570
Und wir bewegen uns mit add force hier oben in der gleichen Klassendatei und sehen das Physik-Monobehaviour

1:04:45.600 --> 1:04:46.590
deklariert ist.

1:04:46.590 --> 1:04:52.560
Es ist ziemlich vertraut, da das gleiche fortgeschrittene Zeichen, das wir im letzten Workshop gesehen haben, ziemlich ähnlich aussieht,

1:04:52.560 --> 1:04:55.350
aber wir haben hier einen starren Körper, den wir speichern.

1:04:55.350 --> 1:05:02.010
Und wenn diese Klasse aufwacht, fügen wir den Starrkörper hinzu und setzen dann einige physikalische Parameter

1:05:02.010 --> 1:05:02.670
Werte.

1:05:02.670 --> 1:05:09.450
Wenn wir also darüber nachdenken, einfach eine Art Zusammenfassung zu machen, anstatt ein Monobehaviour zu haben, das die ganze Physik macht

1:05:09.450 --> 1:05:14.220
und Bewegung zusammen, haben wir das Monobehaviour von dem Nicht-Monobehaviour getrennt.

1:05:14.250 --> 1:05:20.520
Innerhalb des Monobehaviour führen wir dann die Aktualisierungsschleife durch und kümmern uns auch um einige physikalische Dinge.

1:05:20.610 --> 1:05:26.550
Mit dem anderen, dem Nicht-Monobehaviour, können wir uns nach Belieben bewegen und Zeicheneingaben entgegennehmen,

1:05:26.580 --> 1:05:28.470
also Tastatureingaben und solche Sachen.

1:05:28.470 --> 1:05:32.940
Das ist eine ziemlich gute Trennung und bringt uns auf den Weg, was wir brauchen.

1:05:34.100 --> 1:05:37.820
Ich überlege laut, ob es noch etwas gibt, das ich hier erwähnen möchte.

1:05:38.330 --> 1:05:40.430
Ähm, ja.

1:05:40.430 --> 1:05:42.620
Ich habe also über die Idee hier gestichelt.

1:05:42.620 --> 1:05:50.720
Wenn man die hart kodierte Abhängigkeit zwischen den einzelnen Klassen reduzieren wollte und

1:05:50.720 --> 1:05:56.270
mehr von der Flexibilität, die wir im Beispiel von My Data loader gesehen haben, zu erhalten, könnten Sie sicherlich deklarieren

1:05:56.270 --> 1:05:58.670
Schnittstellen deklarieren und auf diese Weise ansprechen.

1:05:58.970 --> 1:06:00.680
Aber das brauchen wir hier nicht zu tun.

1:06:00.680 --> 1:06:03.370
Wir gehen einfach zurück und führen das Beispiel noch einmal aus.

1:06:03.380 --> 1:06:07.700
Hier in Unity laufen wir also, und wir haben die Pfeiltasten, die sich bewegen.

1:06:07.730 --> 1:06:13.130
In den letzten Videos haben wir Beispiele für die Reduzierung der Komplexität gesehen.

1:06:13.130 --> 1:06:17.870
Durch die Verringerung verschiedener Abhängigkeiten haben wir eine gewisse Flexibilität, um unseren Code aufzuteilen.

1:06:17.870 --> 1:06:23.480
Also für dieses Beispiel hier mit Input und Physik und Monobehaviours oder so, habe ich

1:06:23.480 --> 1:06:24.620
denke, wir sind hier fertig.

1:06:24.650 --> 1:06:25.340
Danke!

1:06:31.470 --> 1:06:31.730
Hallo.

1:06:31.740 --> 1:06:37.470
Das deckt eine Menge der verschiedenen Themen ab, die ich bisher in dem Workshop haben wollte, aber es gibt noch

1:06:37.470 --> 1:06:39.990
Es gibt noch viel Platz für weitere Themen in der Zukunft.

1:06:39.990 --> 1:06:42.390
Wir haben in den bisher behandelten Workshops gesehen.

1:06:42.390 --> 1:06:49.350
Das einfachste Beispiel, um den Test Runner zu lernen und zu sehen, wie wir Tests im Spielmodus und im Bearbeitungsmodus machen können,

1:06:49.380 --> 1:06:54.870
Ein wenig über die Unterschiede zwischen Abspielmodus und Bearbeitungsmodus lernen und warum man testen sollte

1:06:54.870 --> 1:06:57.350
in dem einen oder dem anderen, oder in beiden.

1:06:57.360 --> 1:07:03.510
Dann haben wir auch einige der Optionen gesehen, die wir haben, wenn wir asynchrone Funktionalität haben, oder wenn wir

1:07:03.510 --> 1:07:05.460
von anderen Systemen abhängig sind.

1:07:05.460 --> 1:07:09.990
Was können wir tun, um diese Abhängigkeit für den Test zu verringern?

1:07:10.020 --> 1:07:15.180
Auf dem Weg dorthin lernen wir verschiedene Dinge über Dependency Injection und die Trennung von

1:07:15.180 --> 1:07:16.650
der Belange unseres Codes.

1:07:16.680 --> 1:07:22.710
Diese Prinzipien sind im Produktionscode sowieso nützlich, und wir fangen an, einige der Möglichkeiten zu sehen, die

1:07:22.710 --> 1:07:29.850
dass wir, wenn wir unseren Code so vorbereiten, dass er besser testbar ist, auch Code erzeugen, der gut entworfen ist

1:07:29.850 --> 1:07:31.080
für die Produktion.

1:07:31.080 --> 1:07:37.710
Die Injektion von Abhängigkeiten ermöglicht also Flexibilität, die man zur Laufzeit nutzen kann, und reduziert die Komplexität

1:07:37.710 --> 1:07:44.370
Ihrer Systeme, indem Sie bei Bedarf flexible Varianten verschiedener Abhängigkeiten einbinden.

1:07:44.400 --> 1:07:51.960
Wir haben auch gesehen, dass durch die Aufteilung eines monolithischen großen Monobehaviour in nur das, was wir brauchen, aus dem Monobehaviour

1:07:51.960 --> 1:07:58.620
und den anderen Code in eine leichtere Klasse ohne Monobehaviour verschieben, erhalten wir wieder etwas Flexibilität

1:07:58.620 --> 1:08:03.570
die in der Produktion nützlich ist und uns auch hier in der Testwelt hilft.

1:08:03.570 --> 1:08:10.170
Ich denke, einige der Herausforderungen, die wir sehen, sind, was passiert, wenn man mehrere Abhängigkeiten hat

1:08:10.200 --> 1:08:14.670
oder viele Systeme, die von einer bestimmten Methode aufgerufen werden.

1:08:15.060 --> 1:08:20.700
Das könnte ein Zeichen dafür sein, dass die Methode aufgebläht ist und zu viel macht, oder es könnte ein Zeichen dafür sein, dass sie

1:08:20.700 --> 1:08:23.130
eine schlanke und angemessen konzipierte Methode ist.

1:08:23.130 --> 1:08:28.800
Aber wir müssen einige zusätzliche Gedanken und Überlegungen anstellen, wenn wir diese Funktionalität testen wollen.

1:08:28.800 --> 1:08:31.050
Ich hoffe, das war hilfreich für Sie.

1:08:31.050 --> 1:08:38.130
Ich freue mich darauf, noch mehr Themen in dieser Serie zu behandeln, und sie werden wieder in über

1:08:38.130 --> 1:08:38.610
Zeit.

1:08:38.610 --> 1:08:39.750
Also nochmals vielen Dank.
