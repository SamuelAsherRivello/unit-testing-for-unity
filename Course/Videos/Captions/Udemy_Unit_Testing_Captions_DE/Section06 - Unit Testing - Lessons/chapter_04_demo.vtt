WEBVTT

00:00.170 --> 00:03.020
Werfen wir einen Blick auf eine Demo, die dies in Aktion zeigt.

00:03.020 --> 00:07.400
Wir öffnen den Unity-Editor und öffnen unser Kursbeispielprojekt.

00:07.400 --> 00:09.740
Dasselbe Projekt für den gesamten Kurs.

00:09.740 --> 00:12.260
Und darin werden wir uns einige Szenen ansehen.

00:12.260 --> 00:15.620
Ich habe einen reinen Funktionsbereich innerhalb der Lektionen.

00:15.620 --> 00:23.990
Und wir werden ein bisschen mehr über Dummy Sub, Fake Mock und Spy sehen und wir werden in der Lage sein, diese zu vergleichen.

00:23.990 --> 00:25.970
Hier sind wir also in Unity.

00:25.970 --> 00:30.920
Dies ist das Beispielprojekt des Kurses, das auch in einigen anderen Lektionen und Videos verwendet wird.

00:30.920 --> 00:36.590
Und was ich hier zeigen möchte, nur als kurze Einführung, ist, dass in meinem Layout auf der rechten Seite,

00:36.590 --> 00:42.850
Ich habe den Inspektor, der das Readme-Asset innerhalb des Projekts anzeigt, also können Sie hier darauf klicken und

00:42.860 --> 00:44.840
siehe Readme und es wird hier angezeigt.

00:44.840 --> 00:49.580
Oder Sie können zu Window Unit Testing gehen und Readme öffnen.

00:49.790 --> 00:57.620
Die Readme gibt Ihnen einige Informationen über das Beispielprojekt und enthält auch eine Aktualisierung

00:57.620 --> 01:01.970
Liste, welche Lektionen und welche Workshops interessant sind.

01:01.970 --> 01:07.280
Sie werden feststellen, dass sich die Liste von Video zu Video ein wenig verändert, wenn der Kurs erweitert wird

01:07.280 --> 01:08.570
und es mehr Inhalt gibt.

01:08.600 --> 01:11.960
Was wir uns hier ansehen werden, ist die Lektion über reine Funktionen.

01:11.960 --> 01:15.200
Wenn ich darauf klicke, wird genau hier ausgewählt, wo wir sein wollen.

01:16.060 --> 01:18.430
Dann öffne ich das Beispiel mit den reinen Funktionen.

01:18.460 --> 01:24.310
Wie bei den anderen Szenen, die wir uns angeschaut haben, gibt es auch hier eine Produktionsszene, die Sie ausführen können.

01:24.310 --> 01:27.700
Das ist nicht der interessanteste Teil, aber lassen Sie uns damit anfangen.

01:27.940 --> 01:30.100
Wenn ich einfach auf Play klicke.

01:33.170 --> 01:35.060
In der Szene hier.

01:35.090 --> 01:37.970
Es wird uns ein wenig Konsolenausgabe geben.

01:37.970 --> 01:43.760
Das ist nur zur Verdeutlichung der Idee, dass es eine Szene gibt, es gibt

01:43.760 --> 01:45.020
Produktionscode.

01:45.020 --> 01:48.080
In unserem Fall macht es ziemlich kleine Sachen.

01:48.110 --> 01:50.990
Wir sind wirklich eingeladen, uns das Fenster des Testläufers oben anzusehen.

01:52.930 --> 01:57.370
Das Fenster des Testläufers hier ermöglicht es uns, eine beliebige Kategorie auszuwählen.

01:57.370 --> 01:59.800
In diesem Fall sehen wir uns die reinen Funktionen an.

01:59.800 --> 02:02.530
Und dann haben wir hier alle reinen Funktionen.

02:04.640 --> 02:07.280
Diese sind alle Tests und alle Tests sind erfolgreich.

02:07.280 --> 02:11.720
Wenn ich also den obersten Knoten hier auswähle und auf Run All klicke, werden alle Tests ausgeführt.

02:11.750 --> 02:18.590
Jetzt habe ich Tests für den Bearbeitungsmodus und den Wiedergabemodus für jede Lektion und jede Szene des Kurses hinzugefügt.

02:18.590 --> 02:23.480
Und in bestimmten Fällen denke ich, dass es für uns relevanter ist, das eine oder das andere zu betrachten.

02:23.480 --> 02:25.900
In diesem Fall ist der Bearbeitungsmodus wirklich wichtig.

02:25.910 --> 02:28.160
Warum ist der Bearbeitungsmodus so wichtig?

02:28.160 --> 02:33.830
Weil wir in diesem speziellen Fall keine Laufzeitfunktionen wie Monobehaviour und andere

02:33.830 --> 02:35.300
Dinge aus der Unity-Bibliothek.

02:35.300 --> 02:37.220
Der Editiermodus ist hier also relevant.

02:37.220 --> 02:42.890
Und außerdem werden wir uns die End Substitute Library anschauen und das wir editieren

02:42.890 --> 02:43.520
nur.

02:43.520 --> 02:46.310
Sie können das also nur in diesen Tests im Bearbeitungsmodus anwenden.

02:46.310 --> 02:48.560
Erweitern wir also den Test hier und sehen wir nach.

02:51.310 --> 02:59.710
Wir haben hier einen reinen Test, einen nicht reinen Test und einen nicht reinen, erweiterten Test, ähnlich der Theorie, dass

02:59.710 --> 03:01.330
die wir im Diavortrag gesehen haben.

03:01.330 --> 03:03.850
Wir hatten das ursprüngliche reine Beispiel.

03:03.850 --> 03:09.820
Dann haben wir uns überlegt, dass wir uns ein nicht reines Beispiel ansehen sollten, das irgendwie diese indirekten Eingaben hat

03:09.820 --> 03:11.020
oder indirekte Ausgänge.

03:11.020 --> 03:15.370
Und dann ist das Fortgeschrittene sozusagen die weiterentwickelte Lösung des Problems.

03:15.370 --> 03:21.910
Das nicht reine Produkt ist nicht 100% rein, auch wenn es hier massiert wurde.

03:21.910 --> 03:26.400
Es kann also hilfreich sein, sich den reinen Test anzusehen, um die Theorie zu untermauern.

03:26.410 --> 03:35.470
Warum ist ein reiner Test rein, dann sehen Sie sich mein System Nummer zwei als Ausgangspunkt für eine nicht refaktorisierte Art an

03:35.470 --> 03:37.210
eines problematischen Anwendungsfalls.

03:37.210 --> 03:43.810
Und dann sehen Sie sich den fortgeschrittenen Test hier an, der die fortgeschrittene Lösung als eine Art weiterentwickelte Lösung zeigt.

03:44.050 --> 03:46.720
Und das sind alles Optionen, die Sie für sich selbst haben würden.

03:46.720 --> 03:49.450
Sie können sicherlich reine Systeme in Ihrer Codebasis erstellen.

03:49.450 --> 03:53.260
Sie können Systeme erstellen, die nicht rein sind und ein wenig problematisch für das Testen sind.

03:53.260 --> 03:55.570
Und vielleicht ist das in bestimmten Situationen in Ordnung.

03:55.570 --> 04:02.410
Und dann, wenn man sich weiterentwickeln, überarbeiten und verbessern will, macht man den Test eher einsam als gesellig,

04:02.410 --> 04:05.730
kann man sich zum Beispiel den Fortgeschrittenen als Modell ansehen.

04:05.740 --> 04:08.290
Schauen wir uns also den Quellcode für jedes dieser Modelle an.

04:08.290 --> 04:12.100
Beginnen wir hier mit dem Test für das reine System.

04:12.100 --> 04:12.760
Ich lese ihn hier vor.

04:12.760 --> 04:15.400
Der Test, den wir in einen Wert umwandeln werden.

04:15.700 --> 04:18.040
Wir nehmen an, dass das Ergebnis 20 ist.

04:18.070 --> 04:22.030
Das erwarten wir, wenn die Eingabe zwei und zehn ist.

04:22.180 --> 04:24.670
Hier sind also unsere arrangierten Eingaben.

04:24.700 --> 04:26.740
Hier sind die Eingaben.

04:26.740 --> 04:28.410
Und hier ist der Ausgangswert.

04:28.420 --> 04:35.050
Wie wir im Theorieteil gesehen haben, ist der Grund dafür, dass dies eine reine Funktion ist, dass das Ergebnis

04:35.050 --> 04:39.520
nur von der übergebenen Eingabe abhängt und von nichts anderem.

04:39.520 --> 04:41.410
Und sie hat keine Nebeneffekte.

04:41.410 --> 04:45.550
Also keine indirekten Eingaben und keine indirekten Ausgaben.

04:45.550 --> 04:46.510
Das ist also rein.

04:46.540 --> 04:48.880
Schauen wir uns den Quellcode für das pure an.

04:50.180 --> 04:51.510
Und es ist ganz einfach.

04:51.530 --> 04:55.100
Ich glaube, es ist identisch mit dem, was wir auf den Folien gesehen haben, vielleicht mit ein paar kleinen Anpassungen.

04:55.130 --> 04:58.670
Wir übergeben den int und den Multiplikator und geben das zurück.

04:58.700 --> 05:02.070
Wir machen hier keine anderen Abhängigkeiten.

05:02.090 --> 05:03.890
Wir erstellen keine neuen Systeme.

05:03.890 --> 05:05.870
Wir adressieren keine anderen Systeme.

05:05.870 --> 05:08.090
Wir setzen keine anderen Werte.

05:08.090 --> 05:09.890
Wir multiplizieren nur und geben es zurück.

05:09.890 --> 05:14.020
Und wieder gilt die Rückgabe des Wertes nicht als indirekte Ausgabe.

05:14.030 --> 05:15.270
Das ist die direkte Ausgabe.

05:15.290 --> 05:17.330
Das ist also die reinste Ausgabe, die man bekommen kann.

05:17.360 --> 05:19.400
Das ist ein sehr schönes Beispiel und ein guter Startpunkt.

05:19.400 --> 05:21.380
Und wenn wir das Beispiel hier laufen lassen.

05:22.890 --> 05:25.530
Wir sehen, dass es gut funktioniert.

05:25.530 --> 05:26.160
Es ist grün.

05:26.160 --> 05:26.870
Häkchen gesetzt.

05:26.880 --> 05:28.400
Jetzt gehen wir zum nächsten Punkt über.

05:28.410 --> 05:30.750
Hier ist also ein nicht reiner Test.

05:31.020 --> 05:33.120
Hier sehen wir, dass wir den Wert umwandeln werden.

05:33.150 --> 05:37.140
Wir nehmen an, dass das Ergebnis 30 ist, wenn die eingegebene Zahl drei ist.

05:37.260 --> 05:43.350
Jetzt legen wir einen Wert von drei und einen Multiplikator von zehn fest.

05:43.380 --> 05:46.890
Diese beiden int-Werte wurden auch im vorherigen Test verwendet.

05:46.890 --> 05:51.630
Es werden etwas andere Werte verwendet, aber es geht um ähnliche Eingaben.

05:51.630 --> 05:56.490
Beachten Sie aber, dass eine Eingabe hier und eine Eingabe hier hineingeht.

05:56.490 --> 06:00.570
Bei diesem Test geht es also um die Umwandlung von Werten.

06:00.570 --> 06:05.610
Der umgewandelte Wert hängt also vom Wert der drei Eingaben ab.

06:05.610 --> 06:13.470
Und leider hängt es vom Standpunkt der Reinheit auch vom Multiplikatorwert ab, der ein gemeinsamer Wert ist

06:13.470 --> 06:15.780
Zustand, der hier oben eingegeben wurde.

06:15.840 --> 06:22.380
Sie können sich vorstellen, dass je nach den Produktionsanforderungen, die Sie haben, diese Art von Situation auftreten kann.

06:22.380 --> 06:25.620
Sie könnten im Konstruktor einen Zustand einstellen.

06:25.620 --> 06:28.350
Und dann in einer Methode einen Teil dieses Zustands verwenden.

06:28.350 --> 06:32.820
Wie wir hier sehen, kann man auch sieben verschiedene Methoden in einer Klasse haben.

06:32.820 --> 06:37.500
Und der Aufruf von Methode eins und Methode drei wird sich auf den Zustand auswirken.

06:37.500 --> 06:41.220
Wenn wir schließlich Methode sieben aufrufen, hängt es davon ab, ob Sie Methode drei aufgerufen haben?

06:41.250 --> 06:44.730
Haben Sie fünf aufgerufen, haben Sie einige öffentliche Eigenschaften gesetzt, usw.?

06:44.760 --> 06:46.080
Das ist ganz normal.

06:46.080 --> 06:51.330
In der objektorientierten Programmierung würde man erwarten, dass verschiedene Methodenaufrufe vielleicht einige

06:51.330 --> 06:52.260
gemeinsamen Zustand hinterlassen.

06:52.710 --> 06:59.490
Das ist alles in Ordnung, aber wir würden es als unrein betrachten und das Testen hat einige zusätzliche Gedanken und

06:59.490 --> 07:00.480
Implikationen.

07:00.480 --> 07:07.830
Auch hier besteht das Problem darin, dass wir einen indirekten Input haben.

07:08.280 --> 07:10.410
Werfen wir also einen Blick auf den Quellcode.

07:10.560 --> 07:16.860
Im Vergleich zur reinen Implementierung habe ich hier ein paar Dinge für den akademischen Prozess hinzugefügt.

07:17.160 --> 07:19.230
Wenn man eine Art von Problemen zu lösen hat.

07:19.230 --> 07:25.350
Das eine ist, dass wir einen Multiplikator speichern, und das andere ist, dass wir ein letztes Ergebnis hier unten speichern.

07:25.350 --> 07:27.570
Wir sehen, dass das letzte Ergebnis gesetzt wird.

07:27.570 --> 07:35.940
Dies ist ein Beispiel für eine indirekte Ausgabe, denn bevor wir den Wert umwandeln, hat das letzte Ergebnis nicht

07:35.940 --> 07:36.960
keinen Wert gesetzt.

07:36.960 --> 07:42.030
Aber nach dem Aufruf von Wert umwandeln hat das letzte Ergebnis einen Wert.

07:42.030 --> 07:47.910
Vielleicht ändert sich der Wert im Vergleich zu vorher, je nachdem, wie der Wert und der Multiplikator genau lauten.

07:47.940 --> 07:54.870
Dieses nicht reine Beispiel zeigt also sowohl indirekten Input als auch indirekten Output.

07:54.870 --> 07:56.220
Indirekte Eingabe.

07:56.220 --> 08:00.270
Denn ein Teil des Inputs kommt hierher und wird hier verwendet.

08:01.140 --> 08:05.940
Vom Standpunkt der Konvertierung der Werte aus gesehen, nur der hervorgehobene Code hier.

08:05.940 --> 08:10.170
Einiges, was sich auf die Eingabe auswirken wird, ist hier nicht blau hervorgehoben.

08:10.170 --> 08:12.030
Es wurde tatsächlich früher eingestellt.

08:12.180 --> 08:16.110
Man könnte das vom Standpunkt der Reinheit aus als problematisch bezeichnen.

08:16.110 --> 08:18.780
Und dann haben wir noch eine indirekte Ausgabe.

08:18.810 --> 08:25.240
Wir geben nicht nur einen Wert zurück, der perfekt und rein ist, wir setzen auch das letzte Ergebnis.

08:25.260 --> 08:31.500
Auch hier handelt es sich um eine indirekte Ausgabe, die unter dem Gesichtspunkt der Reinheit als unerwünscht anzusehen ist.

08:31.660 --> 08:36.810
Dies deutet nicht darauf hin, dass es sich um einen problematischen Quellcode handelt, der unserer Produktion nicht zuträglich wäre

08:36.810 --> 08:37.470
braucht.

08:37.470 --> 08:42.960
Sicherlich wird es in Ihrem Code einige Situationen geben, in denen Sie diese indirekten Eingaben haben und

08:42.990 --> 08:44.490
oder indirekte Ausgänge.

08:44.820 --> 08:51.270
Aber was ich hier sehe, ist etwas, das Auswirkungen auf unsere Unit-Tests haben könnte.

08:51.270 --> 08:56.970
Also zurück in Unit Let, lassen wir das einfach nochmal laufen, ich drücke auf Run und es läuft prima.

08:56.970 --> 09:02.190
Dann hier unten für unseren nicht reinen fortgeschrittenen Anwendungsfall habe ich diesen problematischen Anwendungsfall genommen.

09:02.190 --> 09:09.660
Ich habe aktualisiert und ein Beispielsystem erstellt, das einige dieser Probleme ein wenig gelöst hat, vielleicht nicht ganz

09:09.660 --> 09:10.920
100% rein.

09:10.920 --> 09:12.750
Und ich habe mir verschiedene Möglichkeiten angesehen.

09:12.750 --> 09:21.000
Ich habe also einen Test erstellt, um verschiedene Arten von Testdoppelungen zu simulieren bzw. ein Beispiel dafür zu geben, wie sie aussehen

09:21.000 --> 09:21.840
verwendet werden.

09:21.870 --> 09:26.670
Zuerst haben wir die Standardvariante, die ohne Testdoppelungen auskommt.

09:26.670 --> 09:29.730
Das ist sozusagen das Vorher-Bild.

09:29.760 --> 09:32.760
Dann verwenden wir hier einen Dummy.

09:32.790 --> 09:35.610
Dann verwenden wir hier einen Stummel.

09:36.690 --> 09:38.610
Wir verwenden hier einen Spion.

09:40.310 --> 09:41.870
Wir verwenden hier eine Attrappe.

09:43.050 --> 09:45.270
Und schließlich verwenden wir hier eine Fälschung.

09:45.360 --> 09:47.670
Ich stelle sie hier in einer Reihenfolge auf.

09:47.790 --> 09:51.930
Dasselbe wie bei der Theorie, die wir zuvor in der Tabelle der verschiedenen Testdoppel gesehen haben.

09:51.930 --> 09:56.280
Und die Reihenfolge ist nicht unbedingt von der besten zur schlechtesten oder so ähnlich.

09:56.280 --> 10:01.890
Es ist eher von dem am wenigsten leistungsfähigen Testdoppel, das am billigsten und einfachsten zu implementieren ist, bis zu dem

10:01.890 --> 10:06.920
leistungsstärksten Testdoppelgänger, der am zeitaufwändigsten zu erstellen sein könnte.

10:06.930 --> 10:13.230
Erledigt auch die meisten Aufgaben, und in manchen Fällen ist es besser, einen dieser Tests zu haben

10:13.230 --> 10:13.800
als eine andere.

10:13.830 --> 10:19.740
In Ihrer speziellen Situation sollten Sie nicht unbedingt immer die falsche oder immer die

10:19.740 --> 10:20.190
nachahmen.

10:20.220 --> 10:24.210
Dies sind verschiedene Werkzeuge, die du in deinem Werkzeuggürtel hast und die du benutzen kannst.

10:24.210 --> 10:26.880
Gehen wir sie also alle durch, beginnend mit dem Standard.

10:26.880 --> 10:28.860
Hier ist also das Standardbeispiel.

10:28.860 --> 10:31.590
In diesem Beispiel sind noch keine Testdoppel enthalten.

10:31.590 --> 10:37.350
Und das sollte Ihnen bekannt vorkommen, denn es ist im Grunde das, was wir für das ursprüngliche, nicht reine Beispiel gemacht haben.

10:37.500 --> 10:40.980
Und das heißt, wir konvertieren den Wert.

10:41.010 --> 10:44.340
Das Ergebnis wird 40 sein, wenn die Eingabe vier ist.

10:44.370 --> 10:47.100
Und hier stellen wir die Anordnung ein.

10:47.310 --> 10:49.950
Wir geben hier den Multiplikator ein.

10:51.050 --> 10:53.060
Dann geben wir hier den Konverter ein.

10:53.730 --> 10:56.880
Und unsere eine Zeile hier gibt den Wert ein.

10:56.880 --> 11:02.280
Aber denk daran, dass wir auch den Wert mit dem Multiplikator multiplizieren.

11:02.280 --> 11:04.980
Wir haben hier also ein paar alte Informationen.

11:05.610 --> 11:07.280
Um ein wenig damit zu spielen.

11:07.290 --> 11:14.820
Wenn wir uns daran erinnern, dass die ursprüngliche reine Implementierung alle Eingaben hier direkt übernommen hat und das würde

11:14.820 --> 11:16.220
reiner sein.

11:16.230 --> 11:21.600
Aber zum Zweck des Lernens habe ich etwas geschaffen, das weniger rein ist, damit wir diskutieren können

11:21.600 --> 11:23.640
damit es gut funktioniert.

11:23.640 --> 11:26.640
Und das ist sozusagen bevor wir irgendwelche Test-Doubles untersuchen.

11:26.640 --> 11:32.490
Bei jedem dieser Tests werden wir sehen, wie wir mehr und mehr leistungsstarke Funktionen hinzufügen.

11:32.490 --> 11:33.290
Test-Doubles.

11:33.300 --> 11:39.390
Ich gebe zu, dass es bei diesem Beispiel am meisten Sinn macht, wenn man die späteren

11:39.390 --> 11:43.620
Beispiele, der spätere Test verdoppelt Mock und Fake und Spionage und so.

11:43.650 --> 11:48.930
Die Dummy-Beispiele sind nicht so toll, aber ich wollte wirklich den gleichen Produktionscode für alle verwenden

11:48.930 --> 11:49.140
sie.

11:49.140 --> 11:55.380
Entschuldigen Sie also, dass der Dummy und vielleicht auch der danach nicht das beste Beispiel sind, aber ich hoffe, dass

11:55.380 --> 11:56.810
sie hilfreich für euch sind, um sie zu lernen.

11:56.820 --> 11:57.930
Hier ist also der Dummy.

11:57.960 --> 12:02.220
Was wir hier tun, ist, dass wir sagen, dass es standardmäßig einen negativen Wert liefert.

12:02.220 --> 12:08.670
Wenn ich also einen Nullwert zwei eingebe, ist das hier der Dummy-Wert für den Konverter.

12:09.330 --> 12:12.480
Jetzt kannst du dir vorstellen, dass die Klasse vielleicht kaputt geht.

12:12.480 --> 12:13.920
Wenn wir einen Nullwert übergeben.

12:13.920 --> 12:17.880
Das bedeutet, dass die Klasse in ihrer Abhängigkeit härter ist.

12:17.880 --> 12:21.180
Darauf würden Sie wahrscheinlich denken: Hey, das tut es nicht.

12:21.180 --> 12:24.090
Jede Klasse, die Sie übergeben, muss ungleich Null sein.

12:24.270 --> 12:27.090
Ja, wahrscheinlich in vielen Fällen, ja.

12:27.090 --> 12:30.210
Aber hier habe ich Ihnen ein Beispiel gegeben und Sie können sich den Quellcode ansehen.

12:30.240 --> 12:32.730
Die Klasse wird diesen Nullwert aufnehmen.

12:32.730 --> 12:33.180
Gut.

12:33.180 --> 12:40.260
Und es gibt viele Situationen, in denen die Eingabe von null oder des dümmstmöglichen Objekts tatsächlich

12:40.260 --> 12:41.010
funktioniert.

12:41.040 --> 12:49.650
Wenn der Konverter in der zu prüfenden Methode verwendet würde, würde dies wahrscheinlich eine Null-Referenz auslösen.

12:49.650 --> 12:52.110
Aber hier wird absichtlich die.

12:52.140 --> 12:57.240
Was wir testen, ist, dass das letzte Ergebnis einen bestimmten Wert hat.

12:57.240 --> 13:01.920
Wenn ich hier die Konvertierung testen würde, wüsste ich, dass sie den Konverter verwendet.

13:01.920 --> 13:06.270
Man muss sich also überlegen, kann ich mir den Weg durch alles erschwindeln?

13:06.270 --> 13:07.380
Wahrscheinlich nicht.

13:07.380 --> 13:13.080
Wahrscheinlich wird das, was Sie übergeben, irgendwo für einen gemeinsamen Zustand verwendet.

13:13.080 --> 13:15.930
Aber wir sehen tatsächlich, dass dies mit einem grünen Häkchen passiert.

13:15.930 --> 13:16.920
Wir wissen also, dass es funktioniert.

13:16.920 --> 13:22.230
Und was wir tun, ist der wichtige Teil für den Dummy, dass manchmal, wenn man testet

13:22.230 --> 13:27.150
etwas testet, kann es auf einer billigen und einfachen Abhängigkeit basieren, die übergeben wird.

13:27.750 --> 13:28.770
Also ist das gut.

13:29.900 --> 13:34.310
Eine weitere Sache, die wir ohne einen Blick in den Quellcode zu werfen, sagen könnten

13:34.310 --> 13:42.230
wahrscheinlich annehmen, dass, wenn es gut funktioniert, es wahrscheinlich nicht davon abhängt, was wir in

13:42.230 --> 13:42.900
als Null.

13:42.920 --> 13:50.960
Es ist also ein kleiner Hinweis darauf, dass die Erstellung dieser Klasse zwar die Übergabe von etwas erfordert, das aber

13:50.960 --> 13:51.500
etwas.

13:51.500 --> 13:54.530
Da wir es null geben, wird es hier wahrscheinlich nicht verwendet.

13:54.560 --> 13:56.240
Sonst würde es mit einer Null-Referenz fehlschlagen.

13:56.480 --> 13:58.070
Werfen wir einen Blick auf den Quellcode.

13:58.070 --> 14:01.940
Hier ist ein Beispiel für den Quellcode, der für alle anderen Tests verwendet wird, die wir uns ansehen werden

14:01.940 --> 14:02.640
hier ansehen.

14:02.660 --> 14:05.270
Ich gebe den Konverter ein und speichere ihn.

14:05.540 --> 14:08.750
Ich setze auch das letzte Ergebnis auf ein negatives Ergebnis.

14:08.780 --> 14:14.180
Negative Eins wird oft als Wert vom Typ Dies wurde noch nicht festgelegt verwendet.

14:14.180 --> 14:15.560
Deshalb habe ich ihn hier gewählt.

14:15.560 --> 14:16.850
Aber es könnte auch Null sein.

14:16.850 --> 14:18.620
Es kann jeder beliebige Wert sein.

14:18.620 --> 14:25.970
Und ich nehme einfach an, wenn das Objekt hier erstellt wird, setze ich das als eine Art von nicht gesetztem Wert.

14:26.150 --> 14:30.650
Wenn ich dann hier unten den Wert umwandle, aktualisiere ich ihn richtig.

14:30.650 --> 14:33.860
Man kann sich das also als den initialisierten Wert vorstellen.

14:33.860 --> 14:35.810
Und dies wird hier aktualisiert.

14:35.900 --> 14:40.190
Alles, was ich im Test mache, ist die Übergabe von Null für den I-Konverter.

14:40.190 --> 14:42.860
Und dann prüfe ich nur das letzte Ergebnis.

14:42.860 --> 14:45.440
Ich mache noch keinen Test für diesen Teil hier.

14:46.580 --> 14:52.710
Und wir können das letzte Ergebnis sehen, weil es überhaupt nicht vom Konverter abhängt.

14:52.730 --> 14:57.590
Es sagt nicht, zum Beispiel, du weißt schon, zurück.

14:59.020 --> 15:00.940
Konverter Punkt etwas.

15:00.940 --> 15:06.340
Sie wissen, dass diese Zeile überhaupt nicht benutzt wird, dass sie wahrscheinlich gut funktionieren wird, auch wenn der Konverter

15:06.340 --> 15:07.030
Null ist.

15:07.210 --> 15:14.260
Wenn Sie also Ihre Klassen erforschen, können Sie dies einfach ausprobieren und sehen, was passiert, wenn ich eine Null

15:14.260 --> 15:15.830
für eine meiner Abhängigkeiten eingebe.

15:15.850 --> 15:17.590
Wird es einfach nicht kompiliert?

15:17.590 --> 15:24.100
Oder wirft es einen Null-Ref-Wert aus, oder hat es eine andere Art von Operationsfehler, der Ihnen zeigt, dass Sie

15:24.100 --> 15:26.920
eine stärkere Abhängigkeit von dem, was Sie übergeben, haben?

15:26.920 --> 15:31.870
Und das mag in Ordnung sein, aber es ist etwas, mit dem man spielen kann, wenn man die Unterschiede kennenlernt

15:31.870 --> 15:33.880
mit Ihren Abhängigkeiten.

15:35.500 --> 15:38.140
Hier im Test sehen wir, dass der Test bestanden wird.

15:38.140 --> 15:39.280
Und es funktioniert negativ.

15:39.280 --> 15:40.870
Das ist also ein Beispiel für einen Dummy.

15:40.870 --> 15:46.630
Und wie ich vorhin zugegeben habe, ist es nicht das beste Beispiel für die ersten beiden, auf die ich mich wirklich konzentrieren wollte

15:46.630 --> 15:47.770
auf die späteren Beispiele konzentrieren.

15:47.770 --> 15:48.850
Hier ist das zweite Beispiel.

15:48.850 --> 15:54.640
Wie wir im Kommentar sehen, ist das Test-Double, das wir hier machen, ein Stub, und ein Stub ist ein Test-Double

15:54.640 --> 15:57.490
der so konfiguriert ist, dass er einen bestimmten Wert zurückgibt.

15:57.490 --> 15:59.740
Dieses Beispiel hier ist also unvollkommen.

15:59.740 --> 16:06.130
Ich gebe zu, dass ich eine Null übergebe, was sich ein bisschen mehr wie ein Dummy anfühlt als vorher.

16:06.130 --> 16:13.600
Aber weil der übergebene Dummy-Wert tatsächlich den Test beeinflusst.

16:14.250 --> 16:16.350
Weil ich hier den Wert umwandeln aufrufe.

16:17.040 --> 16:18.930
Ich würde es als Stub betrachten.

16:19.230 --> 16:26.010
Sie könnten auch so etwas wie einen neuen, Sie wissen schon, temporären Konverter haben.

16:28.550 --> 16:31.040
Und vielleicht wird dann der Wert übergeben.

16:31.090 --> 16:35.360
Sie können sich vorstellen, dass es verschiedene Möglichkeiten gibt, etwas Temporäres einzufügen.

16:35.360 --> 16:41.300
Aber für mich, in diesem speziellen Beispiel, ist die Übergabe einer Null in der Tat Teil des Aufrufs zum Testen

16:41.300 --> 16:42.110
Struktur.

16:42.900 --> 16:43.800
Bedeutet, dass es ein Sub ist.

16:44.190 --> 16:46.280
Dies wird also einen Fehler auslösen.

16:46.290 --> 16:47.490
Warum wird nun ein Fehler ausgegeben?

16:47.520 --> 16:49.320
Schauen wir uns noch einmal den Quellcode an.

16:49.770 --> 16:54.990
Wenn ich nämlich null für converter eingebe und converter als null speichere.

16:55.020 --> 17:01.830
Dann wird es hier unten, wenn ich etwas mit null aufrufe, ausflippen und eine null ref oder irgendetwas anderes werfen

17:01.830 --> 17:03.150
andere Art von Ausnahme.

17:03.360 --> 17:07.140
Und hier überprüfe ich, um sicherzustellen, dass sie tatsächlich ausgelöst wird.

17:07.410 --> 17:11.270
Ich mag dieses spezielle Beispiel nicht, aber ich hoffe, es ist hilfreich zum Lernen.

17:11.280 --> 17:13.500
Als Nächstes wollen wir uns das SPI-Konzept ansehen.

17:13.500 --> 17:15.900
Die Definition hier ist also ein SPI-Test.

17:15.900 --> 17:20.120
Double ist ein Testdouble, das bestätigt, dass eine Methode aufgerufen wurde.

17:20.130 --> 17:23.670
Wir sind nicht daran interessiert, was von der Methode zurückgegeben wird.

17:23.670 --> 17:25.640
Wir wollen nur wissen, dass sie aufgerufen wurde.

17:25.650 --> 17:32.430
Wir gehen also von weniger Informationen aus, die im Dummy-Beispiel und im Sub-Beispiel weniger mächtig sind.

17:32.430 --> 17:35.390
Hier ist eine etwas stärkere Art von mittlerer Stärke.

17:35.400 --> 17:37.280
Wir wissen, dass etwas aufgerufen wurde.

17:37.290 --> 17:39.020
Und so funktioniert es.

17:39.030 --> 17:43.700
Wir benutzen die n substitute Bibliothek und erstellen eine Substitution für die Schnittstelle.

17:43.710 --> 17:48.660
Erinnern Sie sich, als ich die Beispiele durchging und darüber sprach, wie man aktualisiert und refaktorisiert

17:48.690 --> 17:51.360
Ihren Produktionscode zu aktualisieren und zu refaktorisieren, um ihn besser testen zu können?

17:51.360 --> 17:55.560
Eines der Dinge, die ich getan habe, war die Verwendung einer Schnittstelle bei der Umstrukturierung.

17:55.680 --> 18:03.870
Schnittstellen sind in Ihrem Code im Allgemeinen sehr nützlich, um Ihnen eine flexible, weniger hart kodierte Kopplung zu ermöglichen.

18:03.990 --> 18:09.030
Es ist also gut für die Produktion, aber auch speziell für diese Bibliothek hier, die das Mocking durchführt.

18:09.760 --> 18:11.590
Und den Spion für uns erstellt.

18:11.620 --> 18:22.210
Es wird on the fly in dieser einen Zeile eine neue Implementierung für den Konverter auf der Basis des AI-Konverters erstellt.

18:22.210 --> 18:24.640
Wir müssen also nicht unsere eigene Dummy-Klasse erstellen.

18:24.640 --> 18:26.680
Wir müssen nicht unsere eigene Beispielklasse erstellen.

18:26.710 --> 18:28.120
Das hier tut es für uns.

18:28.120 --> 18:29.440
Und wir geben das ein.

18:29.530 --> 18:32.500
Dann geben wir null ein.

18:32.530 --> 18:36.460
Vorher konnten wir den Wert nicht umwandeln, aber hier können wir ihn aufrufen.

18:36.580 --> 18:39.610
Es interessiert uns nicht, was hier zurückgegeben wird.

18:39.610 --> 18:42.610
Manchmal kann es sein, dass du die Bedürfnisse deines Tests bist und wir werden sehen.

18:42.610 --> 18:45.970
Im nächsten Beispiel geht es darum, was der Rückgabewert ist.

18:45.970 --> 18:49.360
Aber hier wollen wir nur wissen, ob etwas aufgerufen wurde.

18:49.360 --> 18:57.070
Wir machen also einen Einheitstest, der eine gewisse Struktur innerhalb des zu testenden Systems voraussetzt.

18:57.070 --> 18:58.240
Also rufen wir das auf.

18:58.240 --> 18:59.890
Und dann ist hier die Behauptung.

19:00.070 --> 19:04.030
Und beachten Sie, dass die Sprache hier Teil der End Substitute Library ist.

19:04.060 --> 19:06.250
Wir sagen, dass der Konverter.

19:06.980 --> 19:09.590
Wir werden einen Anruf erhalten haben.

19:10.010 --> 19:15.110
Nicht den Wert eins, sondern einen Aufruf an den Konvertierungswert.

19:15.740 --> 19:17.100
Das macht Sinn.

19:17.120 --> 19:19.220
Wenn ich das hier machen würde.

19:20.980 --> 19:24.760
Ich könnte annehmen, dass es zweimal aufgerufen wurde.

19:25.680 --> 19:27.420
Oder innen.

19:27.420 --> 19:33.480
Vielleicht habe ich einen Wert umgewandelt und ich würde einen annehmen.

19:35.860 --> 19:43.060
Und dann weiß ich vielleicht, weil ich dieses System verfasst habe, dass es tatsächlich etwas namens intern aufruft.

19:45.940 --> 19:48.490
Oder Vorbereitung.

19:49.120 --> 19:50.500
System.

19:51.070 --> 19:57.430
Ich könnte all die verschiedenen Untermethoden angeben, von denen ich weiß, dass sie wahrscheinlich passieren, wenn ich system convert value aufrufe.

19:57.640 --> 20:02.020
Dies ist ein ziemlich schlankes System, also ist die einzige Annahme, die ich kenne, diese hier.

20:02.020 --> 20:04.270
Und sehen wir mal, warum wir das annehmen können.

20:04.270 --> 20:06.460
Nun, wenn wir uns den Quellcode ansehen.

20:07.350 --> 20:10.230
Immer wenn ich system convert value aufrufe.

20:10.230 --> 20:16.620
Hier können wir also sehen, dass convert value tatsächlich convert dot convert value aufruft.

20:16.620 --> 20:18.060
Und er ruft ihn genau auf.

20:18.060 --> 20:25.440
Noch einmal: Wenn ich mehr als einen Aufruf gehabt hätte, hätte ich behaupten müssen, dass convert value aufgerufen wurde

20:25.440 --> 20:27.780
jedes Mal, wenn ich das System teste, zweimal aufgerufen wurde.

20:27.780 --> 20:29.310
Aber wir testen nur einmal.

20:29.340 --> 20:34.800
Jetzt können Sie sich vorstellen, dass Sie hier viele, viele, viele weitere Codezeilen haben, die mehrere verschiedene

20:35.190 --> 20:37.080
Bereiche ihrer Abhängigkeiten aufrufen.

20:37.080 --> 20:42.510
Und Sie können hier im Test zurückgehen und sie alle testen, indem Sie hier mehr hinzufügen.

20:42.750 --> 20:49.800
Als ich das erste Mal vom SPI erfuhr, dachte ich, dass dieser Test zu schwach sei.

20:49.830 --> 20:55.890
Würde ich nicht wissen wollen, dass er nicht nur aufgerufen wurde, sondern dass etwas Bestimmtes zurückgegeben wurde von

20:55.890 --> 20:56.610
dem Aufruf.

20:57.370 --> 21:00.350
Und das kann man im nächsten Beispiel machen, aber das ist ein guter Weg.

21:00.370 --> 21:04.480
Auch hier gehen wir von den am wenigsten starken Symbolen zu den stärksten Testsymbolen.

21:04.510 --> 21:04.780
Okay.

21:04.810 --> 21:07.780
Wie ich gerade angedeutet habe, ist das nächste Symbol Spott.

21:07.780 --> 21:12.620
Und beim Mocking geht es nicht nur darum, ob eine Methode aufgerufen wurde, sondern auch darum, was sie zurückgibt.

21:12.640 --> 21:15.390
Dies ist also das Beispiel, das wir in der Theorie gesehen haben.

21:15.400 --> 21:22.810
In diesem Beispiel habe ich die n substitute Bibliothek benutzt, um einen Ersatztest zu erstellen

21:22.810 --> 21:25.450
doppelt für I-Konverter, genau wie beim letzten Mal.

21:25.450 --> 21:30.600
Aber hier füge ich spontan einige Details der Implementierung hinzu.

21:30.610 --> 21:37.870
Ich sage, dass der Konverter "dot convert value" in der Lage sein sollte, einen beliebigen int-Wert aufzunehmen und Folgendes zurückzugeben

21:37.870 --> 21:43.300
den Wert mal den Multiplikator im Theorieteil der Folien haben wir genau dieses Beispiel gesehen.

21:43.300 --> 21:47.800
Und hier unten weiß ich es, weil Wert mal Multiplikator.

21:47.800 --> 21:52.570
Wenn der Wert drei und der Multiplikator zehn ist, ergibt das 30.

21:52.690 --> 21:57.730
Sie können also sehen, dass dies hier der eigentliche Test ist.

21:57.730 --> 22:04.600
Aber ich gehe von der Annahme aus, die hier getestet wird, dass, wenn ich den Systemkonvertierungswert aufrufe, das was

22:04.600 --> 22:09.160
dass es das Gleiche zurückgibt wie convert dot convert value.

22:10.100 --> 22:14.810
Es gibt hier eine Menge Wörter und eine Menge verwirrender, wiederverwendeter Terminologie.

22:14.810 --> 22:17.690
Es ist also wichtig, sich mit dem Beispiel hier zu beschäftigen.

22:17.690 --> 22:21.560
Aber schauen wir mal, ob ich hier tatsächlich ein Plus gehabt hätte.

22:21.590 --> 22:29.900
Unser Test würde scheitern, weil mein Test davon ausgeht, dass der vom System umgerechnete Wert genau der gleiche ist wie der

22:29.900 --> 22:31.760
Konverter-Konvertierungswert.

22:31.760 --> 22:37.640
Aber wenn ich hier etwas hätte, würde dies als eine Art indirekte Eingabe betrachtet werden.

22:37.640 --> 22:40.160
Wir bestätigen also, dass es keinen indirekten Input gibt.

22:40.160 --> 22:42.200
Und der Test ist wieder erfolgreich.

22:42.200 --> 22:43.790
Das ist also die Attrappe.

22:43.790 --> 22:48.680
Und ein Mock ist ein Testdouble, das so konfiguriert ist, dass es bestimmte Werte zurückgibt.

22:48.710 --> 22:55.040
Jetzt können Sie sich die Ersatzdokumentation ansehen, die ich in den Link-Teil des Kurses aufgenommen habe.

22:55.040 --> 22:57.380
Sie könnten hier andere Dinge tun.

22:57.380 --> 23:02.750
Vielleicht möchten Sie etwas sagen wie: Ich werde es einfach nachmachen, wenn Sie den Wert von zehn eingeben,

23:02.780 --> 23:04.220
dies zurückgeben würde.

23:04.220 --> 23:12.770
Aber wenn du das Wort 15 eingibst, könnte es auch tausendmal oder so etwas sein.

23:12.800 --> 23:20.330
Es kann verschiedene Umstände geben, unter denen die übergebenen Argumente die Ausgabe verändern.

23:21.590 --> 23:27.890
Aber diese Sprache hier Argumente jeder int ist spezifisch für die End-Ersatz-Bibliothek.

23:27.890 --> 23:33.320
Und es sagt, okay, egal, was wir in den Konvertierungswert übergeben, hier wird der Wert sein, der kommt

23:33.320 --> 23:33.680
heraus.

23:33.680 --> 23:38.510
Und schließlich unser letzter, unser mächtigster Typ von Testdoppel ist der Fake.

23:38.510 --> 23:40.050
Wie funktioniert also der Fake?

23:40.070 --> 23:42.920
Nun, ich benutze hier keinen Ersatz.

23:42.920 --> 23:45.560
Tatsächlich verwende ich ihn in diesem Test überhaupt nicht.

23:45.590 --> 23:51.410
Was ich stattdessen mache, und um ehrlich zu sein, bevor ich viel über Doppeltests gelernt habe, war das wirklich ein

23:51.410 --> 23:52.400
übliches Werkzeug für mich.

23:52.400 --> 23:53.900
Ich wusste nicht, dass es Fake genannt wird.

23:53.930 --> 23:59.750
Vor Jahren, als ich mit dem Unit-Testing anfing, dachte ich nur, oh, ich kann die Produktion nicht benutzen.

23:59.750 --> 24:01.640
Klasse aus irgendeinem Grund nicht benutzen.

24:01.820 --> 24:08.960
Also erstelle ich stattdessen eine Menge temporärer Versionen bestimmter Abhängigkeiten, die nur zum Testen dienen.

24:08.960 --> 24:13.130
In der Welt der Test-Doubles nennt man das dann Fake-Klassen.

24:13.490 --> 24:15.130
Wie erstelle ich so etwas also?

24:15.140 --> 24:21.620
Nun, in einer anderen Klasse erstellen Sie Ihre eigene Implementierung des gefälschten Konverters oder wie ich es mache

24:21.620 --> 24:22.580
zu organisieren.

24:22.580 --> 24:26.210
Meine Kunst wird das direkt über dem Test selbst angehen.

24:26.210 --> 24:29.870
Ich erstelle die Scheinimplementierung von allem, was benötigt wird.

24:29.870 --> 24:34.790
Hier erstelle ich also eine brandneue Klasse, die nur für den Fall des Tests verwendet wird.

24:34.790 --> 24:40.910
Ich möchte sie nicht versehentlich in der Produktion verwenden, also gebe ich ihr einen Titel wie fake oder test oder sample

24:40.910 --> 24:43.220
oder Beispielkonverter, so etwas in der Art.

24:43.220 --> 24:49.430
Aber wenn man der Sprache hier folgt, ist der Fake-Konverter und ich implementiere gerade genug von seiner Funktionalität für

24:49.430 --> 24:50.180
den Test.

24:50.210 --> 24:57.080
Nun sehe ich, dass einige Entwickler von Unit-Tests diesen falschen Konverter erstellen und ihn in vielen Tests in der

24:57.080 --> 24:58.070
derselben Klasse verwenden.

24:58.100 --> 24:59.420
Damit gibt es kein Problem.

24:59.420 --> 25:03.740
Man muss nicht unbedingt für jeden einzelnen Test eine eigene erstellen.

25:03.740 --> 25:08.780
Aber das Schöne daran ist, dass ich weiß, dass ich gerade genug implementieren muss, damit mein Test erfolgreich ist.

25:08.780 --> 25:11.870
Das gibt mir ein sehr einfaches Ziel, das ich anstreben kann.

25:12.680 --> 25:20.750
Ich spiele also damit, dass ich weiß, dass das letzte Ergebnis der Wert mal zehn sein wird,

25:20.750 --> 25:23.960
Ich erfinde meine eigene Implementierung nur, um Spaß zu haben.

25:23.960 --> 25:28.550
Wenn ich also einen Wert von vier eingebe, würde ich erwarten, dass das Ergebnis 40 ist.

25:28.880 --> 25:37.640
Wenn ich damit herumspielen möchte und hier 15 sage, dann könnte ich das Ergebnis auf 45 aktualisieren, weil 15 mal,

25:37.640 --> 25:42.430
Oh, tut mir leid, ich könnte es auf 60 aktualisieren, denn 15 mal vier wäre 60.

25:42.470 --> 25:44.450
Aber kehren wir zu unserem ursprünglichen Beispiel zurück.

25:46.040 --> 25:46.640
Da haben wir's.

25:46.790 --> 25:53.900
Bemerkenswert ist hier, dass unsere Produktionsklasse nicht zwangsläufig die folgenden Werte annimmt, wenn ich den gefälschten Konverter eingebe

25:53.900 --> 25:59.980
den gefälschten Konverter im Gegensatz zu einer Attrappe, die von der Ersatzbibliothek erstellt wurde, oder einem Dummy kennen.

25:59.990 --> 26:03.740
Der Produktionscode weiß es nicht und braucht es auch nicht zu wissen.

26:03.770 --> 26:06.500
Er braucht nur einen I-Konverter.

26:06.500 --> 26:13.370
Und das gibt uns die Flexibilität, Klassen zu implementieren und die Substitutionsbibliothek zu verwenden, um

26:13.370 --> 26:14.840
unsere Testanforderungen zu erfüllen.

26:14.840 --> 26:19.930
Wenn wir in unserem Produktionscode keine Schnittstelle verwenden würden, wären wir stark eingeschränkt.

26:19.940 --> 26:22.850
Lassen Sie mich also ein wenig darüber nachdenken, was wir hier behandelt haben.

26:22.880 --> 26:28.100
Wir haben ein reines System gesehen, das eine reine Funktion hat, und wir haben die Vorteile für die Testbarkeit gesehen.

26:28.190 --> 26:32.240
Dann haben wir gesehen, dass wir einfach mit der Idee einer unreinen Version dieses Systems gespielt haben.

26:32.240 --> 26:37.430
Und was sind einige der Probleme, die vielleicht mit indirektem Input und indirektem Output auftreten können?

26:37.430 --> 26:43.130
Und dann haben wir hier in der fortgeschrittenen Version mit all den verschiedenen Möglichkeiten gespielt, die wir umgehen können

26:43.130 --> 26:47.030
oder die Herausforderungen, die durch unreine Systeme entstehen, zu bewältigen.

26:47.030 --> 26:50.930
Wir haben uns über Dummy-Stub bis hin zu Fake bewegt.

26:50.930 --> 26:58.190
Zu sehen, dass wir leichte Implementierungen eines Tests verdoppeln können, um die gefälschte Version zu hören, ist eine komplette

26:58.220 --> 27:06.050
Fake-Klasse, die wir für den Test verwenden, braucht nur die Schönheit hier durch die Verwendung der Schnittstelle ist, dass unsere Produktion

27:06.050 --> 27:13.940
Klasse nicht wissen muss, ob sie im Testmodus ist, oder welche Version eines Testdoubles übergeben wird

27:13.970 --> 27:20.210
der Produktionscode funktioniert einfach elegant und entkoppelt von der Komplexität, welcher Typ von I-Konverter

27:20.210 --> 27:20.570
ist.

27:20.600 --> 27:23.210
Das gibt uns viele verschiedene Beispiele, mit denen wir spielen können.

27:23.210 --> 27:29.240
Alles in allem hoffe ich, dass es Ihnen Spaß gemacht hat, etwas über reine Funktionen und Testdoppel zu lernen und den Code zu sehen

27:29.240 --> 27:35.840
hier zu sehen, den wir in der Produktion haben, sowie in unseren Tests, die massieren und uns lernen lassen für alle

27:35.840 --> 27:43.670
verschiedene Wege, wie wir unsere Tests reiner machen können und unseren Produktionscode besser machen können

27:43.670 --> 27:49.910
wiederverwendbar zu machen, mit weniger Seiteneffekten und weniger Problemen mit gemeinsam genutzten Zuständen, die auftauchen können.

27:49.910 --> 27:50.840
Danke!
