WEBVTT

00:00.170 --> 00:03.020
Vamos dar uma olhada em uma demonstração disso em ação.

00:03.020 --> 00:07.400
Vamos abrir o unity editor e abrir o projeto de amostra do nosso curso.

00:07.400 --> 00:09.740
O mesmo projeto para todo o curso.

00:09.740 --> 00:12.260
E, dentro dele, examinaremos algumas das cenas.

00:12.260 --> 00:15.620
Tenho uma área de funções puras dentro das lições.

00:15.620 --> 00:23.990
E veremos um pouco mais sobre o submarino fictício, o falso simulado e o espião e poderemos compará-los.

00:23.990 --> 00:25.970
Então, aqui estamos dentro da unidade.

00:25.970 --> 00:30.920
Este é o projeto de amostra do curso utilizado em outras lições e vídeos.

00:30.920 --> 00:36.590
E o que eu quero mostrar aqui, apenas como uma breve reintrodução, é que no meu layout à direita,

00:36.590 --> 00:42.850
Eu tenho o inspetor mostrando o ativo readme dentro do projeto, então você pode clicar nele aqui e

00:42.860 --> 00:44.840
ver Readme e ele aparece aqui.

00:44.840 --> 00:49.580
Ou você pode ir para Window Unit Testing e abrir o readme.

00:49.790 --> 00:57.620
O Readme aqui lhe dá algumas informações de alto nível sobre o projeto de amostra e também inclui uma atualização constante

00:57.620 --> 01:01.970
lista aqui de quais lições e quais workshops são interessantes.

01:01.970 --> 01:07.280
Portanto, você pode notar que, de um vídeo para outro, isso fica um pouco diferente à medida que o curso se expande

01:07.280 --> 01:08.570
e há mais conteúdo.

01:08.600 --> 01:11.960
O que vamos ver aqui é a lição sobre funções puras.

01:11.960 --> 01:15.200
Então, se eu clicar nela, ela seleciona aqui mesmo onde queremos estar.

01:16.060 --> 01:18.430
Em seguida, abrirei o exemplo de funções puras.

01:18.460 --> 01:24.310
Agora, como nas outras cenas que examinamos, há uma cena de produção que você pode executar.

01:24.310 --> 01:27.700
Essa não é a parte mais interessante, mas vamos começar com ela aqui.

01:27.940 --> 01:30.100
Se eu clicar em reproduzir.

01:33.170 --> 01:35.060
Na cena aqui.

01:35.090 --> 01:37.970
Ele nos dará um pouco de saída do console.

01:37.970 --> 01:43.760
Isso serve apenas para reforçar a ideia de que, à medida que avançamos, há uma cena, há

01:43.760 --> 01:45.020
código de produção.

01:45.020 --> 01:48.080
No nosso caso, ele está fazendo coisas bem pequenas.

01:48.110 --> 01:50.990
Estamos realmente convidados a dar uma olhada na janela do executor de teste acima.

01:52.930 --> 01:57.370
A janela do executor de teste aqui permite que nos concentremos em qualquer categoria.

01:57.370 --> 01:59.800
Neste caso, estamos olhando para as funções puras.

01:59.800 --> 02:02.530
E então temos todas as funções puras aqui.

02:04.640 --> 02:07.280
Todas elas são testes e todos os testes estão sendo aprovados.

02:07.280 --> 02:11.720
Portanto, se eu selecionar o nó superior aqui e clicar em Run All, ele executará todos esses testes.

02:11.750 --> 02:18.590
Agora incluí testes de modo de edição e de modo de reprodução para cada lição, cada cena do curso.

02:18.590 --> 02:23.480
E, em certos casos, acho que é mais relevante analisarmos um ou outro.

02:23.480 --> 02:25.900
Nesse caso, o modo de edição é realmente importante.

02:25.910 --> 02:28.160
Então, por que o modo de edição é importante?

02:28.160 --> 02:33.830
Porque não estamos realmente usando, neste caso específico, nenhum recurso de tempo de execução como o Monobehaviour e outros

02:33.830 --> 02:35.300
coisas da biblioteca da unidade.

02:35.300 --> 02:37.220
Portanto, o modo de edição é relevante aqui.

02:37.220 --> 02:42.890
E, além disso, vamos olhar para a biblioteca substituta final e que estamos operando edit

02:42.890 --> 02:43.520
apenas.

02:43.520 --> 02:46.310
Portanto, você só pode aplicar isso nesses testes de modo de edição.

02:46.310 --> 02:48.560
Então, vamos expandir o teste aqui e ver.

02:51.310 --> 02:59.710
Temos aqui um teste puro, um teste não puro e depois um teste avançado não puro semelhante à teoria de que

02:59.710 --> 03:01.330
vimos na parte dos slides.

03:01.330 --> 03:03.850
Tivemos o exemplo original puro.

03:03.850 --> 03:09.820
Então, pensamos: vamos dar uma olhada em um exemplo não puro que, de alguma forma, tem esses inputs indiretos

03:09.820 --> 03:11.020
ou saídas indiretas.

03:11.020 --> 03:15.370
E o avançado é uma espécie de solução evoluída para o problema.

03:15.370 --> 03:21.910
Agora, o não puro, mesmo depois de ser massageado aqui, não é 100% puro.

03:21.910 --> 03:26.400
Portanto, pode ser útil que você analise o teste puro para reforçar a teoria.

03:26.410 --> 03:35.470
Por que um teste puro é puro, então veja o meu sistema número dois como um ponto de partida para um tipo não refatorado

03:35.470 --> 03:37.210
de caso de uso problemático.

03:37.210 --> 03:43.810
E depois veja o teste avançado aqui mostrando o avançado como uma espécie de solução evoluída para ele.

03:44.050 --> 03:46.720
E essas são todas as opções que você tem para si mesmo.

03:46.720 --> 03:49.450
Você pode criar sistemas puros em sua base de código.

03:49.450 --> 03:53.260
Você pode criar sistemas que não sejam puros e que sejam um pouco problemáticos para os testes.

03:53.260 --> 03:55.570
E talvez isso seja bom em determinadas situações.

03:55.570 --> 04:02.410
E então, se você quiser evoluir, refatorar e melhorar, tornando o teste mais solitário do que sociável,

04:02.410 --> 04:05.730
por exemplo, você pode olhar para o avançado como um modelo.

04:05.740 --> 04:08.290
Então, vamos dar uma olhada no código-fonte de cada um deles.

04:08.290 --> 04:12.100
Então, vamos começar examinando o teste para o sistema puro.

04:12.100 --> 04:12.760
Vou ler aqui.

04:12.760 --> 04:15.400
O teste que estaremos convertendo o valor.

04:15.700 --> 04:18.040
O resultado que assumimos é 20.

04:18.070 --> 04:22.030
Esperamos isso quando a entrada é dois e dez.

04:22.180 --> 04:24.670
Portanto, aqui estão nossas entradas organizadas.

04:24.700 --> 04:26.740
Aqui está a passagem deles.

04:26.740 --> 04:28.410
E aqui está o valor de saída.

04:28.420 --> 04:35.050
Portanto, mais uma vez, como vimos na parte teórica, a razão pela qual esta é uma função pura é que o resultado

04:35.050 --> 04:39.520
depende apenas da entrada passada e nada mais.

04:39.520 --> 04:41.410
E não tem efeitos colaterais.

04:41.410 --> 04:45.550
Portanto, não há entradas indiretas e nem saídas indiretas.

04:45.550 --> 04:46.510
Então, isso é puro.

04:46.540 --> 04:48.880
Vamos dar uma olhada no código-fonte do puro.

04:50.180 --> 04:51.510
E é bastante simples.

04:51.530 --> 04:55.100
Creio que é idêntico ao que vimos nos slides, talvez com alguns ajustes.

04:55.130 --> 04:58.670
Estamos passando o int e o multiplicador e retornamos isso.

04:58.700 --> 05:02.070
Não fazemos nenhuma outra dependência não relacionada aqui.

05:02.090 --> 05:03.890
Não estamos criando nenhum sistema novo.

05:03.890 --> 05:05.870
Não estamos abordando nenhum outro sistema.

05:05.870 --> 05:08.090
Não estamos definindo nenhum outro valor.

05:08.090 --> 05:09.890
Estamos apenas multiplicando e retornando o valor.

05:09.890 --> 05:14.020
E, novamente, o valor retornado não conta como uma saída indireta.

05:14.030 --> 05:15.270
Essa é a saída direta.

05:15.290 --> 05:17.330
Portanto, isso é o mais puro que se pode obter.

05:17.360 --> 05:19.400
É um exemplo muito bonito e um bom ponto de partida.

05:19.400 --> 05:21.380
E quando executamos esse exemplo aqui.

05:22.890 --> 05:25.530
Vemos que ele funciona muito bem.

05:25.530 --> 05:26.160
Está verde.

05:26.160 --> 05:26.870
Marca de verificação.

05:26.880 --> 05:28.400
Agora vamos passar para a próxima.

05:28.410 --> 05:30.750
Aqui está um teste não puro.

05:31.020 --> 05:33.120
Aqui vemos que vamos converter o valor.

05:33.150 --> 05:37.140
Assumimos que o resultado é 30 quando a entrada passada é três.

05:37.260 --> 05:43.350
Agora estamos estabelecendo um valor de três e um multiplicador de dez.

05:43.380 --> 05:46.890
Esses dois valores int também foram usados no teste anterior.

05:46.890 --> 05:51.630
Valores ligeiramente diferentes sendo usados, mas o ponto é que as entradas são semelhantes.

05:51.630 --> 05:56.490
Mas observe como uma entrada entra aqui e outra entra aqui.

05:56.490 --> 06:00.570
Portanto, esse teste aqui é sobre o valor de conversão.

06:00.570 --> 06:05.610
Portanto, o valor convertido depende do valor de três que está sendo passado.

06:05.610 --> 06:13.470
E, infelizmente, do ponto de vista da pureza, também depende do valor do multiplicador que é compartilhado

06:13.470 --> 06:15.780
compartilhado que foi passado aqui em cima.

06:15.840 --> 06:22.380
Agora você pode imaginar que, dependendo das necessidades de produção que você tem, você pode ter esse tipo de situação.

06:22.380 --> 06:25.620
Você pode ter definido algum estado no construtor.

06:25.620 --> 06:28.350
E depois, em um método, usar parte desse estado.

06:28.350 --> 06:32.820
Como vemos aqui, você também pode ter sete métodos diferentes para uma classe.

06:32.820 --> 06:37.500
E chamar o método um e o método três afetará o estado.

06:37.500 --> 06:41.220
Quando finalmente chamamos o método sete, isso depende de você ter chamado o três?

06:41.250 --> 06:44.730
Você chamou o cinco, definiu algumas propriedades públicas, etc.?

06:44.760 --> 06:46.080
É muito normal.

06:46.080 --> 06:51.330
Na programação orientada a objetos, você esperaria que diferentes chamadas de método talvez deixassem para trás alguns

06:51.330 --> 06:52.260
estado compartilhado.

06:52.710 --> 06:59.490
Tudo isso está bem, mas nós o consideramos impuro e testá-lo tem algumas considerações adicionais e

06:59.490 --> 07:00.480
implicações.

07:00.480 --> 07:07.830
Então, aqui novamente a parte problemática é que temos a entrada indireta.

07:08.280 --> 07:10.410
Então, vamos dar uma olhada no código-fonte aqui.

07:10.560 --> 07:16.860
Aqui, em comparação com a implementação pura, acrescentei algumas coisas apenas para o processo acadêmico.

07:17.160 --> 07:19.230
Se você tiver algum tipo de problema a ser resolvido.

07:19.230 --> 07:25.350
Uma delas é que estamos armazenando um multiplicador e a outra é que estamos armazenando um último resultado aqui embaixo.

07:25.350 --> 07:27.570
Vemos que o último resultado está sendo definido.

07:27.570 --> 07:35.940
Este é um exemplo de saída indireta porque antes de chamarmos o valor de conversão o último resultado não tem

07:35.940 --> 07:36.960
nenhum valor definido.

07:36.960 --> 07:42.030
Mas depois de chamar o convert value, o último resultado tem um conjunto de valores.

07:42.030 --> 07:47.910
Talvez mudando em relação ao que era anteriormente, dependendo exatamente de qual é o valor e o multiplicador.

07:47.940 --> 07:54.870
Portanto, esse exemplo não puro mostra tanto a entrada indireta quanto a saída indireta.

07:54.870 --> 07:56.220
Entrada indireta.

07:56.220 --> 08:00.270
Porque parte da entrada vem para cá e é usada aqui.

08:01.140 --> 08:05.940
Portanto, do ponto de vista da conversão de valores, apenas o código destacado aqui.

08:05.940 --> 08:10.170
Algumas das coisas que afetarão a entrada não estão destacadas em azul aqui.

08:10.170 --> 08:12.030
Na verdade, foi definido anteriormente.

08:12.180 --> 08:16.110
Isso pode ser considerado problemático do ponto de vista da pureza.

08:16.110 --> 08:18.780
E também temos a saída indireta.

08:18.810 --> 08:25.240
Não apenas estamos retornando um valor que é perfeito e puro, mas também estamos definindo o último resultado.

08:25.260 --> 08:31.500
Novamente, esse é um resultado indireto e seria considerado indesejável do ponto de vista da pureza.

08:31.660 --> 08:36.810
Não indica que se trata de uma parte problemática do código-fonte que não ajudaria a nossa produção

08:36.810 --> 08:37.470
necessidades.

08:37.470 --> 08:42.960
Certamente, você terá algumas situações no seu código em que há essas entradas indiretas e

08:42.990 --> 08:44.490
ou saídas indiretas.

08:44.820 --> 08:51.270
Mas o que vejo aqui é algo que pode ter algumas implicações em nossos testes unitários.

08:51.270 --> 08:56.970
Então, aqui na unidade, vamos rodar isso de novo, vou clicar em "run", roda bem e funciona muito bem.

08:56.970 --> 09:02.190
Então, aqui embaixo, para o nosso avançado não puro, eu peguei esse caso de uso problemático.

09:02.190 --> 09:09.660
Atualizei e criei um sistema de amostra que tem alguns desses problemas um pouco resolvidos, talvez não em

09:09.660 --> 09:10.920
100% puro.

09:10.920 --> 09:12.750
E analisei diferentes maneiras.

09:12.750 --> 09:21.000
Então, criei um teste para simular ou dar um exemplo de alguns tipos diferentes de testes duplos que são

09:21.000 --> 09:21.840
sendo usados.

09:21.870 --> 09:26.670
Primeiro, temos o padrão, que é sem nenhum teste duplo.

09:26.670 --> 09:29.730
Esse é o tipo de imagem anterior.

09:29.760 --> 09:32.760
Em seguida, usamos um boneco aqui.

09:32.790 --> 09:35.610
Em seguida, usamos um stub aqui.

09:36.690 --> 09:38.610
Usamos um spy aqui.

09:40.310 --> 09:41.870
Usamos um mock aqui.

09:43.050 --> 09:45.270
E, finalmente, usamos um falso aqui.

09:45.360 --> 09:47.670
Eu os coloco em uma ordem aqui.

09:47.790 --> 09:51.930
O mesmo da teoria que vimos anteriormente na tabela dos diferentes testes duplos.

09:51.930 --> 09:56.280
E a ordem não é necessariamente da melhor para a pior ou algo do gênero.

09:56.280 --> 10:01.890
É mais do teste duplo menos poderoso que é mais barato e mais fácil de implementar para o

10:01.890 --> 10:06.920
teste duplo mais poderoso que pode ser o mais demorado de criar.

10:06.930 --> 10:13.230
Também faz a maior parte das coisas, e você descobrirá que, em alguns casos, é melhor ter um deles

10:13.230 --> 10:13.800
do que outro.

10:13.830 --> 10:19.740
Dada a sua situação específica, você não precisa necessariamente usar sempre o falso ou sempre usar o

10:19.740 --> 10:20.190
mock.

10:20.220 --> 10:24.210
Essas são várias ferramentas diferentes que você tem no seu cinturão de ferramentas e pode usá-las.

10:24.210 --> 10:26.880
Então, vamos examinar todas elas, começando pela padrão.

10:26.880 --> 10:28.860
Aqui está o exemplo padrão.

10:28.860 --> 10:31.590
Este ainda não tem nenhuma dupla de teste adicionada.

10:31.590 --> 10:37.350
E deve parecer familiar porque é basicamente o que fizemos para o exemplo original não puro.

10:37.500 --> 10:40.980
E isso significa que dizemos converter o valor.

10:41.010 --> 10:44.340
O resultado será 40 quando a entrada for quatro.

10:44.370 --> 10:47.100
E aqui configuramos o arranjo.

10:47.310 --> 10:49.950
Passamos o multiplicador aqui.

10:51.050 --> 10:53.060
Em seguida, passamos o conversor aqui.

10:53.730 --> 10:56.880
E a nossa única linha aqui está passando o valor.

10:56.880 --> 11:02.280
Mas lembre-se de que também estamos multiplicando o valor pelo multiplicador.

11:02.280 --> 11:04.980
Portanto, temos um pouco de informação antiga aqui.

11:05.610 --> 11:07.280
Só para brincar um pouco com isso.

11:07.290 --> 11:14.820
Se nos lembrarmos da implementação original pura, todas as entradas aqui foram tomadas diretamente e isso seria

11:14.820 --> 11:16.220
seria mais pura.

11:16.230 --> 11:21.600
Mas, para fins de aprendizado, criei algo que é menos puro para que possamos discutir

11:21.600 --> 11:23.640
para que funcione bem.

11:23.640 --> 11:26.640
E isso é mais ou menos antes de explorarmos qualquer dupla de teste.

11:26.640 --> 11:32.490
Então, a cada um desses testes que vamos realizar, veremos como adicionar mais e mais poder

11:32.490 --> 11:33.290
testes duplos.

11:33.300 --> 11:39.390
Agora, admito que, ao criar esse exemplo, ele faz mais sentido para o último

11:39.390 --> 11:43.620
exemplos posteriores, o teste posterior duplica o mock e o fake e o spy e outras coisas.

11:43.650 --> 11:48.930
Os testes fictícios não são tão bons, mas eu queria realmente usar o mesmo código de produção em todos os exemplos.

11:48.930 --> 11:49.140
eles.

11:49.140 --> 11:55.380
Portanto, perdoe-me se o dummy e talvez o seguinte não são o melhor exemplo aqui, mas espero que

11:55.380 --> 11:56.810
eles sejam úteis para você aprender.

11:56.820 --> 11:57.930
Aqui está o boneco.

11:57.960 --> 12:02.220
O que estamos fazendo aqui é dizer que ele retorna um negativo por padrão.

12:02.220 --> 12:08.670
Portanto, se eu passar um valor nulo dois, esse é o valor fictício aqui para o conversor.

12:09.330 --> 12:12.480
Agora você pode imaginar que a classe pode quebrar.

12:12.480 --> 12:13.920
Se passarmos um valor nulo.

12:13.920 --> 12:17.880
Isso significa que a classe é mais rígida em sua dependência.

12:17.880 --> 12:21.180
Para isso, você provavelmente pensaria, ei, não tem.

12:21.180 --> 12:24.090
Toda classe que você passa precisa ser não nula.

12:24.270 --> 12:27.090
Sim, provavelmente em muitos casos, sim.

12:27.090 --> 12:30.210
Mas aqui eu lhe dei um exemplo e você pode ver o código-fonte.

12:30.240 --> 12:32.730
A classe receberá esse valor nulo.

12:32.730 --> 12:33.180
Muito bem.

12:33.180 --> 12:40.260
E há muitas situações em que colocar o valor nulo ou o objeto mais idiota possível de fato

12:40.260 --> 12:41.010
funcionar.

12:41.040 --> 12:49.650
Agora, provavelmente, se o conversor fosse usado no método em teste, isso lançaria uma referência nula.

12:49.650 --> 12:52.110
Mas propositalmente aqui o.

12:52.140 --> 12:57.240
O que estamos testando é que o último resultado terá um valor específico.

12:57.240 --> 13:01.920
Se eu estivesse testando o convert aqui, esse eu sei que usa o converter.

13:01.920 --> 13:06.270
Então, você tem de pensar: será que consigo fazer tudo de forma fictícia?

13:06.270 --> 13:07.380
Provavelmente não.

13:07.380 --> 13:13.080
Provavelmente o que você está passando será usado em algum lugar para algum estado compartilhado.

13:13.080 --> 13:15.930
Mas de fato vemos que isso passa com uma marca de verificação verde.

13:15.930 --> 13:16.920
Então sabemos que funciona.

13:16.920 --> 13:22.230
E o que estamos fazendo é a parte importante para o dummy é que, às vezes, quando se está testando

13:22.230 --> 13:27.150
algo, ele pode se basear em uma dependência barata e fácil de ser passada.

13:27.750 --> 13:28.770
Então, isso é bom.

13:29.900 --> 13:34.310
Outra coisa que poderíamos dizer, sem olhar o código fonte, é que

13:34.310 --> 13:42.230
provavelmente presumir que se isso funciona bem, então provavelmente não depende do que estamos passando

13:42.230 --> 13:42.900
como nulo.

13:42.920 --> 13:50.960
Portanto, é uma pequena dica de que, embora a criação dessa classe exija que algo seja passado, isso é

13:50.960 --> 13:51.500
alguma coisa.

13:51.500 --> 13:54.530
Como estamos lhe dando null, provavelmente não é usado aqui.

13:54.560 --> 13:56.240
Caso contrário, ele falharia com uma referência nula.

13:56.480 --> 13:58.070
Vamos dar uma olhada no código-fonte.

13:58.070 --> 14:01.940
Aqui está um exemplo do código-fonte que é usado para todos os outros testes que vamos examinar

14:01.940 --> 14:02.640
aqui.

14:02.660 --> 14:05.270
Eu passo esse conversor e o armazeno.

14:05.540 --> 14:08.750
Também defino o último resultado como sendo negativo.

14:08.780 --> 14:14.180
O valor negativo é frequentemente utilizado como um valor do tipo this hasn't been set yet.

14:14.180 --> 14:15.560
Foi por isso que o escolhi aqui.

14:15.560 --> 14:16.850
Mas pode ser zero.

14:16.850 --> 14:18.620
Pode ser qualquer valor que você queira.

14:18.620 --> 14:25.970
E presumo que, quando o objeto for criado aqui, eu o defina como o tipo de valor não definido.

14:26.150 --> 14:30.650
Então, aqui embaixo, se eu chamar o valor de conversão, eu o atualizo corretamente.

14:30.650 --> 14:33.860
Portanto, você pode pensar nisso como o valor inicializado.

14:33.860 --> 14:35.810
E isso está sendo atualizado aqui.

14:35.900 --> 14:40.190
Agora, tudo o que estou fazendo no teste é passar null para o conversor I.

14:40.190 --> 14:42.860
E então estou verificando apenas o último resultado.

14:42.860 --> 14:45.440
Ainda não estou fazendo um teste nesta parte aqui.

14:46.580 --> 14:52.710
E podemos ver esse último resultado porque ele não depende do conversor de forma alguma.

14:52.730 --> 14:57.590
Ele não diz, por exemplo, "return".

14:59.020 --> 15:00.940
Ponto do conversor alguma coisa.

15:00.940 --> 15:06.340
Você sabe que essa linha não a utiliza de forma alguma, que provavelmente funcionará bem, mesmo que o conversor

15:06.340 --> 15:07.030
seja nulo.

15:07.210 --> 15:14.260
Portanto, ao explorar suas classes, você pode experimentar e ver o que acontece se eu passar um valor nulo

15:14.260 --> 15:15.830
para uma de minhas dependências.

15:15.850 --> 15:17.590
Ele simplesmente não compila?

15:17.590 --> 15:24.100
Ou ele lança um valor de referência nulo, ou tem algum outro tipo de erro de operação que mostra que você

15:24.100 --> 15:26.920
tem uma dependência mais forte do que você está transmitindo?

15:26.920 --> 15:31.870
E isso pode ser bom, mas é algo para se brincar enquanto você aprende sobre as diferenças

15:31.870 --> 15:33.880
com suas dependências.

15:35.500 --> 15:38.140
Então, aqui no teste, vemos que ele passaria.

15:38.140 --> 15:39.280
E funciona com um negativo.

15:39.280 --> 15:40.870
Portanto, esse é um exemplo de um dummy.

15:40.870 --> 15:46.630
E, como admiti anteriormente, não é o melhor exemplo nesses dois primeiros que eu realmente queria focar

15:46.630 --> 15:47.770
nos exemplos posteriores.

15:47.770 --> 15:48.850
Aqui está o segundo.

15:48.850 --> 15:54.640
Como podemos ver no comentário, o teste duplo que estamos fazendo aqui é um stub, e um stub é um teste duplo

15:54.640 --> 15:57.490
que está configurado para retornar um valor específico.

15:57.490 --> 15:59.740
Portanto, este exemplo aqui é imperfeito.

15:59.740 --> 16:06.130
Admito que estou passando um null, que parece um pouco mais com um dummy do que antes.

16:06.130 --> 16:13.600
Mas como o valor fictício passado afeta de fato o teste.

16:14.250 --> 16:16.350
Porque estou chamando o valor de conversão aqui.

16:17.040 --> 16:18.930
Eu consideraria isso como um stub.

16:19.230 --> 16:26.010
Você também poderia ter algo como um novo, você sabe, conversor temporário.

16:28.550 --> 16:31.040
E talvez isso passe o valor.

16:31.090 --> 16:35.360
Você pode imaginar que há diferentes maneiras de inserir algo temporário ali.

16:35.360 --> 16:41.300
Mas para mim, neste exemplo específico, passar um nulo que é de fato parte da chamada para o teste

16:41.300 --> 16:42.110
estrutura.

16:42.900 --> 16:43.800
Significa que é um sub.

16:44.190 --> 16:46.280
Portanto, isso gerará um erro.

16:46.290 --> 16:47.490
Agora, por que está ocorrendo um erro?

16:47.520 --> 16:49.320
Vamos dar uma olhada no código-fonte novamente.

16:49.770 --> 16:54.990
Porque se eu passar null para o conversor e armazenar o conversor como null.

16:55.020 --> 17:01.830
Então, aqui embaixo, quando eu chamar algo em null, ele vai se assustar e lançar um ref nulo ou algo assim

17:01.830 --> 17:03.150
outro tipo de exceção.

17:03.360 --> 17:07.140
E aqui estou verificando para ter certeza de que ele realmente lança.

17:07.410 --> 17:11.270
Não gosto muito desse exemplo específico, mas espero que seja útil para o aprendizado.

17:11.280 --> 17:13.500
A seguir, vamos dar uma olhada no conceito de SPI.

17:13.500 --> 17:15.900
Portanto, a definição aqui é um teste SPI.

17:15.900 --> 17:20.120
Double é um teste duplo que confirma que um método foi chamado.

17:20.130 --> 17:23.670
Não estamos preocupados com o que é retornado pelo método.

17:23.670 --> 17:25.640
Só queremos saber que ele foi chamado.

17:25.650 --> 17:32.430
Portanto, estamos passando de menos informações para menos poder no exemplo fictício e no exemplo sub.

17:32.430 --> 17:35.390
Aqui está um pouco mais poderoso, do tipo força média.

17:35.400 --> 17:37.280
Sabemos que algo foi chamado.

17:37.290 --> 17:39.020
Então, é assim que funciona.

17:39.030 --> 17:43.700
Usamos a biblioteca n substitute e criamos uma substituição para a interface.

17:43.710 --> 17:48.660
Agora, lembre-se de quando eu estava analisando os exemplos aqui e falando sobre como atualizar e refatorar

17:48.690 --> 17:51.360
seu código de produção para torná-lo mais testável?

17:51.360 --> 17:55.560
Uma das coisas que fiz foi usar uma interface na refatoração.

17:55.680 --> 18:03.870
As interfaces são muito úteis em seu código em geral para proporcionar um acoplamento flexível e menos codificado.

18:03.990 --> 18:09.030
Portanto, é bom em produção, mas também especificamente para essa biblioteca que faz a simulação.

18:09.760 --> 18:11.590
E cria o espião para nós.

18:11.620 --> 18:22.210
Ele criará em tempo real, nesta única linha, uma nova implementação para o conversor baseado no conversor AI.

18:22.210 --> 18:24.640
Assim, não temos de criar a nossa própria classe fictícia.

18:24.640 --> 18:26.680
Não precisamos criar nossa própria classe de exemplo.

18:26.710 --> 18:28.120
Isso faz isso para nós aqui.

18:28.120 --> 18:29.440
E passamos isso para cá.

18:29.530 --> 18:32.500
Depois, quando passamos o null.

18:32.530 --> 18:36.460
Antes não podíamos chamar o valor convertido, mas aqui podemos chamá-lo.

18:36.580 --> 18:39.610
Não estamos preocupados com o que é retornado aqui.

18:39.610 --> 18:42.610
Às vezes, você pode precisar do seu teste e veremos.

18:42.610 --> 18:45.970
No próximo exemplo, você está preocupado com o valor de retorno.

18:45.970 --> 18:49.360
Mas aqui nós só queremos saber se algo foi chamado.

18:49.360 --> 18:57.070
Portanto, estamos fazendo um teste unitário que pressupõe alguma estrutura dentro do sistema em teste.

18:57.070 --> 18:58.240
Então, chamamos isso de.

18:58.240 --> 18:59.890
E aqui está a afirmação.

19:00.070 --> 19:04.030
E observe que a linguagem aqui faz parte da biblioteca substituta final.

19:04.060 --> 19:06.250
Estamos dizendo que o conversor.

19:06.980 --> 19:09.590
Teremos recebido uma chamada.

19:10.010 --> 19:15.110
Não o valor um, mas uma chamada para o valor de conversão.

19:15.740 --> 19:17.100
O que faz sentido.

19:17.120 --> 19:19.220
Se eu fizesse isso aqui.

19:20.980 --> 19:24.760
Eu poderia supor que ele foi chamado duas vezes.

19:25.680 --> 19:27.420
Ou dentro.

19:27.420 --> 19:33.480
Talvez eu tenha convertido o valor e assumiria um.

19:35.860 --> 19:43.060
E então talvez eu saiba, porque eu criei esse sistema, que ele de fato chama algo chamado internal.

19:45.940 --> 19:48.490
Ou prep.

19:49.120 --> 19:50.500
Sistema.

19:51.070 --> 19:57.430
Eu poderia colocar todos os diferentes submétodos que eu sei que provavelmente acontecem quando eu chamo system convert value.

19:57.640 --> 20:02.020
Este é um sistema bastante enxuto, portanto, a única suposição que sei que devo fazer é esta aqui.

20:02.020 --> 20:04.270
E vamos ver por que podemos supor isso.

20:04.270 --> 20:06.460
Bem, se olharmos para o código fonte.

20:07.350 --> 20:10.230
Sempre que chamo o valor de conversão do sistema.

20:10.230 --> 20:16.620
Portanto, aqui podemos ver que o convert value de fato chama o converter dot convert value.

20:16.620 --> 20:18.060
E ele o chama exatamente.

20:18.060 --> 20:25.440
Mais uma vez, se eu tivesse tido mais de uma chamada, teria de afirmar que o convert value foi chamado

20:25.440 --> 20:27.780
duas vezes cada vez que testo o sistema.

20:27.780 --> 20:29.310
Mas nós só testamos uma vez.

20:29.340 --> 20:34.800
Agora você pode imaginar que pode ter muitas, muitas, muitas outras linhas de código aqui, chamando vários

20:35.190 --> 20:37.080
áreas diferentes de suas dependências.

20:37.080 --> 20:42.510
E você pode voltar aqui no teste e testar todos eles adicionando mais aqui.

20:42.750 --> 20:49.800
Então, quando aprendi sobre o SPI, pensei, bem, será que esse teste não é muito fraco?

20:49.830 --> 20:55.890
Eu não gostaria de saber não apenas que ele foi chamado, mas que algo específico foi retornado do

20:55.890 --> 20:56.610
da chamada.

20:57.370 --> 21:00.350
E você pode fazer isso no próximo exemplo, mas esta é uma boa maneira.

21:00.370 --> 21:04.480
Novamente, estamos olhando dos símbolos menos poderosos para os símbolos de teste mais poderosos.

21:04.510 --> 21:04.780
Certo.

21:04.810 --> 21:07.780
Como acabei de sugerir, o próximo aqui é a zombaria.

21:07.780 --> 21:12.620
E a simulação não é apenas se um método foi chamado, mas o que ele retorna?

21:12.640 --> 21:15.390
Então, este é o exemplo que vimos na teoria aqui.

21:15.400 --> 21:22.810
O que eu fiz neste exemplo foi usar a biblioteca n substitute para criar um teste substituto em tempo real

21:22.810 --> 21:25.450
duplo para o conversor I, exatamente como da última vez.

21:25.450 --> 21:30.600
Mas aqui estou adicionando rapidamente alguns dos detalhes de implementação.

21:30.610 --> 21:37.870
Estou dizendo que o conversor dot convert value deve ser capaz de receber qualquer int e retornar

21:37.870 --> 21:43.300
o valor vezes o multiplicador na seção de teoria nos slides, vimos esse exemplo exato.

21:43.300 --> 21:47.800
E aqui embaixo eu sei porque o valor é multiplicado pelo multiplicador.

21:47.800 --> 21:52.570
Se o valor for três e o multiplicador for dez, será igual a 30.

21:52.690 --> 21:57.730
Assim, você pode ver que o que realmente está sendo testado é isto aqui.

21:57.730 --> 22:04.600
Mas estou fazendo uma suposição, que é o que está sendo testado, de que se eu chamar o valor de conversão do sistema, o que

22:04.600 --> 22:09.160
retorna é o mesmo que o converter dot convert value.

22:10.100 --> 22:14.810
Agora, há muitas palavras aqui e muito tipo de terminologia confusa reutilizada.

22:14.810 --> 22:17.690
Portanto, é importante se aprofundar e dar uma olhada no exemplo aqui.

22:17.690 --> 22:21.560
Mas vamos ver se eu realmente tivesse um mais um aqui.

22:21.590 --> 22:29.900
Nosso teste falharia porque meu teste pressupõe que o valor de conversão do sistema é exatamente o mesmo que o valor de

22:29.900 --> 22:31.760
valor de conversão do conversor.

22:31.760 --> 22:37.640
Mas se eu tivesse algo aqui, isso seria considerado uma espécie de entrada indireta.

22:37.640 --> 22:40.160
Portanto, estamos confirmando que não há entrada indireta.

22:40.160 --> 22:42.200
E o teste passa novamente.

22:42.200 --> 22:43.790
Portanto, essa é a simulação.

22:43.790 --> 22:48.680
E uma simulação é o teste duplo que está configurado para retornar valores específicos.

22:48.710 --> 22:55.040
Agora você pode dar uma olhada na documentação substituta que incluí na parte de links do curso.

22:55.040 --> 22:57.380
Você poderá fazer outras coisas aqui.

22:57.380 --> 23:02.750
Talvez você queira dizer algo como: "Vou apenas simular que se você passar o valor de dez",

23:02.780 --> 23:04.220
ele retornaria o seguinte.

23:04.220 --> 23:12.770
Mas se você inserir a palavra 15, ele pode fazer, você sabe, vezes mil ou qualquer outra coisa.

23:12.800 --> 23:20.330
Pode haver circunstâncias diferentes em que os argumentos passados mudem a forma como a saída ocorre.

23:21.590 --> 23:27.890
Mas esta linguagem aqui argumentos any int é específica para a biblioteca substituta final.

23:27.890 --> 23:33.320
E diz que, independentemente do que passarmos para o valor de conversão, este será o valor que virá

23:33.320 --> 23:33.680
que sairá.

23:33.680 --> 23:38.510
E, finalmente, o último e mais poderoso tipo de teste duplo é o falso.

23:38.510 --> 23:40.050
Então, como funciona o falso.

23:40.070 --> 23:42.920
Bem, não estou usando nenhum substituto aqui.

23:42.920 --> 23:45.560
Na verdade, não estou usando nenhum substituto neste teste.

23:45.590 --> 23:51.410
O que eu faço em vez disso, e para ser honesto, antes de aprender muito sobre testes duplos, isso era realmente um

23:51.410 --> 23:52.400
ferramenta comum para mim.

23:52.400 --> 23:53.900
Eu não sabia que se chamava fake.

23:53.930 --> 23:59.750
Há alguns anos, quando comecei minha jornada de testes unitários, eu pensava: "Ah, não posso usar a ferramenta de produção...".

23:59.750 --> 24:01.640
por algum motivo.

24:01.820 --> 24:08.960
Então, em vez disso, criarei várias versões temporárias apenas para teste de determinadas dependências.

24:08.960 --> 24:13.130
Portanto, no mundo das duplas de teste, essas são chamadas de classes falsas.

24:13.490 --> 24:15.130
Então, como faço para criar isso?

24:15.140 --> 24:21.620
Bem, em uma classe diferente, você cria a sua própria implementação do conversor falso ou da forma que eu escolhi

24:21.620 --> 24:22.580
para organizá-lo.

24:22.580 --> 24:26.210
Minha arte abordará isso logo acima do teste em si.

24:26.210 --> 24:29.870
Eu crio a implementação falsa do que for necessário.

24:29.870 --> 24:34.790
Então, aqui eu crio uma classe totalmente nova que é usada somente no caso do teste.

24:34.790 --> 24:40.910
Não quero usá-la acidentalmente na produção, portanto, dou a ela um título como falso, teste ou amostra

24:40.910 --> 24:43.220
ou conversor de exemplo, algo assim.

24:43.220 --> 24:49.430
Mas seguindo a linguagem aqui, conversor falso e eu implemento apenas o suficiente de sua funcionalidade para

24:49.430 --> 24:50.180
o teste.

24:50.210 --> 24:57.080
Agora vejo que alguns desenvolvedores de testes unitários criariam esse conversor falso e o usariam em muitos testes no

24:57.080 --> 24:58.070
mesma classe.

24:58.100 --> 24:59.420
Não há nenhum problema com isso.

24:59.420 --> 25:03.740
Você não precisa necessariamente criar um para cada teste individualmente.

25:03.740 --> 25:08.780
Mas o bom aqui é que eu sei que preciso implementar apenas o suficiente para que meu teste seja aprovado.

25:08.780 --> 25:11.870
Isso me dá um objetivo muito simples para perseguir.

25:12.680 --> 25:20.750
Então, aqui o que estou fazendo é saber que o último resultado será o valor vezes dez,

25:20.750 --> 25:23.960
que estou apenas fazendo minha própria implementação para me divertir.

25:23.960 --> 25:28.550
Portanto, se eu passar um valor de quatro, eu esperaria que o resultado fosse 40.

25:28.880 --> 25:37.640
Se eu quisesse brincar com isso e dizer 15 aqui, eu poderia atualizar para 45 porque 15 vezes,

25:37.640 --> 25:42.430
oh, desculpe, eu poderia atualizá-lo para 60 porque 15 vezes quatro seria 60.

25:42.470 --> 25:44.450
Mas vamos voltar ao nosso exemplo original.

25:46.040 --> 25:46.640
Aqui está.

25:46.790 --> 25:53.900
É de notar que quando passo o conversor falso, a nossa classe de produção não é necessariamente

25:53.900 --> 25:59.980
conhece o conversor falso versus uma simulação criada pela biblioteca substituta versus um dummy.

25:59.990 --> 26:03.740
O código de produção não sabe e não precisa saber.

26:03.770 --> 26:06.500
Ele só precisa de um conversor I.

26:06.500 --> 26:13.370
E isso nos dá a flexibilidade de poder implementar classes e usar a biblioteca de substituição para

26:13.370 --> 26:14.840
atender às nossas necessidades de teste.

26:14.840 --> 26:19.930
Se não usássemos uma interface em nosso código de produção, estaríamos severamente limitados.

26:19.940 --> 26:22.850
Então, deixe-me refletir um pouco sobre o que abordamos aqui.

26:22.880 --> 26:28.100
Vimos um sistema puro que tem uma função pura e vimos os benefícios para a testabilidade.

26:28.190 --> 26:32.240
Em seguida, vimos que brincamos com a ideia de uma versão impura desse sistema.

26:32.240 --> 26:37.430
E quais são alguns dos problemas que podem surgir com a entrada indireta e a saída indireta?

26:37.430 --> 26:43.130
E aqui, na versão avançada, brincamos com todas as formas diferentes de contornar o problema

26:43.130 --> 26:47.030
ou massagear os desafios introduzidos pelo fato de termos sistemas impuros.

26:47.030 --> 26:50.930
Passamos do stub fictício até o falso.

26:50.930 --> 26:58.190
Ver que podemos ter implementações leves de um teste que se duplicam para ouvir a versão falsa é uma completa

26:58.220 --> 27:06.050
a classe falsa que estamos usando para teste só precisa da beleza de usar a interface para que a nossa produção

27:06.050 --> 27:13.940
não precisa saber se está no modo de teste, ou qual versão de um teste duplo está sendo passada

27:13.970 --> 27:20.210
o código de produção simplesmente funciona elegantemente desacoplado da complexidade de qual tipo de conversor I

27:20.210 --> 27:20.570
é.

27:20.600 --> 27:23.210
Nos dá muitos exemplos diferentes para brincar.

27:23.210 --> 27:29.240
De modo geral, espero que você tenha gostado de aprender sobre funções puras e testes duplos e de ver o código

27:29.240 --> 27:35.840
aqui que temos em produção, bem como em nossos testes que massageiam e nos permitem aprender para todos os

27:35.840 --> 27:43.670
maneiras diferentes de ajudar a tornar nossos testes mais puros e ajudar a tornar nosso código de produção mais

27:43.670 --> 27:49.910
reutilizável com menos efeitos colaterais e menos problemas de estado compartilhado que podem surgir.

27:49.910 --> 27:50.840
Obrigado.
