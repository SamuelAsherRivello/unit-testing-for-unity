WEBVTT

00:00.590 --> 00:02.660
Olá e bem-vindo ao Unit Testing for unity.

00:02.690 --> 00:03.860
Os workshops.

00:03.860 --> 00:09.590
Nesta seção de workshops, abordaremos vários pequenos exemplos diferentes que nos mostram alguns

00:09.590 --> 00:11.030
características dos testes unitários.

00:11.030 --> 00:12.800
Vamos dar uma olhada no conteúdo aqui.

00:12.800 --> 00:16.730
Primeiro, darei a visão geral que estou apresentando agora nesta seção de introdução.

00:16.730 --> 00:19.070
Em seguida, passaremos por cada workshop.

00:19.070 --> 00:24.320
Normalmente, cada workshop refere-se a uma cena em nosso projeto de amostra.

00:24.320 --> 00:28.370
Portanto, se você baixar esse projeto de amostra, poderá acompanhar cada uma das cenas.

00:28.370 --> 00:35.270
Vamos abordar o meu sistema de matemática, que é um exemplo muito básico, apenas para nos familiarizarmos com o que é o teste de unidade

00:35.270 --> 00:36.500
é dentro da unidade.

00:36.500 --> 00:42.230
Em seguida, passaremos ao meu exemplo de carregador de dados e mostrarei uma versão básica e depois

00:42.230 --> 00:48.740
uma versão mais avançada utilizando alguns recursos adicionais que são opcionais, mas incrivelmente poderosos em seu interior

00:48.740 --> 00:50.390
unity para testes unitários.

00:50.420 --> 00:54.920
Em seguida, veremos um exemplo em que eu queria fazer algo com gráficos renderizados.

00:54.920 --> 01:00.530
Portanto, tenho um cubo que pode ser operado com as teclas de seta ou com um gamepad, e vamos chamá-lo de nosso

01:00.530 --> 01:01.340
personagem.

01:01.400 --> 01:06.950
Vamos passar por alguns exemplos, analisando casos de uso cada vez mais complexos para testes,

01:06.950 --> 01:13.520
eventualmente fazendo um movimento baseado em física, recebendo entrada e movendo nosso personagem com corpo rígido,

01:13.520 --> 01:17.990
e analisando como e por que gostaríamos de fazer testes unitários em torno disso.

01:18.020 --> 01:25.340
De modo geral, quanto mais recursos da unidade você usa e quanto mais animações em tempo de execução você faz, mais

01:25.340 --> 01:27.440
mais desafios para o processo de teste.

01:27.440 --> 01:28.880
Então, falaremos um pouco sobre isso.

01:28.880 --> 01:31.670
Há sempre uma oportunidade para eu acrescentar mais conteúdo aqui.

01:31.670 --> 01:34.160
Portanto, também vamos abordar alguns tópicos avançados.

01:34.160 --> 01:38.990
E este workshop vai nos permitir aprofundar alguns subtópicos específicos.

01:38.990 --> 01:43.580
Todo o código-fonte está disponível no código-fonte baixado do próprio projeto.

01:43.580 --> 01:44.720
Portanto, você pode pegá-lo.

01:44.720 --> 01:48.950
E o formato aqui será um compartilhamento de tela improvisado.

01:48.980 --> 01:53.750
Vou fazer tomadas mais longas do que o normal e apenas pensar em voz alta quando houver algumas coisas diferentes

01:53.750 --> 01:58.520
que eu queira falar e compartilhar com você sobre os poderes e os desafios dos testes unitários.

01:58.820 --> 02:03.320
Vou revisar alguns códigos existentes e, aqui e ali, criarei novos códigos ao longo do caminho.

02:03.320 --> 02:09.590
Uma ótima maneira de analisar e usar essas informações é fazer o download do projeto de exemplo e acompanhá-lo

02:09.590 --> 02:10.400
aqui e ali.

02:10.400 --> 02:16.190
Eu o encorajarei a acrescentar um novo método de produção a ser testado ou novos métodos de teste para cobrir o que você

02:16.190 --> 02:17.540
tem no código de produção.

02:17.540 --> 02:21.200
Você pode desenvolver as amostras existentes que eu tenho aqui.

02:21.200 --> 02:23.720
Ou você pode criar suas próprias cenas de amostra.

02:23.720 --> 02:27.230
E, para recapitular, vamos ler aqui os benefícios dos testes unitários.

02:27.230 --> 02:33.560
Alguns deles incluem aumentar a confiança no código, bem como permitir refatorações mais ousadas em seu código

02:33.560 --> 02:39.560
com mais consciência antes e depois da refatoração do status do seu projeto.

02:39.560 --> 02:44.990
E, no geral, isso vai economizar tempo porque vimos que, embora possa parecer que estamos sempre

02:45.020 --> 02:50.210
adicionando novos recursos na maior parte do nosso esforço de trabalho, aprendemos com a pesquisa que o desenvolvimento de software

02:50.210 --> 02:55.220
é principalmente sobre a manutenção de um código existente, e é aí que os testes unitários estão indo

02:55.220 --> 02:55.640
brilhar.

02:55.640 --> 02:58.700
Portanto, isso nos poupará tempo ao longo da vida do projeto.

02:58.730 --> 03:04.130
Os resultados que esperamos deste curso e do uso de testes unitários é ter mais confiança e

03:04.130 --> 03:05.990
robustez em nossa base de código.

03:06.020 --> 03:12.680
Teremos mais classes e métodos de propósito único, o que é um ótimo princípio de design para focar

03:12.680 --> 03:14.930
e certamente nos ajuda em nossa capacidade de teste.

03:14.930 --> 03:17.450
E vamos incentivar soluções mais simples.

03:17.450 --> 03:19.550
E falaremos sobre isso em alguns desses exemplos.

03:19.550 --> 03:21.650
Para recapitular o exemplo mais simples aqui.

03:21.650 --> 03:24.380
Este também é o primeiro dos workshops em que vamos nos aprofundar.

03:24.410 --> 03:30.290
Se tivermos uma classe de sistema de matemática mental e ela tiver dois métodos para somar e subtrair.

03:30.320 --> 03:35.090
Agora você pode imaginar que, depois de ver essa base de código funcionando, você pode adicionar seu próprio método para multiplicar

03:35.090 --> 03:38.300
ou dividir, e então adicionar alguns testes unitários em cima disso.

03:38.310 --> 03:39.800
Ótima maneira de praticar aqui.

03:39.800 --> 03:43.220
E esta é propositadamente a mais simples das cenas que vamos analisar.

03:43.220 --> 03:48.560
Portanto, se você ainda estiver se acostumando com os fundamentos e quiser se certificar de que eles sejam realmente assimilados,

03:48.560 --> 03:53.300
Sugiro que dedique um pouco mais de tempo a esta parte do vídeo e a esta parte da base de código até

03:53.300 --> 03:55.340
se sinta bem e, depois disso, siga em frente.

03:55.340 --> 03:59.450
E, novamente, aqui está um exemplo do tipo de testes unitários que criaremos.

03:59.450 --> 04:04.100
Este é um teste simples, completo e apropriado para cobrir o meu sistema de matemática.

04:04.100 --> 04:08.690
Portanto, aqui o que fazemos é seguir o paradigma de organizar, agir e afirmar.

04:08.720 --> 04:14.540
Essa é uma forma opcional de abordar seus testes unitários, apenas para organizar seus próprios pensamentos à medida que avança.

04:14.720 --> 04:18.740
Às vezes, ao longo do caminho, você pode estar fazendo desenvolvimento de código assíncrono.

04:18.740 --> 04:23.990
Assim, nessa metodologia, eu faria arrange, act, await e assert.

04:23.990 --> 04:29.840
E se você não tiver certeza do que é uma espera, veremos a metodologia await e async para fazer

04:29.870 --> 04:32.120
codificação assíncrona como parte do workshop.

04:32.120 --> 04:37.760
Agora, ao trabalhar no código-fonte aqui para contribuir com o projeto e para este curso, o que

04:37.760 --> 04:40.330
Fiz foi dar uma olhada em cada uma das dependências.

04:40.340 --> 04:47.990
O Unity tem certas bibliotecas no gerenciador de pacotes do unity disponíveis para que possamos fazer a solução oficial do unity

04:47.990 --> 04:49.550
para testes unitários.

04:49.550 --> 04:55.820
Agora, o que eu fiz aqui foi, em vez de usar a versão x que está em lançamento, usar uma versão experimental.

04:55.820 --> 04:59.900
Portanto, você pode notar que o executor do teste, como estou fazendo no vídeo, parece.

05:00.050 --> 05:04.940
Um pouco diferente de algumas capturas de tela que você já viu na Web ou se você tem experiência

05:04.940 --> 05:06.400
com o executor de testes.

05:06.410 --> 05:08.630
O que estou mostrando hoje pode parecer um pouco diferente.

05:08.660 --> 05:13.370
O projeto de amostra que você vai baixar vai ter a mesma aparência deste vídeo, porque eu

05:13.400 --> 05:15.020
incluí essa dependência lá.

05:15.050 --> 05:16.340
Há razões para eu ter feito isso.

05:16.340 --> 05:21.020
Não se trata apenas do fato de o executor de testes ter uma aparência diferente e ser mais estável, o que eu acho que é o caso.

05:21.050 --> 05:26.870
Além disso, a biblioteca por trás dele nos permite fazer algumas coisas adicionais, principalmente em relação a algumas funções assíncronas

05:26.870 --> 05:28.370
desenvolvimento e testes assíncronos.

05:29.730 --> 05:33.060
Você pode dar uma olhada no arquivo de texto da versão que está incluído no projeto.

05:33.060 --> 05:37.790
Se você quiser ver como, onde e por que incluiu cada uma dessas dependências.

05:37.800 --> 05:43.020
O projeto de exemplo em que vamos entrar inclui um recurso Readme, no qual podemos clicar e ver

05:43.020 --> 05:44.390
este menu agradável à direita.

05:44.400 --> 05:49.950
É uma maneira fácil de se orientar para lembrar alguns links populares e clicar diretamente em cada um dos

05:49.950 --> 05:51.690
amostras que você deseja acessar.

05:51.960 --> 05:57.270
Tenho um layout específico que você me verá usar aqui, que é manter o executor do teste no centro

05:57.270 --> 05:59.930
para que fique bonito e grande para os fins do vídeo.

05:59.940 --> 06:04.710
Muitas vezes, no desenvolvimento, o meu executor de testes talvez ficasse do lado direito, mas eu gosto de tê-lo

06:04.710 --> 06:08.280
na frente e no centro, especialmente para discutir os testes.

06:08.370 --> 06:13.290
É claro que você pode redimensionar essas janelas e layouts da maneira que quiser, mas alguns dos principais para

06:13.290 --> 06:18.150
dar uma olhada aqui são a janela do projeto, o executor de testes e o inspetor, que será

06:18.150 --> 06:19.020
daremos uma olhada.

06:19.020 --> 06:23.310
Então, estamos prestes a mergulhar aqui e dar uma olhada no primeiro dos workshops.

06:23.370 --> 06:27.870
Eu o dividi em várias seções, novamente focando em alguns subtópicos diferentes.

06:27.870 --> 06:35.130
Também pensei em organizá-las mais ou menos de um para o número mais alto, começando por

06:35.130 --> 06:39.840
com o mais fácil e menos complexo e, em seguida, desenvolver esses conceitos.

06:40.140 --> 06:42.810
Cada uma das cenas de demonstração é executada por si só.

06:42.810 --> 06:44.880
Basta apertar play na janela do console.

06:44.910 --> 06:47.070
Você verá algumas leituras e coisas do gênero.

06:47.070 --> 06:52.050
Você pode acompanhar e, em algumas cenas, há algo a ser feito quando você aperta o play.

06:52.080 --> 06:56.610
Às vezes, não há interface de usuário, é simples e você só olha para algumas declarações de registro de depuração.

06:56.610 --> 07:00.110
Por isso, estou muito animado para compartilhar esses workshops como uma ótima maneira de mergulhar de cabeça.

07:00.120 --> 07:01.140
Então, vamos começar.

07:01.140 --> 07:02.970
Vamos abrir o unity editor.

07:02.970 --> 07:07.680
Já fiz o download do código-fonte seguindo os recursos do curso no início da lição.

07:07.680 --> 07:12.540
Abriremos o projeto de amostra do curso e, em seguida, abriremos e reproduziremos uma ou mais cenas

07:12.540 --> 07:13.680
em cada um dos workshops.

07:13.680 --> 07:18.360
Primeiro, vamos dar uma olhada no recurso Readme que nos dá algumas orientações sobre o projeto.

07:18.390 --> 07:23.700
Também veremos o gerenciador de pacotes, exploraremos a estrutura do projeto e daremos uma olhada no teste

07:23.700 --> 07:24.630
janela do executor.

07:24.630 --> 07:29.610
Então, aqui estamos apenas dando uma visão geral do que é o projeto de amostra e como são os workshops

07:29.610 --> 07:30.270
formatados.

07:30.270 --> 07:33.090
Em seguida, passaremos a analisar cada um dos workshops.

07:33.090 --> 07:35.190
Então, aqui estamos dentro da unidade.

07:35.190 --> 07:39.960
Farei o possível para manter a cabeça da minha webcam fora do caminho da ação aqui.

07:39.960 --> 07:45.360
E o que vamos ver é que o Readme, que está disponível em alguns pontos, nós

07:45.360 --> 07:48.810
podemos ir até aqui e explorar esta opção de menu para abrir o Readme.

07:49.440 --> 07:54.060
Podemos também navegar pela janela do projeto e ir até aqui e clicar no readme.

07:54.180 --> 07:56.900
De qualquer forma, ele abrirá o readme no Inspetor.

07:56.910 --> 07:58.650
Vamos dar uma olhada no que temos aqui.

08:00.900 --> 08:05.490
Temos alguns links para o curso e para o projeto de amostra apenas para orientação, onde essas informações

08:05.490 --> 08:06.060
estão disponíveis.

08:06.060 --> 08:08.670
Se você quiser clicar e dar uma olhada nesses links.

08:11.450 --> 08:13.220
E depois a seção Getting Started.

08:13.220 --> 08:18.650
Há uma maneira rápida de chegar a alguns dos exemplos mais populares, portanto, você pode navegar pela seção

08:18.650 --> 08:20.060
janela do projeto e encontrá-los.

08:20.060 --> 08:22.140
Mas essa é uma boa maneira de se orientar.

08:22.160 --> 08:25.190
Outra coisa que eu gostaria de dar uma olhada é o gerenciador de pacotes aqui.

08:25.220 --> 08:29.360
Se você estiver baixando este projeto, verá os mesmos pacotes aqui.

08:29.360 --> 08:35.510
Mas se você decidir, para fins de aprendizado aqui ou no futuro, trazer essas lições

08:35.510 --> 08:40.640
em um projeto diferente, você vai querer que o seu gerenciador de pacotes seja semelhante, se quiser

08:40.640 --> 08:42.230
ter a mesma experiência aqui.

08:42.230 --> 08:46.160
Então, observe que eu tenho o pacote substituto final.

08:46.400 --> 08:52.130
Também tenho o pacote de cobertura de código, a estrutura de teste.

08:52.130 --> 08:56.990
E para o propósito deste curso, observe que tenho uma versão de pré-lançamento que nos dá algumas informações adicionais

08:56.990 --> 08:57.940
funcionalidades adicionais.

08:57.950 --> 09:00.050
Isso é opcional para testes unitários.

09:00.050 --> 09:04.730
Você certamente não precisa dele para a maior parte dos recursos de teste de unidade, mas acho que ele tem algumas

09:04.730 --> 09:06.020
coisas legais de ponta.

09:06.020 --> 09:10.040
Portanto, é nisso que vamos nos concentrar e recomendo que você experimente.

09:10.070 --> 09:11.420
Outra coisa digna de nota aqui.

09:11.420 --> 09:14.750
Este arquivo de versão que eu selecionei vai se aprofundar nisso.

09:14.750 --> 09:19.430
Essas são apenas algumas anotações que fiz ao longo do caminho para falar um pouco sobre as dependências que eu

09:19.430 --> 09:20.390
escolhi e por quê.

09:22.530 --> 09:24.420
Portanto, não vamos nos aprofundar nisso aqui.

09:24.450 --> 09:26.080
Isso também pode mudar com o tempo.

09:26.100 --> 09:30.210
Mas dê uma olhada neste arquivo se estiver curioso para saber como e por que usei cada uma das dependências, e

09:30.210 --> 09:33.450
por que uso a versão de pré-lançamento que mencionei explicitamente aqui.

09:33.480 --> 09:37.110
E, por último, na frente e no centro aqui, vamos dar uma olhada na janela do executor de teste.

09:37.140 --> 09:42.480
Agora essa janela está disponível em Window General e Test Runner.

09:42.480 --> 09:47.160
E está incluída em todas as instalações padrão do unity, como mencionei.

09:47.190 --> 09:51.600
Eu adicionei o pré-lançamento de um determinado pacote, então o layout do meu pode parecer um pouco diferente

09:51.600 --> 09:54.150
do que o padrão aqui neste layout.

09:54.180 --> 10:01.260
O que temos aqui é a capacidade de ativar e desativar os testes do modo de edição, e ativar e desativar os testes do modo de reprodução.

10:01.260 --> 10:03.570
Eles são mostrados aqui na mesma visualização da guia.

10:03.720 --> 10:04.840
Isso é realmente ótimo.

10:04.860 --> 10:07.800
Então, o que posso fazer é navegar pelas diferentes categorias.

10:07.800 --> 10:13.140
Agora criei todos os testes que estamos analisando e marquei cada um deles como uma categoria específica.

10:13.140 --> 10:18.360
Portanto, se eu quiser examinar apenas um teste específico, como o meu sistema de matemática, basta filtrar a visualização

10:18.390 --> 10:23.970
aqui e mostrará somente a edição ou somente a reprodução e de uma determinada categoria.

10:24.000 --> 10:25.230
Isso realmente ajuda você.

10:25.260 --> 10:31.170
Então, o que posso fazer aqui com apenas a edição selecionada, por exemplo, é poder ver todos os testes

10:31.170 --> 10:31.770
que estão lá.

10:31.770 --> 10:36.600
E aqui embaixo, na parte inferior, posso executar os testes selecionados ou executar todos os testes selecionados, por exemplo.

10:36.600 --> 10:40.950
E o que ele faz é percorrer e executar todo o código de teste.

10:41.040 --> 10:48.270
Esse é o núcleo da metodologia que estamos abordando aqui: periodicamente, durante o seu desenvolvimento

10:48.270 --> 10:50.270
você deseja testar sua própria base de código.

10:50.280 --> 10:55.190
Você chega a esta janela e pressiona manualmente o botão executar selecionado ou executar tudo.

10:55.200 --> 10:59.340
Vemos tudo verde aqui indicando sucesso aqui no topo.

10:59.340 --> 11:02.970
Isso nos dá uma pequena recapitulação de que temos 100 testes bem-sucedidos.

11:02.970 --> 11:07.550
Temos zero que falharam e zero que foram pulados ou ignorados.

11:07.560 --> 11:13.530
Portanto, uma ótima prática ao fazer testes unitários é garantir que todos os seus testes sejam aprovados.

11:13.560 --> 11:18.570
Não permita que um teste falho permaneça em seu projeto por muito tempo.

11:18.570 --> 11:19.680
Você quer resolver isso.

11:19.680 --> 11:20.520
Tire-o do caminho.

11:20.520 --> 11:23.280
Mesmo que você saiba que haverá uma migração no futuro.

11:23.280 --> 11:29.280
Portanto, a melhor prática aqui é manter os testes atualizados com as alterações no código e sempre tê-los

11:29.280 --> 11:30.030
passando.

11:30.030 --> 11:32.700
Então, aqui mostramos a prática recomendada em vigor.

11:33.690 --> 11:36.690
No próximo workshop, daremos uma olhada mais de perto no código-fonte envolvido.

11:36.690 --> 11:41.850
Mas isso é tudo para esta seção de análise dos workshops e do projeto de amostra.

11:46.910 --> 11:47.900
Olá e bem-vindos.

11:47.900 --> 11:53.990
Neste workshop, vamos dar uma olhada no sistema My Math, entrando no que é um projeto bastante

11:54.020 --> 11:58.250
exemplo bastante simples, apenas para nos familiarizarmos com os conceitos básicos de teste de unidade.

11:58.250 --> 12:01.640
Portanto, nesta demonstração, você pode usar o projeto Core Sample para acompanhá-lo.

12:01.640 --> 12:06.440
Vamos abrir o unity editor, abrir o projeto Core Sample e, em seguida, vamos

12:06.440 --> 12:08.060
abrir e reproduzir algumas cenas aqui.

12:08.060 --> 12:13.310
Vamos examinar o sistema My Math, bem como o teste por trás dele, e faremos uma recapitulação

12:13.340 --> 12:18.920
dos testes unitários, falando sobre quaisquer conceitos básicos que eu veja e pense em mencionar.

12:18.920 --> 12:25.370
E também falaremos sobre valores parametrizados, que é uma forma intermediária de abordar

12:25.370 --> 12:25.880
testes.

12:25.880 --> 12:29.540
E é uma boa habilidade adicional que você deve ter ao abordar os testes unitários.

12:29.570 --> 12:30.560
Vamos nos aprofundar.

12:30.770 --> 12:35.330
Aqui estou dentro do unity editor e abri o exemplo do meu sistema matemático.

12:35.330 --> 12:37.970
Vamos apenas reproduzir a cena em si.

12:38.000 --> 12:41.630
Às vezes, nesses workshops, a cena é mais emocionante.

12:41.630 --> 12:43.220
Esta não é tão empolgante.

12:43.220 --> 12:48.680
Vamos continuar e apertar o play aqui na janela inferior, vemos um texto simples que está ajudando

12:48.680 --> 12:53.960
a entender que estamos na demonstração de teste de unidade, e vamos apenas reproduzir a cena e visualizar o console.

12:53.960 --> 12:55.430
Então, vamos dar uma olhada no console.

12:55.520 --> 12:58.520
O console diz que essa cena não tem UI.

12:58.550 --> 13:01.430
Veja o console do unity aqui, estamos no console.

13:01.430 --> 13:02.090
Realmente.

13:02.090 --> 13:06.830
Ele só vai nos mostrar um valor que foi cuspido após uma operação bem-sucedida.

13:06.830 --> 13:12.290
Portanto, em um código de produção real, essa seria uma cena muito mais interessante.

13:12.290 --> 13:17.540
Talvez haja de fato o menu do jogo ou o jogo acontecendo aqui.

13:17.780 --> 13:22.730
Esta é uma cena bastante enxuta, onde não há muito para ver, mas você pode imaginar que isso poderia

13:22.730 --> 13:23.150
ser.

13:23.720 --> 13:28.880
Não é particularmente importante que haja uma cena de tempo de execução para fins de teste.

13:28.880 --> 13:34.520
Eu só quero falar com frequência sobre o equilíbrio entre o seu código de produção fazendo a produção dele

13:34.520 --> 13:35.150
coisa.

13:35.150 --> 13:38.480
E aqui está o código de teste fazendo o seu trabalho de teste.

13:38.480 --> 13:44.330
Então, o código de produção, sempre experimentamos isso ao apertar play em uma cena de unidade como esta.

13:44.330 --> 13:47.750
E para fazer nossos testes unitários, fazemos algo diferente.

13:47.780 --> 13:50.990
O que fazemos aqui é olhar para a janela do executor de teste.

13:51.530 --> 13:55.340
Exploramos a categoria apropriada para o que queremos ver aqui.

13:55.340 --> 13:57.470
Estamos examinando apenas o meu sistema de matemática.

13:58.560 --> 14:01.020
E depois clicamos em let's see.

14:01.020 --> 14:02.280
Vamos fazer o teste do modo de edição.

14:02.430 --> 14:06.780
Vamos rodar tudo aqui e todos os testes serão executados dessa forma.

14:06.810 --> 14:09.050
Agora, na verdade, a cena não foi executada.

14:09.060 --> 14:15.420
Ele está apenas rodando meio que lateralmente em seu próprio universo, rodando esses testes dentro de um

14:15.420 --> 14:16.290
modo de edição.

14:16.290 --> 14:19.790
Portanto, testes em modo de edição, falando um pouco sobre a diferença.

14:19.800 --> 14:25.050
Os testes do modo de edição são executados no modo de edição, que na unidade tem dois modos primários.

14:25.050 --> 14:30.630
Basicamente, do momento em que você aperta o botão play até o momento em que você aperta o botão play, ou seja

14:30.630 --> 14:31.290
modo de reprodução.

14:31.320 --> 14:35.440
Geralmente é onde o usuário experimenta a unidade de jogo.

14:35.610 --> 14:38.430
Sempre que não estivermos nesse modo, estaremos no modo de edição.

14:38.430 --> 14:40.170
Sentados bem aqui, estamos no modo de edição.

14:40.200 --> 14:46.260
Esses testes são executados no modo de edição porque não precisam necessariamente de toda a complexidade de um tempo de execução

14:46.260 --> 14:46.800
cena.

14:46.800 --> 14:52.110
Isso nos ajuda a ter uma pequena área isolada mais simples onde esses códigos são executados.

14:52.110 --> 14:57.780
Agora, às vezes, você precisa das conveniências dos monocomportamentos e da funcionalidade em tempo de execução.

14:57.780 --> 15:01.680
É aí que o modo play entra em ação.

15:01.680 --> 15:04.260
E aqui temos alguns testes de modo de reprodução também.

15:04.260 --> 15:09.480
Assim, cada vez que clico em uma dessas caixas de seleção, você pode ver que ele nos mostra algumas listas ligeiramente diferentes

15:09.510 --> 15:10.740
do que temos disponível.

15:10.740 --> 15:13.140
Então, aqui no modo play, vou clicar em run all.

15:13.950 --> 15:18.090
E aqui está sendo criada uma cena totalmente nova.

15:18.090 --> 15:24.420
Executando uma cena em tempo de execução que é apenas para demonstração com qualquer código de teste que eu tenha, e depois retorna

15:24.420 --> 15:26.880
de volta à cena original em que estávamos.

15:26.880 --> 15:31.110
Se não tivéssemos a cena salva, ele nos avisaria e diria, ei, você está prestes a executar um modo de reprodução

15:31.140 --> 15:31.620
teste.

15:31.650 --> 15:33.360
Vamos sair temporariamente de sua cena.

15:33.390 --> 15:35.040
Deseja salvar sua cena primeiro?

15:35.040 --> 15:37.500
Em geral, essa é uma boa ideia, portanto, fique atento a isso.

15:37.530 --> 15:39.300
Agora vamos dar uma olhada no código-fonte.

15:39.330 --> 15:43.020
Vamos primeiro dar uma olhada no código de produção em tempo de execução.

15:43.020 --> 15:45.810
Então, vamos abrir o exemplo do sistema My Math.

15:45.810 --> 15:52.740
Cada um desses workshops tem, em geral, um objeto de jogo com um script de exemplo que inicia

15:52.740 --> 15:53.580
tudo isso.

15:53.580 --> 15:59.490
Então, quando olhamos para isso, aqui estamos no editor de código e podemos ver o sistema completo do my math

15:59.490 --> 16:00.180
exemplo.

16:00.180 --> 16:05.670
Esse é um monocomportamento porque eu quero ter as conveniências do código em um objeto de jogo.

16:05.670 --> 16:10.380
E então, dentro do await aqui, vou simular algum código de produção.

16:10.380 --> 16:16.140
Agora ele está bem enxuto, não há muito o que fazer, e parece o mesmo que o teste que estamos fazendo

16:16.140 --> 16:21.780
porque eu crio a classe do zero e, em seguida, chamo um método nela, e então mostro

16:21.780 --> 16:22.530
os resultados.

16:22.530 --> 16:28.320
Mas é importante saber que em um exemplo de produção, em um projeto de jogo real, esse equivalente seria

16:28.320 --> 16:33.600
seria muitas classes e todas as cenas e todos os prefabs e toda a complexidade que você geralmente teria

16:33.600 --> 16:34.530
em seu projeto.

16:34.530 --> 16:37.230
Mas aqui estou mantendo-o propositalmente muito enxuto.

16:37.230 --> 16:38.910
Portanto, observe o que fazemos aqui.

16:38.910 --> 16:40.920
Criamos o sistema my math.

16:40.920 --> 16:45.750
Pegamos um par de ints e os preenchemos com os valores cinco e dez.

16:45.750 --> 16:47.940
E então chamamos o sistema my Math.

16:47.940 --> 16:50.550
E passamos os valores cinco e dez juntos.

16:50.550 --> 16:52.500
E aqui mostramos o resultado.

16:52.500 --> 16:54.030
Então, vamos em frente e fazer isso.

16:54.030 --> 16:55.470
Então, aqui eu aperto o play.

16:59.430 --> 17:03.560
E aqui embaixo, na janela do console, vemos que o resultado é 15.

17:03.570 --> 17:09.240
Gosto da simplicidade desse exemplo de codificação, pois ele nos faz começar a pensar em um mundo

17:09.240 --> 17:14.540
onde os testes unitários nunca existiram, como eu poderia ter certeza de que esse código é funcional?

17:14.550 --> 17:21.570
Bem, talvez esse código do meu sistema matemático seja usado em muitos, muitos lugares do seu jogo, e você simplesmente..,

17:21.570 --> 17:26.970
sempre que quiser ver e validar que esse sistema está funcionando bem, basta jogar o jogo e

17:26.970 --> 17:31.110
seu jogo pode durar alguns minutos ou várias horas.

17:31.110 --> 17:37.140
E esse sistema específico que está sendo testado pode ser usado em muitos lugares diferentes, dependendo

17:37.140 --> 17:40.320
de diferentes comportamentos, entradas e situações do usuário.

17:40.320 --> 17:42.660
Talvez a hora do dia seja importante.

17:42.660 --> 17:47.970
Portanto, é difícil saber se estou realmente testando em isolamento bruto?

17:47.970 --> 17:56.490
Portanto, um primeiro passo que eu poderia dar se quisesse fazer alguma validação é copiar isso aqui e colar

17:56.490 --> 17:57.360
aqui.

17:59.710 --> 18:02.220
E chamar isso aqui e testar.

18:02.230 --> 18:03.790
Bem, e se fossem seis?

18:03.790 --> 18:05.680
E se for 11?

18:07.710 --> 18:09.360
A para, B para.

18:14.010 --> 18:20.000
Portanto, agora estou testando não um teste unitário, mas estou apenas validando dois exemplos diferentes aqui.

18:20.010 --> 18:22.770
Então, estou fazendo este primeiro e o segundo.

18:22.800 --> 18:29.760
Isso é chamado de teste de usuário ou teste de modo de jogo ou teste de integração em que estou executando

18:29.760 --> 18:30.900
código de produção.

18:30.900 --> 18:37.710
E estou apenas experimentando como usuário, esperando que eu acidentalmente peça para ele fazer um monte de coisas diferentes

18:37.740 --> 18:40.620
operações diferentes e ver se nenhuma delas falha.

18:40.650 --> 18:44.790
Mas você pode imaginar que o que estou fazendo aqui é adicionar coisas que eu realmente não quero para o final

18:44.790 --> 18:46.140
experiência do usuário.

18:46.140 --> 18:52.650
Estou apenas tentando me dar um pouco mais de confiança no meu próprio código, chamando alguma funcionalidade

18:52.650 --> 18:53.910
vezes extras.

18:53.940 --> 19:00.510
Você também pode definir um booleano em algum lugar do seu projeto que diga que o modo de depuração é verdadeiro e, então

19:00.510 --> 19:02.280
em todo o seu código de produção.

19:02.280 --> 19:05.730
Se essa for a situação, você fará um pouco mais de testes.

19:05.730 --> 19:07.140
Isso não é ruim.

19:07.140 --> 19:12.150
Em determinadas situações, isso pode definitivamente ajudá-lo, mas vejamos como a situação é melhor

19:12.150 --> 19:12.720
pode ser.

19:12.720 --> 19:15.960
Se, em vez de fazer isso, eu executar testes unitários.

19:15.960 --> 19:18.780
Então, é aqui que o código desse projeto fica.

19:18.780 --> 19:23.010
Neste projeto, temos o sistema My Math, o exemplo do sistema My Math, que já vimos.

19:23.700 --> 19:29.580
A estrutura desse sistema e a forma como ele funciona em conjunto foram abordadas anteriormente no curso.

19:29.580 --> 19:34.350
Mas temos um teste de editor e um teste de tempo de execução sobre os quais falaremos.

19:34.350 --> 19:40.980
Novamente, qualquer teste de editor executará um modo de edição e, em geral, é ideal para coisas que não

19:40.980 --> 19:44.310
usam classes específicas de unidade como Monobehaviour.

19:44.310 --> 19:49.440
O Monobehaviour foi projetado apenas para ser executado em sua forma mais completa no modo de jogo.

19:49.440 --> 19:51.390
Portanto, aqui não é muito apropriado.

19:51.390 --> 19:51.870
Então.

19:51.870 --> 19:54.810
Mas para testes simples como o que temos aqui, ele é ótimo.

19:54.840 --> 19:59.580
A área de tempo de execução aqui, onde temos o teste do modo de reprodução, seria um ótimo lugar.

19:59.580 --> 20:05.130
E em cada um desses workshops eu faço um de cada, para que você possa ver as diferenças.

20:05.130 --> 20:09.960
Mas é importante pensar que, em determinadas situações, dependendo do que você está testando, provavelmente

20:09.960 --> 20:14.010
um teste de unidade no modo de edição é mais apropriado nessa situação.

20:14.010 --> 20:18.630
Esse é definitivamente o caso mais tarde, quando estivermos falando sobre mover com a entrada e fazer algo com

20:18.630 --> 20:24.750
física, talvez o teste do modo de jogo seja necessário nesse caso, porque a entrada e a física são realmente projetadas

20:24.750 --> 20:26.220
como experiências de modo de jogo.

20:26.220 --> 20:28.650
Portanto, é importante saber essa distinção.

20:28.650 --> 20:30.030
E eu vou falar sobre isso aqui e ali.

20:30.270 --> 20:32.760
Então, vamos dar uma olhada no teste do sistema de matemática mental.

20:36.190 --> 20:39.130
E ver como ele está organizado.

20:40.710 --> 20:45.990
Aqui, observe que o teste do sistema My Math tem algumas diferenças.

20:51.350 --> 20:53.180
Tem alguns métodos diferentes sob ele.

20:53.330 --> 20:57.500
Cada um dos nomes que vemos aqui são os nomes dos métodos de teste.

20:57.500 --> 20:59.000
Então, vamos começar com o primeiro.

20:59.600 --> 21:04.970
A convenção que eu gosto de usar é seguida aqui, e vamos abordá-la no código que eu geralmente coloco

21:04.970 --> 21:10.460
primeiro, qual método estamos testando, o que estamos esperando e, em seguida, qual é a situação.

21:10.460 --> 21:13.400
Então, aqui diz que o método add é o que estamos testando.

21:13.400 --> 21:18.080
Esperamos que o resultado seja 15 quando passarmos cinco e dez.

21:18.320 --> 21:23.750
Um bom atalho aqui é que, ao executar qualquer teste, você pode clicar duas vezes nele para executá-lo novamente.

21:24.800 --> 21:26.540
E depois posso clicar com o botão direito do mouse.

21:28.490 --> 21:29.360
Desculpe, eu estava no modo de reprodução.

21:29.810 --> 21:31.850
Clique duas vezes e ele volta a funcionar.

21:31.880 --> 21:32.330
Ótimo.

21:32.330 --> 21:33.230
Ainda verde.

21:33.230 --> 21:36.560
E posso clicar com o botão direito do mouse e escolher código-fonte aberto.

21:37.720 --> 21:41.800
Essa é uma maneira fácil de ir direto para a classe certa e para o método certo.

21:41.830 --> 21:44.320
Aqui está novamente o nome do método que vimos.

21:44.350 --> 21:47.860
Novamente, o resultado da adição é 15 quando cinco e dez.

21:47.890 --> 21:54.070
A razão pela qual isso é importante é que se você tiver muitas classes de teste com muitos métodos de teste,

21:54.070 --> 22:01.600
e eu espero que você tenha em seu projeto, a fim de saber qual em um executor de teste é qual no código

22:01.600 --> 22:04.610
Aqui, é bom ter essa nomenclatura consistente.

22:04.630 --> 22:09.910
Então, o que fazemos aqui é a metodologia de organizar, agir e afirmar.

22:09.910 --> 22:10.720
No arranjo.

22:10.720 --> 22:15.310
O que vamos fazer primeiro é criar uma nova instância do que queremos testar.

22:15.310 --> 22:19.420
Dessa forma, sabemos que ela não ficou parada, não tem dados antigos dentro dela.

22:19.430 --> 22:20.770
É sempre uma boa prática.

22:20.770 --> 22:22.480
Então, vamos agir de acordo com isso.

22:22.480 --> 22:26.140
Qual é o único método que você pode usar se conseguir se safar?

22:26.140 --> 22:28.690
Talvez dois métodos que realmente façam o teste.

22:28.690 --> 22:30.160
Mas um método é o ideal.

22:30.190 --> 22:32.680
Aqui estamos somando cinco e dez.

22:32.680 --> 22:36.670
E depois, no assert, vamos usar essa linguagem de assert.

22:36.670 --> 22:43.630
A classe assert tem uma certa estrutura na qual você diz que eu afirmo que algo é algo.

22:43.630 --> 22:48.670
E você pode dar uma olhada na documentação sobre isso para ver uma variedade de maneiras de formatar isso.

22:48.670 --> 22:54.790
Mas muitas vezes eu uso é igual a ou é verdadeiro ou é falso.

22:54.790 --> 22:57.670
Então, esses são os que você verá comumente aqui.

22:57.970 --> 23:02.920
Então, quando eu executo isso, porque o código é executado corretamente, ele adiciona cinco e dez para formar 15.

23:02.950 --> 23:03.700
É isso aí.

23:03.730 --> 23:05.010
Somos capazes de fazer isso.

23:05.020 --> 23:08.620
Agora lembre-se do exemplo que eu estava dando no código de produção.

23:08.620 --> 23:17.650
E se você quisesse testar cinco e dez e depois testar seis e 11 e depois testar sete e 12 ou qualquer outra coisa?

23:17.650 --> 23:18.700
combinações?

23:18.700 --> 23:25.510
Quanto mais você se aperfeiçoar nos testes, perceberá quantos testes realmente precisa para oferecer uma cobertura adequada.

23:25.510 --> 23:31.180
Há muita arte e ciência em torno de qual é o número mínimo de testes que você pode fornecer que

23:31.180 --> 23:34.720
maximizar seu impacto e a cobertura de código que você tem?

23:34.750 --> 23:40.030
Portanto, uma das coisas sobre as quais eu gostaria de falar como parte desse workshop específico é o que chamamos de

23:40.030 --> 23:41.830
testes parametrizados.

23:41.830 --> 23:48.460
Portanto, em vez de simplesmente copiar este, colá-lo abaixo e ajustar os valores para somar seis

23:48.460 --> 23:55.780
e 11 ou 0 e dez negativos, podemos pedir ao unity para executar exatamente o mesmo teste, mas passando alguns valores diferentes

23:55.780 --> 23:56.530
valores diferentes.

23:56.530 --> 23:58.750
Há muitas opções diferentes aqui.

23:58.750 --> 24:00.340
Estou mostrando apenas uma delas.

24:00.340 --> 24:02.800
Mas vamos dar uma olhada aqui embaixo.

24:03.730 --> 24:10.090
Dizemos, e juntos, que assumimos que o resultado está correto quando esses valores.

24:10.090 --> 24:15.640
Portanto, os nomes dos métodos são um pouco mais vagos porque são parametrizados, não sei necessariamente.

24:15.640 --> 24:18.430
Isso vai testar cinco e dez é 15.

24:18.460 --> 24:24.250
Observe que aqui, em vez de fazer o que fiz antes, que era declarar cinco e dez.

24:24.280 --> 24:29.890
No corpo do método, eu uso essa linguagem específica, eu uso algo chamado fonte de valor.

24:29.890 --> 24:31.210
E então eu o passo.

24:31.210 --> 24:37.090
O que o unity faz é preencher essa primeira passagem de valores aqui.

24:37.090 --> 24:38.740
Então, digamos que são cinco.

24:38.770 --> 24:41.290
Em seguida, ele pega outra fonte de valores aqui.

24:41.320 --> 24:48.010
Digamos que um é dez e ele assume que são cinco mais dez somados.

24:48.010 --> 24:52.960
Portanto, toda vez que for executado, ele fará o equivalente ao último teste que vimos.

24:52.960 --> 24:59.050
Mas, em vez de ser codificado para apenas um conjunto de valores, ele vai misturar e mostrar uma variedade

24:59.050 --> 24:59.560
deles.

24:59.560 --> 25:02.460
Mais uma vez, há muitas maneiras diferentes de formatar isso.

25:02.460 --> 25:06.670
Portanto, você deve consultar a documentação dos testes parametrizados na unidade.

25:06.670 --> 25:08.920
Mas vamos dar uma olhada no meu caso específico aqui.

25:08.950 --> 25:11.350
Esses valores de fontes de valores A e b.

25:11.350 --> 25:14.770
Referem-se apenas a duas matrizes que tenho aqui em cima.

25:14.770 --> 25:20.980
E o que ele vai fazer é simplesmente passar por ele e testar um e um, negativo dois e

25:20.980 --> 25:23.530
negativo dois, negativo três e negativo três e passá-los para dentro.

25:23.560 --> 25:30.070
Você pode organizá-los da maneira que quiser e testar diferentes cenários, talvez fazendo sete, 11

25:30.070 --> 25:30.670
e 12.

25:30.700 --> 25:32.230
Você pode testar o que quiser.

25:32.260 --> 25:35.020
Agora você não precisa testar quantidades infinitas ali.

25:35.020 --> 25:37.450
É aqui que entram a arte e a ciência.

25:37.450 --> 25:43.960
Talvez você queira testar alguns valores negativos, zero em alguns cenários e alguns valores positivos.

25:43.990 --> 25:48.820
Talvez o que você esteja fazendo não seja baseado em matemática e você queira pensar nisso de outra forma, mas o que você está fazendo é

25:48.820 --> 25:51.370
procurando o que chamamos de casos extremos.

25:51.370 --> 25:57.250
Assim, por exemplo, se você estiver usando um método de divisão e quiser testá-lo matematicamente, há

25:57.250 --> 25:59.740
um desafio sobre a divisão por zero.

25:59.740 --> 26:03.970
Por isso, você deve passar o zero e lidar com isso de forma elegante.

26:03.970 --> 26:09.040
Você realmente precisa conhecer o domínio específico em que se encontra o seu código de produção para saber como

26:09.040 --> 26:09.730
testá-lo.

26:09.730 --> 26:14.020
Mas aqui estão alguns positivos e negativos e coisas do gênero.

26:15.200 --> 26:17.950
Então, vamos dar uma olhada em como isso fica no unity editor.

26:17.960 --> 26:19.670
Observe o que ele faz aqui.

26:19.670 --> 26:24.980
Na verdade, ele executa 49 testes com base em todas as combinações que temos aqui.

26:24.980 --> 26:28.850
Assim, ele mostra quando os valores são e depois passa para dentro.

26:28.850 --> 26:30.430
Isso é muito bom.

26:30.440 --> 26:37.430
Agora, ao olhar para esse resultado, você pode perceber que será importante para mim testar 100

26:37.430 --> 26:38.800
e -100.

26:38.810 --> 26:39.320
Ótimo.

26:39.320 --> 26:45.890
Em seguida, volte e adicione esses valores de amostra se você quiser fazer outras coisas em vez de apenas uma

26:45.890 --> 26:46.610
lista codificada.

26:46.610 --> 26:50.510
Se você quiser selecionar valores aleatórios, há muitas outras opções disponíveis.

26:50.510 --> 26:53.180
Novamente, faça uma pesquisa sobre testes parametrizados.

26:53.360 --> 26:57.860
Se quiser, você também pode se aprofundar no teste do modo de jogo, mas como esse será mais interessante

26:57.860 --> 27:02.000
em outros exemplos, vamos seguir em frente e concluir este dos workshops.

27:02.000 --> 27:02.840
Obrigado.

27:09.660 --> 27:13.260
Olá e bem-vindo a este workshop de teste de unidade Unity.

27:13.260 --> 27:16.830
Vamos dar uma olhada no meu carregador de dados Basic como exemplo.

27:16.830 --> 27:17.420
Vamos nos aprofundar.

27:17.430 --> 27:20.280
Então, nesta demonstração, vou abrir o unity.

27:20.280 --> 27:25.650
Abra o nosso projeto de amostra principal e dê uma olhada na cena do meu carregador de dados básico.

27:25.650 --> 27:31.500
Agora, a razão pela qual escolhi fazer algum tipo de carregamento de dados é apenas para falar sobre, bem, o que

27:31.500 --> 27:39.900
Se os nossos testes de unidade, que esperamos que sejam muito confiáveis, isolados e executados rapidamente para o bem da nossa

27:39.900 --> 27:42.000
metodologias de teste próprias?

27:42.000 --> 27:47.760
E se eles dependerem de outros sistemas, como saberemos se podemos testar apenas uma parte?

27:47.790 --> 27:55.740
Em geral, o teste de unidade consiste em testar uma única unidade, que pode ser considerada como um método de uma classe.

27:55.740 --> 28:01.740
Mas, muitas vezes, nosso código é composto por várias classes que dependem umas das outras, e isso pode ser um desafio para decidir

28:01.740 --> 28:05.100
como separá-las e testá-las isoladamente.

28:05.100 --> 28:11.280
Além disso, você pode ter um sistema que depende de algo assíncrono, como renderização de gráficos, renderização

28:11.280 --> 28:14.760
áudio ou, nesse caso, chamar um servidor de back-end.

28:14.760 --> 28:22.380
Então, criei um exemplo muito simples aqui que carrega os dados que você passa em uma URL, ele simplesmente chama alguma página da web

28:22.380 --> 28:24.630
e recebe de volta o texto dessa página da Web.

28:24.660 --> 28:31.410
Portanto, este é o exemplo mais simples, mas você pode imaginar que se trata de qualquer lógica de servidor chamando para enviar

28:31.410 --> 28:36.540
uma pontuação alta do seu jogo, chamando para carregar os dados do jogador, algo relacionado ao multijogador.

28:36.540 --> 28:41.250
Talvez todos eles possam depender de algum tráfego de rede assíncrono.

28:41.340 --> 28:42.330
Vamos dar uma olhada.

28:42.420 --> 28:44.250
Então, aqui estamos na amostra.

28:44.250 --> 28:46.290
Temos meu carregador de dados básico.

28:46.290 --> 28:46.890
Carregue-o.

28:46.890 --> 28:47.940
Vamos dar o play.

28:50.730 --> 28:51.990
Nesta demonstração em particular.

28:52.020 --> 28:56.550
Não há coisas realmente interessantes nesta demonstração em particular.

28:56.580 --> 28:58.950
Não há nada muito interessante acontecendo na jogabilidade.

28:59.220 --> 29:02.940
Vamos para o console aqui e veremos que essa cena não tem UI.

29:02.970 --> 29:09.300
Veja o console da unidade, que mostra apenas o comprimento do que é retornado do servidor.

29:09.300 --> 29:13.200
Qualquer coisa diferente de zero significa que foi carregada uma página.

29:13.200 --> 29:14.670
Portanto, muito leve.

29:14.670 --> 29:15.690
Teste simples.

29:15.690 --> 29:19.190
Eu não tenho verificação de erros ou esse tipo de coisa embutida.

29:19.200 --> 29:23.640
Ele apenas assume o sucesso por causa da simplicidade desta demonstração.

29:23.670 --> 29:27.780
Se você estiver fazendo um código de produção e chamando os servidores, você vai querer adicionar muito mais funcionalidades

29:27.780 --> 29:28.410
a ele.

29:28.410 --> 29:32.770
Portanto, essa é a experiência em tempo de execução, que é bastante simples e não muito interessante.

29:32.790 --> 29:38.550
Agora, se olharmos para o executor do teste aqui, podemos definir a nossa categoria como sendo o meu carregador de dados básico.

29:38.550 --> 29:42.360
Assim, ele nos mostra apenas os testes relacionados a esse código específico.

29:42.360 --> 29:44.160
Em seguida, entramos no modo de edição.

29:44.160 --> 29:48.210
Aqui, novamente, temos o modo de reprodução, mas você pode explorá-lo por conta própria.

29:48.210 --> 29:52.230
Para esta demonstração em particular, acho que o modo de edição é mais interessante.

29:52.230 --> 29:54.660
Portanto, vou clicar em executar tudo.

29:56.330 --> 29:58.350
E podemos ver que tivemos sucesso.

29:58.370 --> 30:04.520
Isso diz que o resultado do load async contém doctype quando é carregado.

30:04.520 --> 30:06.500
Então, vamos dar uma olhada em um pouco disso.

30:06.630 --> 30:08.780
Vamos abrir nosso código-fonte aqui.

30:10.200 --> 30:11.820
E aqui está o teste.

30:11.940 --> 30:17.640
Ele mostra que primeiro criamos uma instância do nosso My Data Loader basic.

30:17.940 --> 30:21.660
Em seguida, ouvimos quando ele é carregado.

30:22.610 --> 30:25.880
Verificaremos os dados carregados de volta do servidor.

30:25.890 --> 30:30.800
Mais uma vez, isso é apenas uma chamada para uma página da Web e, seja qual for o código-fonte da página da Web, ele é retornado como um

30:30.800 --> 30:32.030
grande bloco de texto.

30:32.030 --> 30:34.370
Portanto, vai se parecer com alguma coisa HTML.

30:34.370 --> 30:39.920
E quando olhei para ele enquanto o estava criando, notei que dizia doctype como parte dele.

30:39.920 --> 30:45.530
Portanto, o Doctype não é algo muito significativo, certamente não no mundo da unidade, mas eu apenas pensei

30:45.530 --> 30:49.640
era um pequeno teste que me diz se eu recebi algo de volta de uma página da web?

30:49.640 --> 30:53.030
Você pode imaginar um teste para qualquer outra substring que faça sentido para você.

30:53.120 --> 31:00.020
Finalmente, executo a ação aqui que estamos testando e carrego a chamada assíncrona

31:00.020 --> 31:01.340
e passo a URL.

31:01.370 --> 31:05.690
Agora observe que a URL é a URL da página do GitHub.

31:05.690 --> 31:07.280
Mas isso não é tão importante.

31:07.430 --> 31:08.600
Não há nada de exclusivo aqui.

31:08.600 --> 31:15.620
Se você quiser fazer um teste como o do google.com, ele simplesmente chamará o google.com e obterá a fonte

31:15.620 --> 31:16.820
código de volta a partir disso.

31:16.820 --> 31:22.220
Não quero realmente me concentrar no que estou fazendo aqui no código de produção, porque é um código reconhecidamente

31:22.220 --> 31:23.330
exemplo simples.

31:23.330 --> 31:28.640
Eu só queria que fosse uma forma de fazer algo assíncrono acontecer dentro da unidade.

31:29.800 --> 31:32.500
Então, vamos dar uma olhada no código-fonte para entendermos.

31:33.520 --> 31:33.970
Aqui.

31:33.970 --> 31:34.540
O que estamos fazendo.

31:34.540 --> 31:38.740
Quando chamo o load, apenas digo, ei, certifique-se de que a URL não está vazia.

31:39.130 --> 31:44.320
Em seguida, vou em frente e uso a solicitação web do Unity, que é uma funcionalidade integrada.

31:44.320 --> 31:51.520
Chamo a solicitação de envio e defino o resultado como sendo o texto do manipulador de download.

31:51.550 --> 31:53.830
Essa é uma maneira super econômica e fácil.

31:53.830 --> 31:57.010
Recomendado pela unity para chamar dados simples on-line.

31:57.040 --> 31:58.570
Muito simples e direto.

31:58.600 --> 32:02.860
Isso levanta uma questão: o que estamos testando aqui?

32:03.280 --> 32:09.580
Tenho uma classe personalizada chamada meu carregador de dados, mas dentro dela estou dependendo muito de uma unidade existente

32:09.610 --> 32:12.160
funcionalidade do unity web request.

32:12.190 --> 32:16.060
Em seguida, estou chamando alguma página da Web, neste caso o GitHub.

32:16.060 --> 32:17.650
E isso está envolvido.

32:17.650 --> 32:22.810
Se o GitHub estivesse de alguma forma fora do ar durante o dia, este teste falharia.

32:22.840 --> 32:24.100
Isso é apropriado?

32:24.100 --> 32:31.000
Se o meu teste unitário for realmente para testar a minha própria metodologia, a minha própria funcionalidade, eu não deveria considerar

32:31.000 --> 32:32.050
um teste que falhou.

32:32.050 --> 32:34.840
Se alguma dependência não relacionada falhar.

32:34.840 --> 32:36.610
Mas aqui é esse o caso.

32:36.610 --> 32:38.640
Eu falharia se o GitHub estivesse fora do ar.

32:38.650 --> 32:44.440
Além disso, aqui dentro estou usando o Unity web request, que é uma funcionalidade incorporada pelo unity.

32:44.470 --> 32:50.920
Esperamos que ele funcione 100% do tempo em todas as situações, mas é possível que o meu código funcione e

32:50.920 --> 32:52.210
seu código não funcione.

32:52.210 --> 32:54.520
Portanto, há uma área cinzenta aqui.

32:54.520 --> 32:59.680
Quando você pensa em projetar suas classes e depois projetar os testes nessas classes, como você

32:59.680 --> 33:01.990
sabe no que você deve se concentrar de fato?

33:01.990 --> 33:04.390
Testes, de modo geral.

33:04.390 --> 33:09.550
E há livros e livros escritos sobre esse assunto de como abordar a arte dos testes unitários.

33:09.550 --> 33:15.370
Mas, de modo geral, você quer reduzir as dependências e simplificar o número

33:15.370 --> 33:17.530
de linhas de código que você está testando.

33:17.530 --> 33:24.490
Portanto, menos código é melhor porque é mais simples e focado e você sabe exatamente, isoladamente, qual

33:24.490 --> 33:26.020
código que está sendo testado.

33:26.020 --> 33:28.000
Portanto, este é um exemplo perfeito.

33:28.000 --> 33:32.950
Mas, para nós, é uma ótima maneira de começar e apenas falar sobre a execução de código assíncrono.

33:32.950 --> 33:35.020
Então, por enquanto, vamos encerrar este exemplo.

33:42.300 --> 33:44.460
Olá e bem-vindo ao Unit Testing for unity.

33:44.490 --> 33:48.120
Vamos dar uma olhada no meu carregador de dados na versão avançada aqui.

33:48.120 --> 33:54.270
Para ver essa demonstração em ação, vamos abrir o unity Download e usar o projeto de amostra Source para

33:54.270 --> 33:55.020
este curso.

33:55.020 --> 33:57.120
Vamos dar uma olhada em uma cena-chave aqui.

33:57.120 --> 33:59.310
Esse é o carregador My Data avançado.

33:59.310 --> 34:05.310
Alguns dos conceitos sobre os quais falarei aqui incluem injeção de dependência, como vemos, e substituto final.

34:05.310 --> 34:11.250
Aqui estamos dentro da unidade, tenho a cena para o carregador My Data avançada pronta e pronta para ser usada aqui.

34:11.250 --> 34:16.170
Então, vamos prosseguir e executar essa cena para muitas dessas cenas no workshop.

34:16.170 --> 34:20.940
A execução da cena de produção não é a coisa mais interessante, mas eu sempre incentivo você a fazê-la

34:20.940 --> 34:21.990
como ponto de partida.

34:21.990 --> 34:28.410
Então, aqui vemos um registro simples do console que diz que o comprimento dos dados carregados é este.

34:28.440 --> 34:32.220
Esse valor não é muito importante, mas você pode se aprofundar na classe de exemplo se quiser dar uma olhada

34:32.220 --> 34:32.550
para dar uma olhada nela.

34:32.550 --> 34:34.290
Vamos executar o teste para ele.

34:36.660 --> 34:40.200
Então, aqui em cima, eu tenho a minha categoria definida para o meu carregador de dados avançado.

34:40.200 --> 34:44.430
Portanto, estamos vendo apenas os testes relacionados a isso e apenas no modo de edição.

34:44.460 --> 34:47.430
Há também um teste no modo play que você pode dar uma olhada quando quiser.

34:47.430 --> 34:49.710
Mas acho que o modo de edição é mais interessante aqui.

34:49.710 --> 34:51.600
Então, vou fazer tudo.

34:57.250 --> 35:01.540
E aqui vemos que temos dois testes e ambos passam com uma verificação verde, o que é ótimo.

35:01.570 --> 35:06.590
Vamos dar uma olhada no load async e no mock load async e ver como eles funcionam.

35:06.610 --> 35:08.350
Então, aqui estamos no código de exemplo.

35:08.350 --> 35:11.260
Se você acompanhou o último vídeo, e espero que tenha acompanhado.

35:11.290 --> 35:18.760
Examinamos o método que estamos vendo aqui, que usa uma chamada real para um servidor da Web, carrega

35:18.760 --> 35:21.000
os dados de volta e verifica o valor deles.

35:21.010 --> 35:24.460
Isso se parece muito com o que seria o caso de uso de produção?

35:24.460 --> 35:26.950
Mas já falamos sobre alguns dos problemas.

35:26.980 --> 35:31.150
Estou testando o meu código ou estou testando o Unity Web Service por baixo dele?

35:31.180 --> 35:35.260
Estou testando isso ou estou testando o back-end do github.com?

35:35.260 --> 35:42.130
E se for um servidor estável, você deve concentrar seus testes no seu próprio código personalizado e ter pelo menos

35:42.130 --> 35:43.900
e o menor número possível de dependências.

35:43.900 --> 35:46.060
Portanto, há alguns problemas com isso.

35:46.090 --> 35:51.990
A primeira coisa que fiz ao abordar esse assunto foi pensar na injeção de dependência.

35:52.000 --> 35:58.630
Digamos que, na produção, eu queira ter uma forma de chamar isso e que isso seja implementado, que

35:58.630 --> 36:00.480
está usando o serviço web Unity.

36:00.490 --> 36:04.780
Então, para testar, talvez eu queira ter uma segunda maneira de abordar o assunto.

36:04.810 --> 36:11.890
Agora, você pode ter um sinalizador em sua base de código que diga algo como "is debug equals true" ou "is production".

36:11.890 --> 36:12.790
é igual a falso?

36:12.790 --> 36:17.360
E em seu código de produção, faça certas coisas no modo de teste e outras não.

36:17.380 --> 36:21.930
Vejo muito disso acontecer nas bases de código, mas geralmente não é uma boa prática.

36:21.940 --> 36:27.880
Você está poluindo o seu código de produção com coisas que são realmente apenas para testes, portanto, não é tão apropriado.

36:27.910 --> 36:29.320
Esta é uma solução melhor.

36:29.320 --> 36:30.700
Vamos dar uma olhada no que fazemos.

36:31.270 --> 36:37.450
Bem, no exemplo básico anterior, eu não tinha um conceito de serviço de rede, nem passei

36:37.450 --> 36:38.220
aqui.

36:38.230 --> 36:41.560
Nós simplesmente o criamos e ele sempre funcionou de uma forma.

36:41.560 --> 36:45.760
Mas a injeção de dependência aqui é decidida por mim.

36:45.760 --> 36:49.170
Aqui está uma forma personalizada em que isso poderia funcionar.

36:49.180 --> 36:53.380
Esta é uma parte da lógica que eu poderia trocar de algumas maneiras diferentes.

36:53.380 --> 36:56.020
Eu a declaro aqui em uma linha e depois a passo.

36:56.020 --> 36:59.560
Assim, você pode imaginar ter vários serviços de rede diferentes.

36:59.560 --> 37:04.120
Eu poderia ter um que fosse apenas para testes, um que fosse apenas para produção, um que apenas escrevesse para

37:04.120 --> 37:08.680
um disco local, um que seja apropriado para um servidor backend específico.

37:08.680 --> 37:09.460
ET cetera.

37:09.490 --> 37:12.160
Isso também tem casos de uso em produção.

37:12.160 --> 37:14.060
Essa ideia de injeção de dependência.

37:14.080 --> 37:16.360
Agora, por que chamamos isso de injeção de dependência.

37:16.360 --> 37:26.080
É porque, em vez de meu carregador de dados avançado fazer sempre uma coisa, eu passo alguma informação que decide

37:26.080 --> 37:27.610
como ele vai operar.

37:27.610 --> 37:34.090
Portanto, em vez de a própria classe saber tudo aqui, estou passando uma dependência, neste caso, para

37:34.090 --> 37:36.250
o serviço Unity Web Request Network.

37:36.250 --> 37:42.610
Então, vamos dar uma olhada em como isso foi estruturado e veremos por que é útil para nós ao fazermos o nosso

37:42.610 --> 37:43.300
testes.

37:43.390 --> 37:47.140
Aqui está o código-fonte completo do My Data loader advanced.

37:47.170 --> 37:49.420
Agora, quero me concentrar em duas coisas aqui.

37:49.420 --> 37:53.530
Uma é que em seu construtor eu passo essa dependência.

37:53.560 --> 38:01.060
Agora a injeção de dependência e como criar classes flexíveis a partir desse conceito de injeção de dependência

38:01.060 --> 38:03.700
estão realmente fora do escopo desta aula.

38:03.730 --> 38:06.220
É uma coisa muito boa para você dar uma olhada.

38:06.220 --> 38:12.730
Você poderia pesquisar no Google algo como D I para unity ou injeção de dependência para unity, ou mesmo dependência

38:12.730 --> 38:17.410
em programação orientada a objetos, e ver mais alguns desses conceitos gerais.

38:17.410 --> 38:23.160
Mas supondo que você tenha alguma familiaridade, especialmente devido à minha explicação que acabei de dar,

38:23.170 --> 38:24.460
vamos seguir em frente.

38:24.490 --> 38:31.810
Agora que estou passando isso como uma dependência aqui e armazenando-a, sempre que eu chamar a nossa funcionalidade principal

38:31.840 --> 38:38.560
de carregar assíncrono, o que eu faço é dizer, ok, quando eu estiver pronto para carregar assíncrono, basta dizer ao meu serviço de rede

38:38.560 --> 38:39.730
para carregar o async.

38:39.730 --> 38:47.020
Agora você pode imaginar se eu tiver passado um serviço de rede que faz um load async para um servidor de back-end

38:47.020 --> 38:48.820
de uma tecnologia específica.

38:48.850 --> 38:50.410
Esta linha aqui faria isso.

38:50.650 --> 38:56.920
Que se eu passasse outra coisa que escrevesse no disco ou lesse do disco como um tipo diferente

38:56.920 --> 38:59.980
de serviço de rede, esta é a linha aqui que realmente mudaria.

38:59.980 --> 39:06.130
Assim, eu não preciso ter 2 ou 3 versões diferentes do meu carregador de dados avançado aqui.

39:06.130 --> 39:11.130
Em vez disso, eu passo uma implementação personalizada que lida com esse detalhe específico de uma forma única.

39:11.140 --> 39:15.130
É uma maneira muito poderosa de tornar o seu código mais flexível.

39:15.130 --> 39:23.410
Agora que já falamos sobre passar uma dependência e como ela pode envolver a funcionalidade

39:23.410 --> 39:26.650
aqui, vamos dar uma olhada no que é a fonte para essa dependência em particular.

39:26.650 --> 39:31.240
Então, aqui em cima, no mesmo arquivo de classe, tenho algumas coisas para falar.

39:31.240 --> 39:33.580
Primeiro, criei uma interface.

39:33.700 --> 39:41.230
Esta interface aqui do serviço de rede I declara que qualquer pessoa que queira ser considerada viável

39:41.230 --> 39:47.020
dependência a ser passada aqui tem que ter algum método ou métodos disponíveis.

39:47.020 --> 39:51.970
E, neste caso, ele só precisa ter o load async e receber uma string URL.

39:51.970 --> 39:52.720
É isso aí.

39:52.750 --> 39:56.620
Agora, se você não estiver muito familiarizado com as interfaces.

39:56.940 --> 39:58.560
Por favor, dê uma olhada nas interfaces.

39:58.560 --> 40:04.290
Você poderia dar uma olhada em algo como interfaces versus classes em C-sharp ou em unity, e verá muitas

40:04.290 --> 40:05.130
de exemplos.

40:05.130 --> 40:11.970
Mas uma distinção importante aqui é que a interface define o que é a API pública, mas não define

40:11.970 --> 40:13.980
se preocupa em fazer a implementação.

40:14.100 --> 40:17.530
A implementação é declarada aqui em uma classe pública.

40:17.560 --> 40:19.710
Agora as classes com as quais você provavelmente está mais familiarizado.

40:20.010 --> 40:24.570
E o que fazemos aqui é implementar um sabor particular disso.

40:24.600 --> 40:30.360
O serviço de rede nessa variante específica deve lhe parecer muito familiar em relação ao vídeo anterior.

40:30.390 --> 40:32.760
Esta é exatamente a mesma implementação.

40:33.030 --> 40:40.130
Estamos apenas usando o unity web request e depois fazendo a metodologia de envio de web request.

40:40.140 --> 40:45.510
Agora que olhamos o código-fonte que está voltando aqui, podemos ver que estamos apenas criando

40:45.510 --> 40:48.270
uma classe personalizada que lida com um pouco da funcionalidade.

40:48.270 --> 40:50.520
E passamos essa classe personalizada para lá.

40:50.520 --> 40:55.010
Mas agora temos uma classe avançada do carregador de dados que é muito mais flexível.

40:55.020 --> 40:59.720
Agora, por que, especificamente no mundo dos testes, a injeção de dependência é relevante?

40:59.730 --> 41:05.370
Bem, temos um utilitário maravilhoso que podemos usar dentro do unity para nossos testes unitários.

41:05.370 --> 41:10.800
Essa é uma biblioteca chamada N substitute e foi incluída aqui no projeto de exemplo.

41:10.800 --> 41:13.980
Vamos dar uma olhada em outro método de teste logo abaixo do outro.

41:13.980 --> 41:17.880
E este vai usar o que é chamado de simulação de uma classe.

41:17.880 --> 41:23.280
Portanto, aqui temos uma criação muito semelhante do carregador My Data avançado.

41:23.280 --> 41:29.070
E, em vez de passar a versão da solicitação web da unidade, vamos fazer algo que parece bastante

41:29.100 --> 41:29.880
estranho aqui.

41:29.880 --> 41:32.940
Vamos usar a biblioteca substituta.

41:32.940 --> 41:40.260
E o que vamos fazer aqui é dizer "hey on the fly" nessas duas linhas, vá criar

41:40.260 --> 41:45.000
uma classe que pode lidar com a funcionalidade que eu preciso.

41:45.000 --> 41:51.990
Mas como se trata de uma classe simulada, ela não precisa necessariamente chamar o servidor.

41:51.990 --> 41:57.450
Em vez disso, o que ele fará é, em momentos importantes, retornar um valor previsível para nós.

41:57.450 --> 42:06.660
Lembre-se de que o nosso fluxo aqui é que o teste diz ao carregador de dados para carregar um URL dentro dos dados

42:06.660 --> 42:10.740
O carregador de dados diz ao serviço de rede para carregar uma URL.

42:10.770 --> 42:17.430
Esse último passo, o resultado final, leva meio segundo, vai e carrega do servidor e retorna

42:17.460 --> 42:18.870
uma string de volta.

42:18.870 --> 42:23.760
Portanto, tudo o que eu realmente preciso em uma situação de simulação é: ok, nem mesmo chame um servidor.

42:23.760 --> 42:27.330
Apenas quando eu chamar isso, você me dará uma string de volta.

42:27.330 --> 42:36.750
Então, estou dizendo aqui com essa linguagem que quero que sempre que eu chamar o load async e passar qualquer string

42:36.750 --> 42:41.460
para a URL, então retorne a palavra mocked data.

42:41.760 --> 42:48.060
Então, aqui embaixo, eu poderia me certificar de que estou obtendo o resultado esperado que quero, em vez de verificar

42:48.060 --> 42:52.020
que tem doctype no retorno como fiz anteriormente.

42:52.020 --> 42:55.740
Posso verificar os dados de simulação aqui.

42:55.740 --> 43:04.380
Portanto, o que estamos vendo aqui é um exemplo muito simples, que pode não parecer útil, mas imagine em um exemplo de

43:04.380 --> 43:11.580
exemplo mais complexo em que não estivéssemos apenas carregando dados, mas sim carregando-os, lendo, escrevendo, transformando

43:11.580 --> 43:14.850
os dados, fazendo bastante coisa, talvez uns 5 ou 6 métodos diferentes.

43:14.850 --> 43:21.150
Todos eles poderiam estar apontando para sistemas totalmente diferentes, mas quando realmente queremos testar apenas o

43:21.150 --> 43:30.330
o carregador de dados, então queremos passar habilidades simuladas para que esses outros sistemas sejam apenas temporariamente

43:30.330 --> 43:34.230
ignorados para que possamos nos concentrar apenas no que temos em mãos aqui.

43:34.260 --> 43:36.450
Agora vamos dar uma olhada no que aconteceria.

43:36.450 --> 43:38.940
Então eu chamo o load async.

43:38.940 --> 43:46.050
O que vai acontecer é que esse sistema interno vai retornar o valor previsto.

43:46.050 --> 43:50.220
E o carregador de dados será chamado de carregado.

43:50.220 --> 43:56.160
E seu valor de resultado será o valor que esperamos que seja.

43:56.160 --> 44:00.330
Então, vamos executar isso dentro do unity editor.

44:00.330 --> 44:01.800
Vamos clicar em run all aqui.

44:04.100 --> 44:05.480
E funciona bem rápido.

44:05.480 --> 44:11.270
Vamos comparar se eu apenas executar o load async, que na verdade está chamando um servidor.

44:15.200 --> 44:16.220
Foi rápido.

44:16.250 --> 44:20.690
Então, se eu chamar o mock load async que não está chamando nenhum servidor.

44:24.630 --> 44:29.840
Talvez não seja evidente no vídeo, mas é muito mais rápido chamar o MOC.

44:29.850 --> 44:35.150
E isso faz sentido porque não estamos realmente chamando um servidor e esperando por um resultado.

44:35.160 --> 44:38.640
Portanto, isso não é apenas para nos poupar alguns segundos.

44:38.670 --> 44:42.270
É mais uma vez para nos concentrarmos ao projetar nossos testes.

44:42.300 --> 44:44.790
O que de fato queremos testar?

44:44.790 --> 44:46.920
E então queremos isolá-lo.

44:46.920 --> 44:51.160
Portanto, não estamos realmente testando uma classe do Unity Web Services.

44:51.180 --> 44:53.610
Não estamos testando um back end do GitHub.

44:53.700 --> 44:57.470
O teste de vários sistemas juntos é chamado de teste de integração.

44:57.480 --> 44:59.550
Esse é um tipo apropriado de teste.

44:59.550 --> 45:03.660
Mas ele está fora do que estamos falando aqui, que é o teste de unidade.

45:03.660 --> 45:08.430
Mais uma vez, estamos reduzindo ao mínimo de dependências possível, poucas linhas de código.

45:08.430 --> 45:09.450
Você poderia pensar sobre isso.

45:09.450 --> 45:17.880
Então é isso, vimos como usar a biblioteca substituta e como também podemos fazer uma simulação para

45:17.880 --> 45:19.710
uma chamada para o servidor back-end.

45:19.710 --> 45:20.550
Então, obrigado.

45:26.450 --> 45:29.420
Olá e bem-vindo ao Unit testing for unity.

45:29.450 --> 45:30.710
Estamos no workshop aqui.

45:30.710 --> 45:34.850
Neste, vamos dar uma olhada no personagem em uma forma básica.

45:34.850 --> 45:37.070
Vamos dar uma olhada em alguns diferentes.

45:37.100 --> 45:39.800
Começaremos com o básico e passaremos para algo mais avançado.

45:39.800 --> 45:41.480
Vamos dar uma olhada nessa demonstração em ação.

45:41.480 --> 45:42.920
Dentro do unity editor.

45:42.920 --> 45:45.830
Vamos abrir o unity, abrir o nosso projeto de amostra.

45:45.830 --> 45:49.760
E depois vamos reproduzir uma ou mais cenas relacionadas ao tópico aqui.

45:49.760 --> 45:55.670
A cena será o personagem básico, e eu falarei sobre o Monobehaviour como algo

45:55.670 --> 46:01.160
que pode ou não ser testado, bem como o modo de reprodução versus o modo de edição, algo que já mencionei

46:01.160 --> 46:02.450
anteriormente no curso.

46:02.450 --> 46:04.010
Vamos trazê-lo de volta aqui e falar sobre isso.

46:04.010 --> 46:06.380
Aqui estamos no projeto, olhando para o caractere básico.

46:06.380 --> 46:07.760
Vamos prosseguir e executar a cena.

46:13.120 --> 46:20.020
Portanto, embora a maioria dos workshops que fizemos já tenha tido uma cena bem chata em que absolutamente nada

46:20.050 --> 46:22.830
de interesse estava acontecendo aqui, temos um pouco mais.

46:22.840 --> 46:28.470
Quando apertamos o play, vemos um cubo branco que é criado no centro da tela.

46:28.480 --> 46:31.030
Posso usar minhas teclas de seta e me movimentar.

46:31.030 --> 46:37.930
Portanto, embora o exemplo aqui seja reconhecidamente muito simples, o objetivo é falar sobre alguns dos aspectos mais complexos

46:37.930 --> 46:40.600
aspectos mais complexos dos testes dentro do unity.

46:40.630 --> 46:45.730
Nas cenas anteriores, não estávamos preocupados com a renderização de gráficos ou com a recepção de entrada.

46:45.970 --> 46:52.840
No último workshop, falamos sobre a diferença entre testar várias dependências diferentes

46:52.840 --> 46:53.590
juntas.

46:53.590 --> 46:58.780
Por exemplo, um método que dentro chama um segundo método que dentro chama um terceiro.

46:58.810 --> 47:00.490
Essas são dependências.

47:00.520 --> 47:06.790
Aqui estamos falando de um aspecto semelhante, exceto que toda vez que eu quero mover meu personagem, eu primeiro

47:06.790 --> 47:13.750
peço para ouvir o sistema de entrada do Unity, depois uso o movimento de transformação Monobehaviour do Unity.

47:13.750 --> 47:14.190
Certo.

47:14.200 --> 47:18.820
Portanto, estamos usando várias dependências diferentes ou classes diferentes.

47:21.360 --> 47:24.630
Aqui posso usar as teclas de seta para me movimentar.

47:25.750 --> 47:27.190
E é basicamente isso.

47:29.010 --> 47:32.100
Mas a ideia é que estamos fazendo um pouco mais do que antes.

47:32.190 --> 47:34.650
Vamos falar sobre as implicações de testar isso.

47:34.650 --> 47:41.190
Então, aqui em cima, no executor do teste, tenho a categoria definida para o nosso personagem básico, o que é ótimo.

47:41.220 --> 47:46.800
Depois, posso alternar para ver os testes do modo de jogo e os testes do modo de edição.

47:46.830 --> 47:53.100
Podemos ver que temos um pouco de ambos, mas como há um monocomportamento envolvido, eu vou

47:53.100 --> 47:54.600
me concentrar mais no modo play.

47:54.630 --> 48:01.230
Agora, em cada um dos workshops, eu incluí pelo menos um teste de modo de edição e pelo menos um modo de reprodução

48:01.260 --> 48:03.420
para a cena em questão.

48:03.450 --> 48:09.030
Eu fiz isso novamente aqui, mas dependendo do que você está testando, você deve pensar, é isso

48:09.030 --> 48:13.470
mais apropriado para o modo de edição ou mais apropriado para o modo de reprodução?

48:13.500 --> 48:18.510
Há uma arte e uma ciência em como você abordaria isso e como você projetaria seu código para ser mais

48:18.510 --> 48:19.170
testável.

48:19.200 --> 48:26.010
Mas uma maneira geral de ver isso, que é relevante aqui, é que se você estiver usando a funcionalidade Monobehaviour,

48:26.010 --> 48:32.460
que soa mais como um teste de modo de jogo, quanto mais bibliotecas de unidade, particularmente em tempo de execução, você estará

48:32.460 --> 48:36.840
usando em sua produção, você deve pensar nelas como testes de modo de jogo.

48:36.870 --> 48:40.410
Não é uma regra rígida, mas é uma boa maneira de começar a pensar nisso.

48:40.650 --> 48:42.490
Então, vamos executar nossos testes aqui.

48:42.510 --> 48:45.300
Tenho o modo play e vou executar todos.

48:48.880 --> 48:49.210
Certo.

48:49.240 --> 48:52.060
Demorou alguns segundos para executar, mas já temos todos eles.

48:52.090 --> 48:58.060
O que realmente acontece quando você está executando um teste de modo de reprodução é que ele cria uma nova cena vazia e

48:58.060 --> 49:01.840
executa apenas um teste dentro dela e a destrói.

49:01.840 --> 49:09.040
E cria uma cena totalmente nova, garantindo que temos o espaço mundial fornecido por uma cena.

49:09.040 --> 49:16.000
Mas o frescor de uma nova cena que não tem nenhuma dependência ou informação obsoleta que possa influenciar

49:16.000 --> 49:16.630
o teste.

49:16.630 --> 49:18.230
Então, gostamos de como isso está configurado.

49:18.250 --> 49:25.030
Agora, as coisas que estou fazendo são mover, mover por código de chave e mover para um lugar específico.

49:25.030 --> 49:27.640
Então, vamos dar uma olhada nesse movimento para testar.

49:29.650 --> 49:31.990
Na verdade, vamos dar uma olhada no código de produção primeiro.

49:31.990 --> 49:34.960
Então, se eu for aqui e der uma olhada no exemplo básico.

49:36.760 --> 49:38.560
Este é o código de produção.

49:38.560 --> 49:40.720
Vamos dar uma olhada nisso antes de passar para os testes.

49:40.720 --> 49:43.960
Aqui, tudo o que faço é criar uma primitiva.

49:43.990 --> 49:49.030
Você poderia imaginar também carregar um pré-fabricado aqui se quisesse fazer isso.

49:49.030 --> 49:54.010
Mas eu queria nos levar lentamente a todas as complexidades do tempo de execução e da unidade.

49:54.010 --> 49:56.140
Portanto, não estou usando um prefab aqui.

49:56.140 --> 50:00.130
Eu apenas crio um novo cubo do zero com uma linha de código.

50:00.130 --> 50:06.820
Eu lhe dou um nome apenas para fins de organização e, em seguida, adiciono o componente do monobehaviour

50:06.820 --> 50:08.620
que eu quero de fato testar.

50:08.650 --> 50:14.770
Uma das coisas que estou fazendo é movê-lo para o ponto 000 e depois mostrar que

50:14.770 --> 50:16.300
valor na tela.

50:16.300 --> 50:18.850
Então, vamos dar uma olhada no código-fonte aqui.

50:21.530 --> 50:22.960
Aqui está o caractere básico.

50:22.970 --> 50:24.770
Isso estende o Monobehaviour.

50:24.800 --> 50:32.730
Agora, se você está familiarizado com o unity, provavelmente usa Monobehaviours o tempo todo como uma boa prática recomendada.

50:32.750 --> 50:35.600
Você quer começar a pensar de forma consciente.

50:35.600 --> 50:40.660
Quando é apropriado usar um monocomportamento e quando posso usar algo diferente?

50:40.670 --> 50:46.580
Como desenvolvedores iniciantes, criamos tudo como um filho do monobehaviour, mas com o tempo e a experiência

50:46.580 --> 50:49.900
você percebe que há prós e contras em usar monocomportamentos.

50:49.910 --> 50:54.620
Um dos contras é que, historicamente, era mais difícil fazer testes ao longo do caminho.

50:54.620 --> 50:56.570
A Unity forneceu esses testes de modo de jogo.

50:56.570 --> 51:00.950
Então, agora podemos certamente testar o Playmode e podemos testar os Monobehaviours.

51:00.950 --> 51:03.630
Isso é ótimo, mas ainda há algumas desvantagens.

51:03.650 --> 51:08.330
Novamente, o Monobehaviour dependerá de mais sistemas de unidade sob o capô.

51:08.330 --> 51:13.700
E quando estivermos tentando testar o nosso código personalizado, talvez não tenhamos certeza de onde está o problema.

51:13.730 --> 51:15.720
É o nosso código ou é o código da Unity?

51:15.740 --> 51:18.110
Então, novamente, há algumas dependências aqui.

51:18.140 --> 51:22.280
Tudo isso está bem, mas é algo em que você deve pensar quando estiver projetando suas classes e como

51:22.280 --> 51:23.690
você estiver projetando seus testes.

51:24.110 --> 51:27.080
Portanto, temos uma velocidade de movimento.

51:27.110 --> 51:28.460
Temos um tipo de movimento.

51:28.460 --> 51:31.390
Esta é apenas a direção da tecla de seta que estou pressionando.

51:31.400 --> 51:33.680
Em seguida, usamos a atualização do Unity.

51:33.710 --> 51:36.530
Agora, deixe-me verificar novamente aqui.

51:38.720 --> 51:39.230
Realmente.

51:39.230 --> 51:44.960
O loop de atualização aqui é a única funcionalidade importante do monocomportamento que estou usando.

51:44.990 --> 51:49.130
O restante desse código não precisa necessariamente estar em um monobehaviour.

51:49.220 --> 51:53.560
Também estou usando o sistema de entrada do Unity, portanto, essa é uma segunda dependência.

51:53.570 --> 51:56.760
Então, vamos ver o que eu faço a cada quadro de atualização.

51:56.780 --> 51:59.360
Eu chamo esse método aqui de mover por entrada.

51:59.390 --> 52:04.340
Eu verifico se o usuário está pressionando uma tecla ou teclas específicas no teclado.

52:04.340 --> 52:08.360
E então eu chamo o movimento pelo código da tecla aqui embaixo.

52:09.710 --> 52:16.220
Tudo o que fazemos é dizer que, se estivermos nos movendo para a esquerda, então vamos nos mover em um vetor para a direção esquerda.

52:16.220 --> 52:19.820
Se estivermos nos movendo para a direita, etc., para cima e para baixo.

52:19.820 --> 52:24.860
Isso permite que você se mova em todas as quatro direções usando as quatro teclas de seta.

52:24.860 --> 52:26.420
Portanto, o código é bastante simples.

52:26.420 --> 52:30.440
E se você já criou seu próprio personagem personalizado antes, deve estar familiarizado com a configuração de algo como

52:30.440 --> 52:30.980
isso.

52:34.010 --> 52:35.870
Aqui embaixo, temos dois métodos.

52:35.870 --> 52:41.240
Um que nos permite mover para um ponto específico e outro que nos permite mover por uma unidade.

52:41.240 --> 52:44.090
Então, digamos que eu queira mover uma unidade para a direita.

52:44.090 --> 52:48.490
Eu poderia passar uma unidade por uma unidade por uma unidade por uma unidade.

52:48.500 --> 52:53.740
Se eu quiser me deslocar diretamente para um ponto específico no espaço, esse seria o movimento para.

52:53.750 --> 52:59.810
Portanto, esses não são necessariamente os únicos métodos de que você precisaria em uma classe de personagem personalizada, mas há

52:59.810 --> 53:01.100
alguns bastante comuns.

53:01.100 --> 53:07.850
Portanto, encerraremos esta lição apenas com isso, como uma forma básica e adequada de testar algumas funcionalidades.

53:07.850 --> 53:13.340
Se quiser dar uma olhada no modo de edição ou nos outros testes que estão aqui no modo de reprodução, vá em frente

53:13.340 --> 53:14.230
e faça isso.

53:14.240 --> 53:15.830
Vou passar para o próximo vídeo.

53:15.830 --> 53:16.580
Obrigado.

53:22.920 --> 53:26.060
Olá e bem-vindo ao Unit Testing for unity.

53:26.070 --> 53:30.060
Neste workshop, vamos examinar a classe de personagem em uma versão avançada.

53:30.060 --> 53:31.980
Vamos dar uma olhada nessa demonstração em ação.

53:31.980 --> 53:32.310
Aqui.

53:32.310 --> 53:33.990
Vamos abrir a nossa unidade.

53:34.020 --> 53:36.000
Vamos abrir o nosso projeto de amostra.

53:36.000 --> 53:41.190
E vamos dar uma olhada em uma cena interna para a situação avançada do personagem aqui.

53:41.190 --> 53:44.310
Quero falar um pouco sobre a separação de códigos.

53:44.340 --> 53:49.110
Anteriormente, em um dos workshops, falei sobre as diferentes dependências que você teria.

53:49.110 --> 53:51.360
Por exemplo, se você estiver chamando um servidor de back-end.

53:51.360 --> 53:58.530
E nessa situação, usamos uma biblioteca substituta para simular e não precisar chamar o back end.

53:58.560 --> 54:04.890
É uma discussão semelhante aqui, em que estamos analisando quais são as dependências envolvidas com um determinado

54:04.890 --> 54:11.640
cenário de teste específico e como podemos estar cientes dessas diferentes dependências, e o que queremos fazer a respeito?

54:11.640 --> 54:12.240
isso aqui?

54:12.240 --> 54:14.400
Não vamos usar a biblioteca substituta.

54:14.430 --> 54:18.960
Vamos pensar em separar o nosso monocomportamento de outro código e dar uma olhada.

54:19.170 --> 54:20.940
Então, aqui estamos dentro da unidade.

54:21.270 --> 54:22.440
Temos uma classe de produção.

54:22.440 --> 54:23.250
Vamos dar uma olhada nela.

54:23.250 --> 54:23.850
Em execução.

54:27.540 --> 54:30.510
Aqui embaixo, vemos que podemos nos movimentar com as teclas de seta.

54:30.510 --> 54:34.050
Assim como no exemplo básico, a experiência do usuário final é a mesma.

54:34.050 --> 54:39.330
E esse é um exemplo interessante, pois algumas das alterações que fazemos no código

54:39.330 --> 54:44.250
qualidade do código e testabilidade dos nossos sistemas não afetam necessariamente o usuário final.

54:44.280 --> 54:45.350
Isso é positivo.

54:45.360 --> 54:48.270
Então, vamos dar uma olhada no código de produção aqui.

54:48.270 --> 54:50.340
Vamos abrir o exemplo avançado do personagem.

54:50.340 --> 54:51.890
Aqui está um exemplo completo.

54:51.900 --> 54:57.830
O que estamos fazendo dentro da esteira dessa classe de exemplo é criar uma primitiva para o cubo.

54:57.840 --> 55:00.270
Damos a ele um nome para fins de organização.

55:00.390 --> 55:08.010
Então, em vez de uma linha aqui onde apenas adicionamos um componente que tem toda a nossa funcionalidade, fazemos

55:08.010 --> 55:09.180
duas etapas.

55:09.450 --> 55:14.700
Isso me lembra um pouco a injeção de dependência que vimos no exemplo do My Data loader.

55:14.700 --> 55:17.970
Mas este é um caso de uso diferente com dependências diferentes.

55:17.970 --> 55:22.920
Portanto, em vez de apenas uma linha de adição de componente, fazemos a adição de componente.

55:22.920 --> 55:28.260
E então criamos nossa própria classe avançada de caráter não monocomportamental.

55:28.260 --> 55:30.540
E passamos o Monobehaviour.

55:30.540 --> 55:35.370
Então, estamos passando a dependência que o personagem avançado vai usar.

55:35.400 --> 55:41.910
Agora, o caractere avançado não é um monocomportamento e, portanto, temos mais flexibilidade na forma como queremos

55:41.910 --> 55:42.480
testá-lo.

55:42.510 --> 55:45.780
Poderíamos testá-lo no modo de edição, por exemplo, com mais facilidade.

55:45.930 --> 55:51.000
Novamente, sempre que estiver usando Monobehaviours, isso é mais apropriado para testes no modo de reprodução.

55:51.030 --> 55:53.940
Não é uma regra rígida, mas essa é uma maneira de pensar sobre isso.

55:53.940 --> 56:00.660
Portanto, aqui, ao separar o nosso monocomportamento do nosso não monocomportamento, temos mais algumas opções.

56:00.690 --> 56:06.060
Agora ainda estamos aqui em um ambiente de modo play play porque este é o código de produção.

56:06.060 --> 56:08.970
Vamos entrar e ver como o nosso código-fonte foi alterado.

56:08.970 --> 56:11.010
Então, aqui estamos no caractere avançado.

56:11.040 --> 56:13.220
Você verá que ele parece bastante familiar.

56:13.230 --> 56:17.790
A maior parte do código aqui será igual ao do exemplo básico anterior.

56:17.800 --> 56:19.080
As poucas exceções.

56:19.090 --> 56:25.710
Uma delas é que o caractere avançado vai receber uma referência em seu construtor para o Monobehaviour.

56:25.710 --> 56:30.900
Isso ocorre porque ele precisa saber algumas coisas sobre o Monobehaviour, particularmente sobre sua transformação

56:30.900 --> 56:31.710
posição.

56:31.830 --> 56:38.400
Há também uma situação em que precisamos usar a segunda linha e informar ao Monobehaviour uma referência

56:38.400 --> 56:40.830
de volta para nós como o caractere avançado.

56:40.860 --> 56:47.460
Isso é apenas para que o Monobehaviour, sempre que chamar a atualização, possa nos dizer para fazer o movimento adequado.

56:47.490 --> 56:52.950
Há outras maneiras de organizar isso, mas, para simplificar, estamos passando o monobehaviour

56:52.950 --> 56:54.360
e tratando-o dessa forma.

56:54.660 --> 56:57.150
Vamos ver que outras alterações vemos na base de código.

56:58.510 --> 57:00.820
O tipo de movimento é o mesmo que o básico.

57:00.850 --> 57:03.040
A movimentação por entrada é a mesma.

57:03.940 --> 57:08.260
Aqui embaixo, a movimentação por código de tecla é muito semelhante, se não idêntica.

57:09.300 --> 57:15.630
E aqui embaixo, em mover para e mover por, você pode notar que estamos obtendo e definindo a posição

57:15.630 --> 57:18.300
na transformação do Monobehaviour.

57:18.300 --> 57:25.260
Então, mais uma vez, temos aqui uma classe não monobehaviour fazendo o que pode fazer sem qualquer dependência de

57:25.260 --> 57:30.810
monobehaviour e somente nos pontos mais necessários ela se dirige ao Monobehaviour.

57:30.840 --> 57:36.840
Essa separação começa a nos ajudar a pensar em como poderíamos testar apenas o monocomportamento se pudéssemos,

57:36.840 --> 57:39.910
como poderíamos testar apenas o não monocomportamento se pudéssemos?

57:39.930 --> 57:45.240
Agora, esse não é um exemplo perfeito porque é uma espécie de passo intermediário à medida que estamos aprendendo sobre

57:45.240 --> 57:47.040
como podemos separá-los adequadamente.

57:47.040 --> 57:48.600
Mas acho que é um bom aprendizado.

57:48.600 --> 57:52.500
Então, dê uma olhada no código-fonte aqui para o caractere avançado.

57:52.500 --> 57:56.550
Compare-o com o character basic em seu próprio tempo e veja as diferenças.

57:56.730 --> 57:59.580
Em seguida, vamos dar uma olhada no exemplo que fizemos.

57:59.580 --> 57:59.970
Novamente.

57:59.970 --> 58:01.500
Aqui está o exemplo que vimos.

58:01.500 --> 58:02.670
Portanto, são essas duas linhas.

58:02.670 --> 58:03.900
Essa é realmente a chave.

58:03.930 --> 58:09.960
Vamos adicionar um componente do Monobehaviour avançado de personagem ao nosso objeto de jogo.

58:09.960 --> 58:12.270
E então vamos criar um novo personagem avançado.

58:12.270 --> 58:13.440
Esse é um passo separado.

58:13.440 --> 58:17.010
Portanto, você poderia imaginar que poderíamos testar essas duas coisas isoladamente.

58:17.010 --> 58:19.320
Agora eles são bastante dependentes um do outro.

58:19.350 --> 58:24.000
Há maneiras de modificar isso para que um não dependa diretamente do outro.

58:24.000 --> 58:30.330
Ou poderíamos fazer algo como fizemos no exemplo do carregador de dados e usar uma biblioteca substituta para que

58:30.330 --> 58:32.730
em vez disso, estamos simulando a dependência.

58:32.730 --> 58:38.400
Mas, novamente, para simplificar o aprendizado de como separar um monocomportamento, acho que fizemos

58:38.400 --> 58:39.210
o caso aqui.

58:39.210 --> 58:44.100
Você pode executar esses testes com o modo de edição e o modo de reprodução no seu tempo livre e dar uma olhada nisso.

58:44.370 --> 58:50.460
Mas, para mim, acho que já terminamos de falar sobre as diferenças na separação entre monocomportamento e não monocomportamento.

58:50.490 --> 58:51.120
Obrigado.

58:57.320 --> 58:59.600
Olá e bem-vindo ao Unit Testing for unity.

58:59.630 --> 59:02.630
Este é o nosso workshop falando sobre a física dos personagens.

59:02.660 --> 59:09.110
Nos workshops anteriores, passamos lentamente de um exemplo de personagem muito simples, movendo-se com a seta

59:09.110 --> 59:14.960
para o exemplo avançado que separa as preocupações monocomportamentais e não monocomportamentais.

59:14.960 --> 59:20.900
E aqui, neste exemplo, vamos falar sobre o que aconteceria se dependêssemos de outro sistema de unidade, como a física.

59:20.900 --> 59:26.720
Além disso, quando usamos a física neste exemplo específico, nosso movimento se torna mais confuso.

59:26.720 --> 59:30.890
Isso significa que eu não clico na esquerda e ele imediatamente clica em uma posição.

59:30.890 --> 59:32.930
Ele se move lentamente ao longo do tempo.

59:32.930 --> 59:37.100
Como poderíamos testar o valor que está mudando lentamente com o tempo?

59:37.100 --> 59:40.220
Portanto, falaremos sobre algumas dessas coisas aqui no código-fonte.

59:40.220 --> 59:45.290
Para dar uma olhada nessa demonstração, vamos abrir o nosso unity editor e o projeto de amostra.

59:45.290 --> 59:48.020
A cena aqui será a cena de física do personagem.

59:48.020 --> 59:51.720
E uma das coisas que vamos examinar é como testar esses valores difusos.

59:51.740 --> 59:58.640
Chamei de novo, valores difusos para mim são valores que não são necessariamente instantâneos, mudando de

59:58.640 --> 1:00:05.960
A para B, eles são animados lentamente ao longo do tempo, como a posição de um objeto ou uma pontuação que gradualmente

1:00:05.960 --> 1:00:06.890
aumenta a contagem.

1:00:06.920 --> 1:00:12.110
Todas essas são áreas em que você gostaria de poder testar algo ao longo do tempo, e temos uma abordagem fácil

1:00:12.110 --> 1:00:13.250
aqui para fazer isso.

1:00:13.250 --> 1:00:17.750
Não é a única maneira de resolver o problema, mas acho que nos ajuda a aprender ao longo do caminho.

1:00:17.750 --> 1:00:18.770
Então vamos dar uma olhada.

1:00:18.770 --> 1:00:20.420
Então, aqui estamos no projeto unity.

1:00:20.420 --> 1:00:22.940
Temos o exemplo de física de personagem aberto.

1:00:22.940 --> 1:00:24.500
Vamos prosseguir e executar a cena.

1:00:30.610 --> 1:00:33.520
Agora, posso me mover usando as teclas de seta.

1:00:37.390 --> 1:00:42.970
E em exemplos anteriores aqui no workshop, vimos que ele clica sobre cada clique que fiz à esquerda

1:00:42.970 --> 1:00:48.430
a posição do clique mudava instantaneamente, mas aqui há um movimento mais suave.

1:00:49.060 --> 1:00:54.250
Ainda posso usar todas as teclas de seta para direcionar o tráfego diferente para onde ele deve ir, mas a ideia

1:00:54.250 --> 1:00:58.030
de se mover lentamente ao longo do tempo é realmente a nova situação agora.

1:00:58.030 --> 1:01:03.790
Há muitas maneiras de fazer isso no unity, mas optei por usar o sistema de física apenas para falar

1:01:03.790 --> 1:01:08.920
um pouco sobre o que acontece se tivermos mais alguns sistemas de unidade envolvidos.

1:01:08.920 --> 1:01:10.960
Você se lembra do que estamos fazendo?

1:01:10.960 --> 1:01:18.130
A ideia aqui é que, em um mundo ideal, os testes unitários testem o menor número de linhas de

1:01:18.130 --> 1:01:21.760
dependência, o menor número de linhas de código de uma só vez.

1:01:21.760 --> 1:01:25.600
Mas muitas vezes nosso código de produção não é tão simplista.

1:01:25.600 --> 1:01:27.520
Estamos dependendo de coisas diferentes.

1:01:27.520 --> 1:01:33.370
Portanto, com o meu carregador de dados e com os exemplos de caracteres anteriores aqui, vimos algumas maneiras de lidar com

1:01:33.370 --> 1:01:35.080
essas diferentes dependências.

1:01:35.200 --> 1:01:38.260
Este é mais um exemplo um pouco mais complexo que os demais.

1:01:38.290 --> 1:01:40.240
Vamos dar uma olhada no código de produção aqui.

1:01:40.240 --> 1:01:43.120
Vamos dar uma olhada no exemplo da física do personagem.

1:01:44.530 --> 1:01:45.790
Vamos abrir isso?

1:01:47.210 --> 1:01:50.570
E aqui temos a criação de um personagem primitivo.

1:01:51.320 --> 1:01:59.840
Aqui criamos o objeto de jogo primeiro com o cubo na aparência da primitiva e depois adicionamos

1:01:59.840 --> 1:02:03.500
o componente do monocomportamento de física do personagem.

1:02:03.500 --> 1:02:07.070
E então temos uma classe de física de personagem separada que levamos para lá.

1:02:07.070 --> 1:02:12.740
Portanto, já estamos nos separando de uma classe monolítica de monocomportamento em duas.

1:02:12.740 --> 1:02:18.350
Portanto, essa é uma boa maneira de simplificar o nosso código e fazer um único propósito em cada um deles.

1:02:18.350 --> 1:02:25.640
Vimos no exemplo anterior que a maior parte da funcionalidade do Monobehaviour de que precisávamos era apenas a atualização.

1:02:25.640 --> 1:02:27.680
Essa é a única coisa de que realmente precisamos cuidar.

1:02:27.710 --> 1:02:33.110
Portanto, ao mover todas as coisas que não são de atualização para a segunda classe, agora temos algo que é mais fácil de

1:02:33.110 --> 1:02:33.740
testar.

1:02:36.450 --> 1:02:39.570
Então, neste exemplo simples, nós nos movemos para uma posição específica.

1:02:39.600 --> 1:02:43.710
Agora vamos executar os testes e dar uma olhada no código de produção.

1:02:43.740 --> 1:02:46.500
Então, vamos dar uma olhada na execução do selecionado.

1:02:48.580 --> 1:02:49.830
Está tudo funcionando lá.

1:02:49.850 --> 1:02:50.850
Tudo passa.

1:02:50.870 --> 1:02:52.640
Agora é só o teste do modo de jogo.

1:02:52.640 --> 1:02:57.110
Mas também temos testes de modo de edição se você quiser se aprofundar e dar uma olhada novamente, porque estamos

1:02:57.110 --> 1:02:58.950
lidando com coisas de monocomportamento.

1:02:58.970 --> 1:03:01.340
Parece mais apropriado usar um modo play.

1:03:01.340 --> 1:03:02.990
Então, essa é a abordagem que eu fiz aqui.

1:03:02.990 --> 1:03:06.470
Mas cabe a você e ao seu projeto decidir quais sistemas deseja testar.

1:03:06.500 --> 1:03:08.230
Modo de edição e quais você deseja testar.

1:03:08.240 --> 1:03:08.840
Modo de reprodução.

1:03:15.570 --> 1:03:21.000
Agora que já vimos esses testes, vamos dar uma olhada rápida no código-fonte da classe.

1:03:21.000 --> 1:03:22.660
E depois vamos dar uma olhada em alguns dos testes no topo.

1:03:22.710 --> 1:03:22.860
Muito bem.

1:03:22.860 --> 1:03:24.780
Então, aqui estamos na física do personagem.

1:03:24.810 --> 1:03:28.870
Veremos que ela é bem parecida com a do personagem avançado que vimos anteriormente.

1:03:28.890 --> 1:03:32.850
Novamente, separamos a classe Monobehaviour e a classe não monobehaviour.

1:03:32.850 --> 1:03:36.630
Então, aqui está a classe não monocomportamental que está fazendo a maior parte do trabalho.

1:03:36.660 --> 1:03:42.840
Observe que aqui, dentro de seu construtor, ele pega uma referência ao Monobehaviour e a armazena e então

1:03:42.840 --> 1:03:47.670
também passa para o Monobehaviour uma referência a essa classe aqui.

1:03:47.670 --> 1:03:51.900
Isso é para que ele possa chamar o move by toda vez que fizer uma atualização.

1:03:51.930 --> 1:03:53.970
Agora, há diferentes maneiras de organizar isso.

1:03:53.970 --> 1:03:57.810
Você poderia até mesmo remover a dependência codificada que temos uns dos outros aqui.

1:03:57.810 --> 1:04:01.350
Mas, por uma questão de simplicidade neste exemplo, isso é muito apropriado.

1:04:01.740 --> 1:04:02.790
Descendo o código.

1:04:02.790 --> 1:04:05.820
Novamente, é como o avançado na maior parte.

1:04:05.850 --> 1:04:08.670
Quero destacar onde a física está sendo usada.

1:04:08.670 --> 1:04:16.920
Então, aqui no movimento, em vez de apenas mover-se pela posição codificada em uma instância de atualização Taneous,

1:04:16.950 --> 1:04:20.340
vamos usar a posição de movimentação aqui.

1:04:20.340 --> 1:04:25.890
E, em seguida, em Add force, que é um novo método que eu criei e que vai se mover com base na física

1:04:25.890 --> 1:04:26.580
forças.

1:04:26.580 --> 1:04:30.630
Imagine que se trata de um bloco e que estamos empurrando um dos lados.

1:04:30.630 --> 1:04:36.390
E então, com base no atrito, na massa e na gravidade, você sabe que há algum tipo de consequência que tende a

1:04:36.390 --> 1:04:39.240
a ser uma reação mais confusa aqui usando a força adicional.

1:04:39.240 --> 1:04:45.570
E estamos nos movendo por add force aqui em cima, no topo do mesmo arquivo de classe, vemos o monocomportamento de física

1:04:45.600 --> 1:04:46.590
é declarado.

1:04:46.590 --> 1:04:52.560
Isso é bastante familiar, pois o mesmo caractere avançado que vimos no último workshop é bastante semelhante,

1:04:52.560 --> 1:04:55.350
mas temos um corpo rígido aqui que estamos armazenando.

1:04:55.350 --> 1:05:02.010
E quando essa classe é ativada, anexamos o corpo rígido e definimos a física

1:05:02.010 --> 1:05:02.670
valores.

1:05:02.670 --> 1:05:09.450
Então, se pensarmos em apenas recapitular, em vez de ter um monocomportamento que faça toda a física

1:05:09.450 --> 1:05:14.220
e o movimento juntos, nós separamos o monocomportamento do não monocomportamento.

1:05:14.250 --> 1:05:20.520
Em seguida, dentro do Monobehaviour, fazemos o loop de atualização e também cuidamos de algumas coisas de física.

1:05:20.610 --> 1:05:26.550
Depois, a partir do outro, o não monobehaviour, podemos nos mover como quisermos e receber a entrada do personagem,

1:05:26.580 --> 1:05:28.470
portanto, receber entrada de teclado e coisas do gênero.

1:05:28.470 --> 1:05:32.940
Portanto, essa é uma separação muito boa e nos leva ao que precisamos.

1:05:34.100 --> 1:05:37.820
Deixe-me pensar em voz alta se há algo mais que eu queira mencionar sobre isso.

1:05:38.330 --> 1:05:40.430
Hum, sim.

1:05:40.430 --> 1:05:42.620
Então, eu falei sobre a ideia aqui.

1:05:42.620 --> 1:05:50.720
Se você quiser reduzir a dependência codificada que temos de cada classe dependendo uma da outra e

1:05:50.720 --> 1:05:56.270
obter mais da flexibilidade que vimos no exemplo do carregador My Data, você certamente poderia declarar

1:05:56.270 --> 1:05:58.670
interfaces e abordá-las dessa forma.

1:05:58.970 --> 1:06:00.680
Mas não precisamos fazer isso aqui.

1:06:00.680 --> 1:06:03.370
Vamos voltar e executar o exemplo mais uma vez.

1:06:03.380 --> 1:06:07.700
Então, aqui na unidade, estamos rodando e temos as teclas de seta se movendo.

1:06:07.730 --> 1:06:13.130
Nos últimos vídeos, vimos exemplos de redução da complexidade.

1:06:13.130 --> 1:06:17.870
Assim, reduzindo as diferentes dependências, temos alguma flexibilidade para separar nosso código.

1:06:17.870 --> 1:06:23.480
Então, para este exemplo aqui, usando entrada e física e monocomportamentos ou coisas do gênero, eu

1:06:23.480 --> 1:06:24.620
acho que já terminamos aqui.

1:06:24.650 --> 1:06:25.340
Obrigado.

1:06:31.470 --> 1:06:31.730
Hi.

1:06:31.740 --> 1:06:37.470
Isso abrange muitos dos diferentes tópicos que eu queria incluir no workshop até agora, mas ainda há

1:06:37.470 --> 1:06:39.990
muito espaço para mais tópicos no futuro.

1:06:39.990 --> 1:06:42.390
Vimos nos workshops abordados até agora.

1:06:42.390 --> 1:06:49.350
Este é o exemplo mais simples de aprendizado do test runner, vendo como podemos fazer testes no modo playmode, testes no modo edit,

1:06:49.380 --> 1:06:54.870
aprendendo um pouco sobre as diferenças entre o modo de reprodução e o modo de edição, e por que você gostaria de testar

1:06:54.870 --> 1:06:57.350
em um ou outro, ou em ambos.

1:06:57.360 --> 1:07:03.510
Depois, também vimos algumas das opções que temos quando temos uma funcionalidade assíncrona ou quando estamos

1:07:03.510 --> 1:07:05.460
dependentes de outros sistemas.

1:07:05.460 --> 1:07:09.990
O que poderíamos fazer para reduzir essa dependência para o bem do teste?

1:07:10.020 --> 1:07:15.180
Ao longo do caminho, estamos aprendendo algumas coisas diferentes sobre injeção de dependência e separação

1:07:15.180 --> 1:07:16.650
as preocupações do nosso código.

1:07:16.680 --> 1:07:22.710
De qualquer forma, esses princípios são úteis no código de produção, e estamos começando a ver algumas das maneiras

1:07:22.710 --> 1:07:29.850
que, quando preparamos o código para ser mais testável, também estamos criando um código bem projetado

1:07:29.850 --> 1:07:31.080
para produção.

1:07:31.080 --> 1:07:37.710
Portanto, a injeção de dependência permite flexibilidade que pode ser usada em tempo de execução, reduzindo a complexidade

1:07:37.710 --> 1:07:44.370
de seus sistemas, passando variedades flexíveis de dependências diferentes quando necessário.

1:07:44.400 --> 1:07:51.960
Também vimos que ao separar um grande monocomportamento monolítico em apenas o que precisamos do monocomportamento

1:07:51.960 --> 1:07:58.620
e movendo o outro código para uma classe mais leve e não monocomportamental, obtemos novamente alguma flexibilidade

1:07:58.620 --> 1:08:03.570
que é útil na produção e também nos ajuda aqui no mundo dos testes.

1:08:03.570 --> 1:08:10.170
Acho que, no geral, alguns dos desafios que estamos vendo são o que acontece quando você tem várias dependências

1:08:10.200 --> 1:08:14.670
ou muitos sistemas chamados a partir de um método específico.

1:08:15.060 --> 1:08:20.700
Isso pode ser um sinal de que o método está inchado e fazendo coisas demais, ou pode ser um sinal de que ele é

1:08:20.700 --> 1:08:23.130
um método enxuto e com design apropriado.

1:08:23.130 --> 1:08:28.800
Mas precisamos ter alguns pensamentos e considerações adicionais quando formos testar essa funcionalidade.

1:08:28.800 --> 1:08:31.050
Espero que isso tenha sido útil para você.

1:08:31.050 --> 1:08:38.130
Espero abordar ainda mais tópicos nesta série e eles serão adicionados novamente ao longo de

1:08:38.130 --> 1:08:38.610
tempo.

1:08:38.610 --> 1:08:39.750
Então, mais uma vez, obrigado.
