WEBVTT

00:00.410 --> 00:03.080
Olá e bem-vindo à Inteligência Artificial.

00:03.080 --> 00:07.700
Aqui estamos usando inteligência artificial para nos ajudar a criar código de teste de unidade.

00:07.700 --> 00:12.530
Agora, a incorporação da IA no desenvolvimento de jogos pode agilizar o desenvolvimento e os testes.

00:12.530 --> 00:17.480
Alguns dos benefícios estão incluídos aqui, e vamos nos concentrar nos testes automatizados.

00:17.780 --> 00:23.060
A IA pode identificar e corrigir rapidamente seus bugs e pode reduzir o tempo de criação de testes.

00:23.060 --> 00:28.580
Agora, a abordagem tradicional, sem nenhuma IA, seria criar o código de produção.

00:28.580 --> 00:34.040
E então, se você for adotar os testes unitários, criar manualmente esses testes à medida que avança.

00:34.070 --> 00:40.430
Vimos no vídeo anterior como a IA pode nos ajudar a criar o nosso código de produção para alguns ou todos os testes de uma aplicação.

00:40.430 --> 00:41.060
sistema de jogo.

00:41.060 --> 00:47.000
Agora vamos dar uma olhada em como a IA pode nos ajudar a automatizar o processo de criação dos nossos testes de unidade.

00:47.000 --> 00:52.160
Temos um chat GPT existente, aberto com a forma como criamos o código de produção.

00:52.160 --> 00:58.070
Agora é muito importante que eu continue exatamente nesse mesmo chat quando começar a fazer as próximas perguntas

00:58.070 --> 00:59.450
sobre testes unitários.

01:00.370 --> 01:06.670
Se, por exemplo, eu quisesse criar um bate-papo totalmente novo aqui, precisaria reintroduzir o contexto,

01:06.670 --> 01:12.190
talvez dizendo, ei, você pode me criar um teste unitário para essa classe e depois colar a classe ou

01:12.190 --> 01:13.440
classes que estão relacionadas?

01:13.450 --> 01:16.030
Mas como já temos o contexto aqui, vou usar isso.

01:16.030 --> 01:23.680
Portanto, na seção anterior, criei um exemplo aqui de uso de uma classe de gerente de produto, adicionando

01:23.680 --> 01:24.820
alguns produtos a ela.

01:24.820 --> 01:31.390
Você poderia imaginar isso como um produto sendo vendido em uma loja de jogos, ou um personagem NPC que tem uma loja

01:31.390 --> 01:35.590
que talvez lhe dê itens ou os coloque em seu inventário, algo assim.

01:35.590 --> 01:40.870
E acima disso, no mesmo chat, temos o I create us, o próprio gerenciador de produtos.

01:40.870 --> 01:44.490
Portanto, o gerente de produto criou um I e o exemplo em cima dele.

01:44.500 --> 01:46.680
Agora vamos pedir a ele que nos forneça alguns testes.

01:46.690 --> 01:51.880
O que vou fazer é colar um teste de modo de edição que já tenho para que ele conheça o namespace

01:51.880 --> 01:56.200
e a nomenclatura de que gosto e, em seguida, pedir que ele o preencha com testes relevantes.

01:56.200 --> 01:57.700
Vamos ver como isso se comporta aqui.

01:57.700 --> 02:02.080
Dentro da unidade, tenho um teste I e um teste playmode.

02:02.110 --> 02:04.660
Vamos fazer o teste do modo de edição aqui.

02:04.660 --> 02:05.740
Então aqui está.

02:05.740 --> 02:09.610
Aqui podemos ver que há um teste chamado meu teste.

02:09.640 --> 02:11.620
Abrimos o código fonte e o vemos aqui.

02:11.620 --> 02:13.480
Ele tem o namespace que eu gosto.

02:13.480 --> 02:16.090
Tem usos que eu presumo que sejam a categoria.

02:16.090 --> 02:21.640
Portanto, em vez de pedir ao ChatGPT para nos criar algo do zero, vou lhe dar isto

02:21.640 --> 02:22.180
aqui.

02:24.160 --> 02:26.620
Acho que vou me livrar da nomenclatura aqui.

02:27.370 --> 02:29.290
Para que eu não sugira essa parte.

02:29.320 --> 02:32.710
Então, aqui no ChatGPT, eu vou dizer ótimo.

02:32.740 --> 02:40.150
Agora quero fazer o teste unitário em cima da classe Product Manager.

02:40.600 --> 02:49.540
Crie uma nova resposta com uma classe de teste com um ou mais métodos de teste.

02:52.090 --> 02:54.490
Comece com este código.

02:55.490 --> 02:57.050
Vamos dar uma olhada na resposta.

02:57.050 --> 03:02.630
Para criar testes de unidade para a classe Product Manager, você pode usar qualquer estrutura de teste popular de unidade

03:02.630 --> 03:02.780
para.

03:02.990 --> 03:03.500
Net.

03:03.530 --> 03:05.930
Abaixo está um exemplo da classe de teste.

03:07.070 --> 03:13.730
Podemos ver que ele usou o namespace, os comentários, o nome da categoria de teste, tudo o que eu dei

03:13.730 --> 03:14.060
ele.

03:14.090 --> 03:16.850
Depois, ele faz o resto por conta própria.

03:16.880 --> 03:19.880
Agora, uma coisa que noto é que ele está criando um.

03:20.900 --> 03:26.270
Ele está criando uma variável aqui que será preenchida na configuração e talvez seja removida mais tarde.

03:26.270 --> 03:27.800
Na verdade, ele não faz o desmantelamento.

03:28.100 --> 03:33.470
Então, o que ele faz em cada um dos testes é usar o arrange, act e assert, o que acontece

03:33.470 --> 03:35.090
para corresponder à minha preferência particular.

03:35.090 --> 03:41.390
Por isso, gosto do fato de que ele estava apenas supondo que, com base na popularidade como uma solução geral, se de alguma forma

03:41.390 --> 03:45.140
Eu tivesse uma maneira diferente de fazer isso, eu poderia instruir isso.

03:45.140 --> 03:46.550
Mas estou gostando disso até agora.

03:46.550 --> 03:52.970
Assim, ele configura o produto de teste, adiciona o produto e depois se certifica de que o produto get retorna

03:52.970 --> 03:54.410
esse produto específico.

03:54.410 --> 03:55.760
Então, isso parece bom.

03:55.760 --> 03:57.740
Em seguida, ele testa como remover um produto.

03:57.740 --> 04:01.100
Então ele vai para criar um produto e adicioná-lo.

04:01.100 --> 04:06.170
Em seguida, removê-lo e certificar-se de que ele realmente funcionou lá.

04:06.170 --> 04:11.540
E que não há esse produto nele dessa forma.

04:11.570 --> 04:13.790
Get products, retorna todos os produtos.

04:13.790 --> 04:16.130
Portanto, ele faz dois e conhece dois.

04:16.130 --> 04:21.230
Agora, este seria um ótimo passo para eu colar isso na unidade e ter certeza de que funciona.

04:21.230 --> 04:22.280
Vou fazer isso.

04:22.280 --> 04:27.800
E depois voltarei e pensarei se há outro teste que possa ser adicionado ou se há algum refatoramento

04:27.800 --> 04:30.500
no código que poderíamos fazer apenas para brincar um pouco mais com ele?

04:30.500 --> 04:31.820
Mas eu gosto do rumo que isso está tomando.

04:31.820 --> 04:33.200
Então vamos colar isso no unity.

04:33.230 --> 04:37.820
Salve-o dentro do unity, parece que ele compila e dentro do unity parece que está rodando.

04:37.820 --> 04:38.990
Vamos executar o teste.

04:40.910 --> 04:42.200
Todos os testes foram aprovados.

04:42.230 --> 04:43.010
Agora.

04:43.730 --> 04:45.590
Os nomes dos testes que ele nos deu.

04:45.590 --> 04:45.890
Ótimo.

04:45.890 --> 04:51.110
Não corresponde ao meu estilo particular e eu posso decidir neste momento, adotar o que me dá

04:51.110 --> 04:52.730
ou sugerir uma diferença.

04:52.730 --> 04:58.040
Então, só para brincar com a ideia aqui, vou sugerir que se use um esquema de nomes ligeiramente diferente.

04:58.040 --> 05:01.610
Mas adoro o teste que me deu e adoro o fato de todos eles terem sido aprovados.

05:01.610 --> 05:03.530
Então, estamos indo muito bem até agora.

05:03.530 --> 05:08.390
Vamos voltar e brincar com a ideia de dar uma pequena sugestão e ver como ela funciona mais uma vez

05:08.390 --> 05:08.780
tempo.

05:08.780 --> 05:11.900
Então, vamos dizer a ele o que funciona bem.

05:11.900 --> 05:16.960
Isso funciona, compila e todos os testes passam.

05:16.970 --> 05:25.790
No entanto, não gosto da nomenclatura do método de teste, portanto, mude para o formato de adicionar produto.

05:25.790 --> 05:28.880
Adicionar produtos à lista para um novo formato como Adicionar produto.

05:28.910 --> 05:32.510
Obter produtos que contenham produtos quando o produto for adicionado.

05:33.080 --> 05:38.930
Em geral, gosto de seguir algo como o método em teste, o resultado esperado e, em seguida, quando

05:38.930 --> 05:43.970
essa coisa específica acontece, às vezes a nomeação fica um pouco longa, como mostrado aqui.

05:43.970 --> 05:45.650
Às vezes não é o mais claro.

05:45.650 --> 05:47.240
Depende muito do contexto.

05:47.240 --> 05:52.100
Mas, além disso, o que estou mostrando aqui é que gosto da maior parte do que o ChatGPT me deu.

05:52.100 --> 05:53.990
Mas quero sugerir uma alteração.

05:53.990 --> 05:57.200
Então, vamos usar isso como alteração e ver o resultado que obtemos.

05:57.230 --> 05:58.520
Vamos dar uma olhada no resultado.

05:58.520 --> 06:01.040
Ele diz que certamente a renomeação parece boa.

06:01.070 --> 06:06.110
Ele menciona que está inferindo método, nome, condição, resultado esperado.

06:06.230 --> 06:09.530
Na verdade, acho que o resultado esperado e depois a condição.

06:09.530 --> 06:11.660
Mas vamos dar uma olhada nos resultados aqui.

06:11.660 --> 06:14.270
Mais uma vez, admito que isso é muito longo.

06:14.270 --> 06:18.170
Mas add product get products contém o produto.

06:18.170 --> 06:20.480
Quando o produto é adicionado, ótimo.

06:20.510 --> 06:21.710
Aqui está um ainda mais longo.

06:21.710 --> 06:23.240
Obter produto não.

06:23.270 --> 06:28.100
Agora você pode argumentar que esse não é o melhor esquema de nomenclatura, pois estou vendo esse nome longo aqui,

06:28.100 --> 06:32.690
Estou pensando, ei, talvez não seja uma boa opção, mas o que vimos é que somos capazes de nos recuperar

06:32.690 --> 06:37.790
e dar um pouco de sugestão e ver que o ChatGPT funciona bem.

06:37.790 --> 06:41.300
Então, vamos copiar isso para a unidade e ver como funciona.

06:41.300 --> 06:42.110
Então, aqui estamos.

06:42.110 --> 06:42.800
Está no unity.

06:42.800 --> 06:43.520
Está compilado.

06:43.520 --> 06:44.810
E vamos executar os testes.

06:47.350 --> 06:48.850
E tudo parece bem aqui.

06:48.850 --> 06:54.490
Portanto, vimos um caso de uso fantástico de inteligência artificial, não apenas para tornar o código de produção tão

06:54.490 --> 06:59.200
como fizemos na lição anterior, mas também para criar novos testes de unidade em cima desse código de produção.

06:59.200 --> 07:05.440
Aqui, pelo menos em nossa demonstração simples, vimos que a unidade compilou o código todas as vezes sem problemas,

07:05.440 --> 07:07.350
e todos os nossos testes foram aprovados.

07:07.360 --> 07:11.110
Se você descobrir que o código não foi compilado, você pode informar ao ChatGPT.

07:11.410 --> 07:16.720
Ei, isso foi muito bom, mas eu recebi este erro e você estaria ajudando a educá-lo e lhe daria

07:16.720 --> 07:17.590
uma resposta melhor.

07:17.590 --> 07:19.000
Não precisamos fazer isso aqui.

07:19.000 --> 07:24.460
Além disso, se alguns ou todos os testes falharam, você poderia dizer à unidade que geralmente não vejo que o

07:24.460 --> 07:26.350
testes falhem, mas é possível.

07:26.350 --> 07:27.490
Então é isso aqui.

07:27.490 --> 07:31.000
Vimos um caso de uso fantástico para IA em testes de unidade.

07:31.030 --> 07:31.750
Obrigado.
