WEBVTT

00:02.840 --> 00:04.730
Então, por que fazer testes unitários?

00:04.880 --> 00:06.200
Gosto de começar com esta citação.

00:06.200 --> 00:07.050
Vou lê-la aqui.

00:07.070 --> 00:14.150
Toda decisão que tomamos, seja ela sobre tecnologia, processos ou pessoas, pode ser vista como uma forma de investimento.

00:14.510 --> 00:19.040
Esses investimentos têm um custo e confiamos que serão compensados.

00:19.250 --> 00:24.950
Portanto, se você já está familiarizado com o desenvolvimento de jogos e é capaz de obter algumas das funcionalidades

00:24.950 --> 00:29.480
que tem em mente para os projetos e compartilhá-las com os jogadores que estão jogando o seu jogo,

00:29.480 --> 00:32.520
talvez não esteja muito claro qual é o valor dos testes unitários.

00:32.540 --> 00:38.060
Os testes unitários devem ser vistos, antes de mais nada, como uma atividade opcional que você pode adicionar ao jogo

00:38.060 --> 00:39.640
ao seu código de produção.

00:39.650 --> 00:47.210
De certa forma, os seus usuários finais nunca vêem essa funcionalidade, mas a ideia e os benefícios que advêm da

00:47.210 --> 00:53.960
testes unitários, especialmente o desenvolvimento orientado por testes, esperamos que nos dêem uma recompensa por esse investimento.

00:53.990 --> 01:01.010
Teremos classes e sistemas que operam de forma mais confiável, que são mais robustos, mas que são

01:01.010 --> 01:08.330
menos propensos a erros e que lhe permitirão adicionar mais recursos aos seus usuários de forma mais rápida e confiante

01:08.330 --> 01:11.670
com testes unitários como uma de suas habilidades.

01:11.690 --> 01:15.190
Agora, neste mundo de testes unitários, há muitos termos diferentes.

01:15.200 --> 01:18.320
Alguns dos que vemos aqui, vou ler apenas alguns deles.

01:18.320 --> 01:23.660
Composição e abstração, referindo-se à maneira como suas classes e arquiteturas podem se encaixar

01:23.660 --> 01:24.470
juntas.

01:24.710 --> 01:29.120
Classes e métodos são apenas os fundamentos da programação orientada a objetos.

01:29.120 --> 01:34.630
Depois, coisas como mock e assertion e range act e assert também.

01:34.640 --> 01:37.850
Essas são coisas que se referem especificamente a testes unitários.

01:37.850 --> 01:42.500
Vamos cobrir, de maneira informal, todos os termos que vemos aqui.

01:42.500 --> 01:44.810
Provavelmente, vamos abordá-los agora no último.

01:44.810 --> 01:46.040
Desenvolvimento profissional.

01:46.040 --> 01:52.010
Quando você começa como um desenvolvedor de jogos dentro do unity, aprendendo a ferramenta unity, aprendendo a teoria

01:52.010 --> 01:56.840
por trás do unity e, claro, a codificação em C-sharp, você percebe que está se formando.

01:56.840 --> 02:01.700
Os conceitos estão ficando cada vez mais complexos à medida que você passa por esses diferentes tópicos.

02:01.730 --> 02:06.050
Coisas como classes em OOP, que são coisas que você aprende no início do desenvolvimento.

02:06.050 --> 02:13.340
Mais tarde em sua carreira, você se concentrará mais em fazer com que seus projetos sejam mais modulares, reutilizáveis, acrescentando

02:13.370 --> 02:18.800
testes, que é o núcleo aqui, e depois falar mais sobre a arquitetura de seus projetos.

02:18.830 --> 02:25.460
Um sinal de um projeto bem arquitetado é aquele que, quando você adiciona o 101º recurso, ele não

02:25.460 --> 02:26.900
quebra tudo o que você já tem.

02:26.930 --> 02:33.050
Agora, aqui vemos um caminho possível de um desenvolvedor júnior que se move em uma carreira.

02:33.050 --> 02:38.600
E é particularmente interessante que as habilidades de que estamos falando aqui são realmente o que move

02:38.600 --> 02:42.890
você de um desenvolvedor iniciante para um júnior e para um sênior.

02:42.890 --> 02:49.070
São realmente esses tipos de conhecimento prático que você está adicionando ao seu conjunto de habilidades que o ajudarão a

02:49.070 --> 02:55.040
a conseguir uma promoção em sua função atual ou a encontrar novas funções e oportunidades de contribuir em outras

02:55.040 --> 02:55.790
equipes.

02:55.820 --> 03:02.030
Agora, nem todas as equipes usam testes unitários no mundo da programação, e acho que particularmente no desenvolvimento de jogos,

03:02.030 --> 03:07.670
você não os encontra com tanta frequência quanto em outras plataformas e paradigmas de programação, mas eles são

03:07.670 --> 03:08.870
igualmente importante aqui.

03:08.870 --> 03:11.150
Vejamos por que os testes unitários são importantes.

03:11.150 --> 03:12.460
Eu vou ler aqui.

03:12.470 --> 03:19.100
À medida que o seu projeto cresce com mais scripts, classes e métodos, fica difícil para você garantir

03:19.100 --> 03:23.810
que uma alteração em uma parte do seu código não quebra algo em outra parte.

03:23.900 --> 03:28.850
Os testes automatizados ajudam a verificar se o código está funcionando conforme o esperado.

03:29.150 --> 03:35.870
Os testes economizam tempo ao descobrir onde e quando os problemas ocorrem assim que são introduzidos no desenvolvimento,

03:35.870 --> 03:42.290
em vez de depender de testes manuais, ou até mesmo da espera mais cara pelos usuários finais, o seu

03:42.290 --> 03:47.030
jogadores para relatar um erro, vamos falar um pouco sobre o valor de encontrar os erros com antecedência.

03:47.030 --> 03:54.410
Muitos de nós, como desenvolvedores, achamos que o processo de desenvolvimento de jogos se resume a adicionar novos recursos

03:54.410 --> 03:59.540
e achamos que quanto mais rápido os adicionarmos, mais valor ofereceremos aos usuários finais.

03:59.570 --> 04:05.300
Embora essa seja uma maneira divertida de começar um projeto, todos nós conhecemos os resultados que advêm da adição de recursos

04:05.300 --> 04:13.160
muito rápido no início do desenvolvimento, especialmente em cima de uma base de código que não foi bem projetada, bem arquitetada

04:13.160 --> 04:14.210
ou bem testada.

04:14.210 --> 04:21.620
O que as pesquisas no setor de desenvolvimento de jogos mostram é algo parecido com a regra 80 sobre 20, ou seja, 80% dos

04:21.620 --> 04:25.250
bugs de desenvolvimento vêm de apenas 20% de seus recursos.

04:25.250 --> 04:29.780
A complexidade central geralmente fica em um canto estreito da base de código.

04:29.780 --> 04:36.080
O projeto, a organização ou a falta deles podem causar problemas tremendos e recorrentes.

04:36.110 --> 04:42.050
Você acaba lutando contra os mesmos incêndios de sempre, porque não tem o projeto e a

04:42.050 --> 04:46.070
testes para provar que aquela área está sendo desenvolvida com segurança.

04:47.120 --> 04:49.770
80% do tempo de desenvolvimento é de manutenção de códigos.

04:49.790 --> 04:55.190
Isso é assustador de se ouvir, mas é o que vemos em grandes bases de código.

04:55.220 --> 05:01.100
Imagine lançar um jogo em seis meses e dar suporte a ele por mais um ou dois anos enquanto estiver corrigindo os bugs

05:01.100 --> 05:03.210
correções de bugs e adicionando novos recursos.

05:03.230 --> 05:05.800
Esse é um exemplo de um jogo muito simples.

05:05.810 --> 05:12.020
Mesmo nesse processo, descobrimos que 80% do tempo que você gasta como desenvolvedor não é adicionando esses

05:12.020 --> 05:12.890
novos recursos.

05:12.890 --> 05:20.030
É para reduzir e encontrar bugs em sistemas antigos e fazer refatorações nos primeiros seis meses.

05:20.060 --> 05:24.050
A arquitetura pode não se encaixar nos segundos seis meses de arquitetura.

05:24.080 --> 05:29.300
O seu projeto vai crescer e a sua equipe vai aprender, portanto, você vai fazer mudanças

05:29.300 --> 05:30.150
ao longo do caminho.

05:30.170 --> 05:31.430
Não há problemas.

05:31.460 --> 05:33.950
Essas alterações são geralmente chamadas de refatoração.

05:33.950 --> 05:39.860
Refatoração é tornar seu código mais eficiente e oferecer o mesmo valor aos seus consumidores finais.

05:39.890 --> 05:45.530
Cada refatoração permite que você tenha um novo ponto de partida para adicionar ainda mais recursos.

05:45.530 --> 05:52.460
Portanto, o que vemos aqui é que, ao estabelecer boas práticas de teste, isso ajudará a

05:52.460 --> 05:56.450
manutenção do código, isso ajudará os 80% em que gastamos muito do nosso tempo.

05:56.450 --> 06:02.480
E, como mencionei anteriormente, vamos dar uma olhada no fato de que o custo dos bugs de software aumenta com o tempo.

06:02.480 --> 06:08.420
Agora, essa parte específica da pesquisa mostra que se você estiver conversando com um colega sobre

06:08.420 --> 06:13.250
um recurso de jogo e um de vocês aponta algo que pode ser um problema, eles o corrigem,

06:13.280 --> 06:15.420
essa conversa é super barata.

06:15.440 --> 06:22.340
Vamos chamar isso de uma quantidade x de tempo e esforço muito baixos à medida que você implementa isso

06:22.340 --> 06:28.430
projeto, encontrar o mesmo bug depois de codificado é mais difícil de encontrar e mais difícil

06:28.430 --> 06:30.860
para corrigi-lo e ter certeza de que o corrigiu.

06:30.860 --> 06:36.860
Bem, depois de fazer o teste, você passa o produto para os clientes testarem e depois envia

06:36.860 --> 06:38.400
para os jogadores finais.

06:38.420 --> 06:41.000
Imagine um jogador encontrando esse mesmo problema.

06:41.030 --> 06:44.330
Ele terá de ficar desapontado com isso.

06:44.330 --> 06:47.510
Talvez isso afete negativamente a forma como eles pensam sobre o jogo.

06:47.510 --> 06:50.060
Talvez você possa até perdê-lo como jogador do jogo.

06:50.060 --> 06:55.400
Mas se ele for uma pessoa que fala muito e você tiver um bom canal de atendimento ao cliente e ele enviar isso,

06:55.430 --> 07:00.950
ele vai para o seu sistema de emissão de tíquetes de bugs, eventualmente é atribuído, eventualmente é corrigido, talvez

07:00.950 --> 07:06.950
seja ou não corrigido corretamente e, em seguida, você envia essa atualização para os usuários finais, esperando que o usuário

07:06.980 --> 07:08.270
necessidades do usuário tenham sido atendidas.

07:08.300 --> 07:09.590
É muito mais caro.

07:09.590 --> 07:10.210
No final.

07:10.220 --> 07:15.480
Veremos que os testes unitários nos permitem, em primeiro lugar, projetar melhor o nosso software.

07:15.500 --> 07:22.550
Em segundo lugar, colocar testes em seu projeto para que esses testes automatizados encontrem o bug mais cedo.

07:22.550 --> 07:28.130
Talvez na fase de integração, como estamos vendo aqui, não seja tão bom quanto corrigi-lo na primeira etapa.

07:28.130 --> 07:32.240
conversa, mas é muito melhor do que esperar que o projeto seja lançado.

07:32.480 --> 07:38.090
Portanto, algumas das melhores práticas destacadas aqui são a criação de código de fácil manutenção, o aumento da

07:38.090 --> 07:44.150
a automação e os testes que você tem em seu código, capturando os bugs cedo e com frequência e corrigindo-os

07:44.150 --> 07:46.490
bugs antes de adicionar novos recursos.
