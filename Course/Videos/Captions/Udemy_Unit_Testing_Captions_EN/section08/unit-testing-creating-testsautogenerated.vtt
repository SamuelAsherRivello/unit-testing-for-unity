WEBVTT

00:00.090 --> 00:01.510
Creating unit tests.

00:01.530 --> 00:03.600
Test class and test methods.

00:03.600 --> 00:07.260
Here's the code for a test class containing one test method.

00:07.260 --> 00:12.510
Inside, we follow the optional paradigm of arrange, act and assert.

00:12.510 --> 00:14.970
That's the convention I use for all of my testing.

00:14.970 --> 00:19.120
So we've seen what a test looks like and how to run an existing test.

00:19.140 --> 00:20.750
Now let's create our own test.

00:20.760 --> 00:27.780
We'll open up an empty project, open the test run or window, create a test folder, a test class,

00:27.780 --> 00:29.760
and a method inside that test.

00:29.910 --> 00:31.740
Then we'll run the test and see the result.

00:31.740 --> 00:34.020
Here we are in a fairly empty project.

00:34.020 --> 00:37.410
I do have the unity test framework added already.

00:37.410 --> 00:43.920
Let's open up the test runner window since the project has no edit mode tests and no play mode tests,

00:43.920 --> 00:47.670
each of those tabs offer some options here to get us started.

00:47.670 --> 00:53.610
First, we'll create an edit mode test assembly folder by clicking the button that creates a new folder

00:53.610 --> 00:59.430
in our project window, including an assembly set up for testing, unity assemblies and the assembly

00:59.430 --> 01:07.110
definition file is outside the scope of this course, but in brief this signals unity that things within

01:07.110 --> 01:11.700
this given folder should be compiled, should be compiled in a unique way.

01:11.700 --> 01:16.470
So now that we have that test assembly folder set up, we can create our first test class.

01:16.470 --> 01:21.390
Each of these steps can be done manually without using the window, but I'll continue by clicking the

01:21.390 --> 01:26.610
next button here to create a test script in the current folder in the project window that creates a

01:26.610 --> 01:29.600
new test class and it gives us two test methods.

01:29.610 --> 01:32.430
Notice in the test run or window, everything shows up.

01:32.550 --> 01:33.930
I'll run all those tests.

01:33.930 --> 01:35.150
All the tests pass.

01:35.160 --> 01:37.230
Let's take a look at the code that's generated.

01:37.230 --> 01:42.090
At this point, you're free to rename the class and these methods however you see fit.

01:42.090 --> 01:45.660
And then, of course copy and paste to add more methods within.

01:45.660 --> 01:50.940
There's no limit to the number of test methods you can have in a test class, but generally you use

01:50.940 --> 01:57.990
the class to organize certain topics, perhaps one test class for each production class and then one

01:57.990 --> 02:01.170
test method within for each method in production.

02:01.170 --> 02:03.420
You want to test something like that.

02:03.420 --> 02:07.110
These comments are automatically generated by unity and are quite helpful.

02:07.650 --> 02:09.120
I'll go over the highlights here.

02:09.120 --> 02:10.380
Using the test.

02:10.920 --> 02:19.290
Using the test attribute sets us up for a normal edit mode test Using the unity test attribute allows

02:19.290 --> 02:22.250
us to execute a test over multiple frames.

02:22.260 --> 02:26.790
Now, I mentioned before that using unity test is best fit for play mode.

02:26.790 --> 02:31.320
You have much more options at what type of asynchronous functionality you can do there.

02:31.320 --> 02:38.160
It is indeed possible here and as the comment suggests, you can use yield return null to skip a frame.

02:38.160 --> 02:43.020
For example, doing the setup, then waiting a frame and doing the test.

02:43.020 --> 02:44.010
Something like that.

02:44.010 --> 02:47.730
For example, doing the setup code, waiting a frame.

02:48.380 --> 02:51.080
And then doing the assertion, something like that.

02:51.080 --> 02:54.620
Here, back into unity I will tab over to the.

02:55.350 --> 02:57.840
Play mode and follow the same steps.

02:57.840 --> 03:04.020
First, we'll create a play mode test assembly folder and then I'll create a test script.

03:04.020 --> 03:09.900
In this folder we can see in the test runner that we've got one test class that contains two test methods.

03:10.500 --> 03:13.370
I'll run all and we see that everything passes.

03:13.380 --> 03:15.350
Let's take a look at the generated code.

03:15.360 --> 03:21.960
The code generated here is actually identical in both play mode and edit mode.

03:21.960 --> 03:24.240
They give you very similar starting points.

03:24.240 --> 03:25.110
That's it.

03:26.480 --> 03:31.700
We're beginning to see that with the test runner window and just a little bit of added C-sharp.

03:31.700 --> 03:35.250
We can do more things with our unity projects than we have before.

03:35.270 --> 03:41.420
If you're new to unit testing, you're familiar with using unity to create runtime code, but testing

03:41.420 --> 03:42.800
code is something different.

03:43.480 --> 03:46.750
It's never directly experienced by your end users.

03:47.200 --> 03:49.770
This code only runs in test mode.

03:49.790 --> 03:52.320
It's not even packaged into your end build.

03:52.330 --> 03:59.470
We start to look at tests now as a small window into moments and time in a larger application testing

03:59.470 --> 04:03.030
with a narrow focus to ensure we get consistent results.

04:03.040 --> 04:08.320
Up to now, we've been talking mostly about adding new tests to existing code.

04:08.350 --> 04:13.420
Next, we'll look at how to add tests while we're developing code with test driven development.

04:13.420 --> 04:14.200
Thanks.
