WEBVTT

00:00.590 --> 00:02.660
Hello and welcome to Unit Testing for unity.

00:02.690 --> 00:03.860
The workshops.

00:03.860 --> 00:09.590
In this workshop section, we're going to cover lots of different small examples that each show us some

00:09.590 --> 00:11.030
features of unit testing.

00:11.030 --> 00:12.800
Let's take a look at the contents here.

00:12.800 --> 00:16.730
First I'll give this overview that I'm going through now in this section introduction.

00:16.730 --> 00:19.070
And then we'll step through each workshop.

00:19.070 --> 00:24.320
Typically each workshop refers to one scene in our one sample project.

00:24.320 --> 00:28.370
So if you download that sample project you can follow along with each of the scenes.

00:28.370 --> 00:35.270
We'll cover my math system, which is a very basic example, just to reacquaint us with what unit testing

00:35.270 --> 00:36.500
is inside unity.

00:36.500 --> 00:42.230
Then we'll move on to a my data loader example, and that one I'll be showing a basic version and then

00:42.230 --> 00:48.740
a more advanced version using some additional features that are optional but awesomely powerful inside

00:48.740 --> 00:50.390
unity for unit testing.

00:50.420 --> 00:54.920
Then we'll go through an example that I wanted to do something with rendered graphics.

00:54.920 --> 01:00.530
So I have a cube that we can operate with the arrow keys or with a gamepad, and we'll call that our

01:00.530 --> 01:01.340
character.

01:01.400 --> 01:06.950
We're going to step through a few examples, looking at more and more complex use cases for testing,

01:06.950 --> 01:13.520
eventually doing a physics based movement, taking input and moving our character with rigid body,

01:13.520 --> 01:17.990
and looking at how and why we would want to do unit testing around that.

01:18.020 --> 01:25.340
Generally speaking, the more unity features you use and the more runtime animation you do, it makes

01:25.340 --> 01:27.440
more challenges to the testing process.

01:27.440 --> 01:28.880
So we'll talk a little bit about that.

01:28.880 --> 01:31.670
There's always an opportunity for me to add more content here.

01:31.670 --> 01:34.160
So we're going to be doing some advanced topics as well.

01:34.160 --> 01:38.990
And this workshop is going to allow us to dive deeper into some particular subtopics.

01:38.990 --> 01:43.580
All the source code is available in the downloaded source code for the project itself.

01:43.580 --> 01:44.720
So you can grab that.

01:44.720 --> 01:48.950
And the format here is going to be an improvised screen share.

01:48.980 --> 01:53.750
I'm going to do longer takes than normal, and just think out loud when there's some different things

01:53.750 --> 01:58.520
that I want to talk about and share with you about the powers and the challenges of unit testing.

01:58.820 --> 02:03.320
I'm going to be reviewing some existing code and here and there be creating new code along the way.

02:03.320 --> 02:09.590
A great way to look at this and use this information is to download the sample project and follow along

02:09.590 --> 02:10.400
here and there.

02:10.400 --> 02:16.190
I'll encourage you to add a new production method to be tested, or new test methods to cover what you've

02:16.190 --> 02:17.540
got in production code.

02:17.540 --> 02:21.200
You can build on to the existing samples that I've got here.

02:21.200 --> 02:23.720
Or you could certainly create your own sample scenes.

02:23.720 --> 02:27.230
And as a recap, let's read here the benefits of unit testing.

02:27.230 --> 02:33.560
Some of them include adding code confidence, as well as allowing for bolder refactors to your code

02:33.560 --> 02:39.560
base with more awareness before and after the refactor of the status of your project.

02:39.560 --> 02:44.990
And overall, this is going to save time because we've seen that while it may feel like we're always

02:45.020 --> 02:50.210
adding new features in the bulk of our work effort, we learn from research that software development

02:50.210 --> 02:55.220
is mostly about maintaining an existing existing code, and that's really where unit testing is going

02:55.220 --> 02:55.640
to shine.

02:55.640 --> 02:58.700
So it's going to save us time over the life of the project.

02:58.730 --> 03:04.130
The results that we expect from this course and from using unit testing is to have more confidence and

03:04.130 --> 03:05.990
robustness in our code base.

03:06.020 --> 03:12.680
We're going to have more single purpose classes and methods, which is a great design principle to focus

03:12.680 --> 03:14.930
on and certainly helps us in our testability.

03:14.930 --> 03:17.450
And we're going to be encouraging more simple solutions.

03:17.450 --> 03:19.550
And we'll talk about that in some of these examples.

03:19.550 --> 03:21.650
To recap the simplest example here.

03:21.650 --> 03:24.380
This is also the first of the workshops we're going to dive into.

03:24.410 --> 03:30.290
If we have a mind math system class, and it has two methods on it to add and subtract.

03:30.320 --> 03:35.090
Now you could imagine once you see this code base working, you could add your own method for multiply

03:35.090 --> 03:38.300
or divide, and then add some unit tests on top of that.

03:38.310 --> 03:39.800
Great way to practice here.

03:39.800 --> 03:43.220
And this is purposely the simplest of the scenes we'll go through.

03:43.220 --> 03:48.560
So if you're still getting used to the fundamentals and you want to make sure that it really sinks in,

03:48.560 --> 03:53.300
I suggest spend a little bit more time on this part of the video and this part of the code base until

03:53.300 --> 03:55.340
you're feeling good, and then move on after that.

03:55.340 --> 03:59.450
And again, here is a sample of the type of unit tests we'll be creating.

03:59.450 --> 04:04.100
This is a simple, complete, appropriate test to cover that my math system.

04:04.100 --> 04:08.690
So here what we do is we follow the paradigm of arrange, act and assert.

04:08.720 --> 04:14.540
This is an optional way to approach your unit testing, just to organize your own thoughts as you go.

04:14.720 --> 04:18.740
Sometimes along the way you may be doing asynchronous code development.

04:18.740 --> 04:23.990
So in that methodology I would do arrange, act, await and assert.

04:23.990 --> 04:29.840
And if you're not exactly sure what a wait is, we'll look at the await and async methodology for doing

04:29.870 --> 04:32.120
asynchronous coding as part of the workshop.

04:32.120 --> 04:37.760
Now while working on the source code here for contributing to the project and for this course, what

04:37.760 --> 04:40.330
I did was look at each of the dependencies.

04:40.340 --> 04:47.990
Unity has certain libraries in the unity package manager available for us to do the official unity solution

04:47.990 --> 04:49.550
for unit testing.

04:49.550 --> 04:55.820
Now, what I did here is instead of using the one x which is in release, I use an experimental version.

04:55.820 --> 04:59.900
So you may notice that the test runner as I'm going through in the video looks.

05:00.050 --> 05:04.940
A little bit different than maybe some screenshots you've seen on the web, or if you have experience

05:04.940 --> 05:06.400
with the test runner yourself.

05:06.410 --> 05:08.630
What I'm showing today might look a little different.

05:08.660 --> 05:13.370
The sample project you're going to download is going to match the look of this video, because I've

05:13.400 --> 05:15.020
included that dependency in there.

05:15.050 --> 05:16.340
There's reasons why I did it.

05:16.340 --> 05:21.020
It's not just that the test runner looks different and is more stable, which I think is the case.

05:21.050 --> 05:26.870
It also the library behind it allows us to do a few additional things, particularly around some asynchronous

05:26.870 --> 05:28.370
development and testing.

05:29.730 --> 05:33.060
You can take a look at this version text file that's included in the project.

05:33.060 --> 05:37.790
If you want to see how and where and why included each of these dependencies.

05:37.800 --> 05:43.020
The sample project that we're going to go into includes a Readme asset, which we can click on and see

05:43.020 --> 05:44.390
this nice menu on the right.

05:44.400 --> 05:49.950
It's an easy way to get oriented to remember some popular links, and to click right into each of the

05:49.950 --> 05:51.690
samples that you want to get into.

05:51.960 --> 05:57.270
I have a particular layout that you'll see me use here, which is to keep the test runner in the center

05:57.270 --> 05:59.930
there just so it's nice and big for the purposes of the video.

05:59.940 --> 06:04.710
Often in development, my test runner would maybe sit on the right side there, but I like to have it

06:04.710 --> 06:08.280
front and center, especially for the purpose of discussing the tests.

06:08.370 --> 06:13.290
You can resize these windows and layouts of course, any way you want, but some of the key ones to

06:13.290 --> 06:18.150
take a look at here would be the project window, the test runner, and then the inspector, which we'll

06:18.150 --> 06:19.020
be taking a look at.

06:19.020 --> 06:23.310
So we're about to dive in here and take a look at the first of the workshops.

06:23.370 --> 06:27.870
I've divided it up into several sections, again focusing on some different sub topics.

06:27.870 --> 06:35.130
I also thought along the way to more or less organize them from one up into the highest number, starting

06:35.130 --> 06:39.840
with the easiest and least complex, and then building on those concepts there.

06:40.140 --> 06:42.810
Each of the demo scenes runs by itself.

06:42.810 --> 06:44.880
You just hit play in the console window.

06:44.910 --> 06:47.070
You'll see some readouts and stuff like that.

06:47.070 --> 06:52.050
You can follow along, and some of the scenes, there's actually something to do when you hit play.

06:52.080 --> 06:56.610
Sometimes there's no UI, it's just kind of simple and you just look at some debug log statements.

06:56.610 --> 07:00.110
So I'm really excited to share these workshops as a great way to dive in.

07:00.120 --> 07:01.140
So let's get started.

07:01.140 --> 07:02.970
We're going to open up the unity editor.

07:02.970 --> 07:07.680
I've already downloaded the source code following the course resources from earlier in the lesson.

07:07.680 --> 07:12.540
We'll open up that course sample project, and then we're going to open and play one or more scenes

07:12.540 --> 07:13.680
in each of the workshop.

07:13.680 --> 07:18.360
First we're going to look at the Readme asset that gives us some orientation in the project.

07:18.390 --> 07:23.700
We'll also look at the package manager, explore the project structure and then take a look at the test

07:23.700 --> 07:24.630
runner window.

07:24.630 --> 07:29.610
So here we're just giving an overview to kind of what the sample project is and how the workshops are

07:29.610 --> 07:30.270
formatted.

07:30.270 --> 07:33.090
And then we'll move in and go through each of the workshops.

07:33.090 --> 07:35.190
So here we are inside unity.

07:35.190 --> 07:39.960
I'll do my best to keep my webcam head out of the way of the action here.

07:39.960 --> 07:45.360
And what we're going to be looking at is that the Readme, which is available in a couple spots, we

07:45.360 --> 07:48.810
can go up here and explore this menu option to open the Readme.

07:49.440 --> 07:54.060
We can also browse through the project window and go down here and just click on the readme.

07:54.180 --> 07:56.900
Either way, it's going to open up the readme in the Inspector.

07:56.910 --> 07:58.650
Let's take a look at what we've got here.

08:00.900 --> 08:05.490
We've got some links to the course and to the sample project just for orientation where this information

08:05.490 --> 08:06.060
is available.

08:06.060 --> 08:08.670
If you want to click over and check out those links.

08:11.450 --> 08:13.220
And then the Getting Started section.

08:13.220 --> 08:18.650
There's a quick way to get to some of the popular examples, so you can certainly browse through the

08:18.650 --> 08:20.060
project window and find them.

08:20.060 --> 08:22.140
But this is a nice way to get oriented.

08:22.160 --> 08:25.190
Something else I wanted to take a look at is the package manager here.

08:25.220 --> 08:29.360
Just if you're downloading this project, you'll see the same packages here.

08:29.360 --> 08:35.510
But if you decide for the purpose of your learning here or further into the future to bring these lessons

08:35.510 --> 08:40.640
into a different project, you're going to want to make your package manager look similar if you want

08:40.640 --> 08:42.230
to have the same experience here.

08:42.230 --> 08:46.160
So notice that I've got the end substitute package.

08:46.400 --> 08:52.130
I've also got the code coverage package, the test framework.

08:52.130 --> 08:56.990
And for the purpose of this course, notice that I have a pre-release version that gives us some additional

08:56.990 --> 08:57.940
functionality.

08:57.950 --> 09:00.050
This is optional for unit testing.

09:00.050 --> 09:04.730
You certainly don't need it for the bulk of the features of unit testing, but I think it's got some

09:04.730 --> 09:06.020
cool cutting edge stuff.

09:06.020 --> 09:10.040
So that's what we're going to focus on, and I recommend you give it a try.

09:10.070 --> 09:11.420
Something else of note here.

09:11.420 --> 09:14.750
This version file that I have selected will dig into that.

09:14.750 --> 09:19.430
That's just some notes that I took along the way to talk a little bit about the dependencies that I

09:19.430 --> 09:20.390
chose and why.

09:22.530 --> 09:24.420
So we won't go into it here.

09:24.450 --> 09:26.080
This may change over time as well.

09:26.100 --> 09:30.210
But just check out this file if you're curious how and why I've used each of the dependencies, and

09:30.210 --> 09:33.450
why I use that pre-release version I mentioned explicitly there.

09:33.480 --> 09:37.110
And lastly, front and center here, let's look at the test runner window.

09:37.140 --> 09:42.480
Now that window is available from Window General and Test Runner.

09:42.480 --> 09:47.160
And it's included in every default unity installation as I mentioned.

09:47.190 --> 09:51.600
I've added the pre-release of one given package, so the layout of mine might look a little different

09:51.600 --> 09:54.150
than the standard here in this layout.

09:54.180 --> 10:01.260
What we've got here is the ability to toggle on and off edit mode tests, and on and off play mode tests.

10:01.260 --> 10:03.570
They're shown here in the same tab view.

10:03.720 --> 10:04.840
This is really great.

10:04.860 --> 10:07.800
Then what I can do is browse the different categories.

10:07.800 --> 10:13.140
Now I've created all the tests we're looking at and I've flagged them each as a specific category.

10:13.140 --> 10:18.360
So if I want to look at just one particular one like my math system, then it just filters the view

10:18.390 --> 10:23.970
here and it'll show you only the edit or only the play and of a given category.

10:24.000 --> 10:25.230
That really helps you.

10:25.260 --> 10:31.170
Then what I can do here with just the edit selected, for example, is be able to see all the tests

10:31.170 --> 10:31.770
that are there.

10:31.770 --> 10:36.600
And down here at the bottom I can run selected or run all I'll run selected, for example.

10:36.600 --> 10:40.950
And what it does is it goes through and runs all the test code.

10:41.040 --> 10:48.270
This is kind of the core of the methodology we're approaching here is that periodically in your development

10:48.270 --> 10:50.270
you want to test your own code base.

10:50.280 --> 10:55.190
You come to this window and you manually hit that run selected or that run all button.

10:55.200 --> 10:59.340
We see all green here indicating success up here at the top.

10:59.340 --> 11:02.970
It gives us a little recap that we've got 100 tests that succeeded.

11:02.970 --> 11:07.550
We've got zero that failed, and we've got zero that were skipped or ignored.

11:07.560 --> 11:13.530
So a great practice as you're doing unit testing is to ensure that all of your tests pass.

11:13.560 --> 11:18.570
Don't allow a failing test in your project for a long time.

11:18.570 --> 11:19.680
You want to address that.

11:19.680 --> 11:20.520
Move it out of the way.

11:20.520 --> 11:23.280
Even if you know there's a migration coming in the future.

11:23.280 --> 11:29.280
So the best practice here is to keep your tests updated with your code changes and always have them

11:29.280 --> 11:30.030
passing.

11:30.030 --> 11:32.700
So here we show the best practice in effect.

11:33.690 --> 11:36.690
In the next workshop we'll take a closer look at the source code involved.

11:36.690 --> 11:41.850
But that's it for this section of looking at the workshops and the sample project.

11:46.910 --> 11:47.900
Hello and welcome.

11:47.900 --> 11:53.990
In this workshop, we're going to be taking a look at the My Math system, stepping into what is a pretty

11:54.020 --> 11:58.250
simple example, just getting us reacquainted with the basics of unit testing.

11:58.250 --> 12:01.640
So in this demo you can use the Core Sample project to follow along.

12:01.640 --> 12:06.440
We're going to be opening up the unity editor, opening up that core sample project, and then we'll

12:06.440 --> 12:08.060
open and play some scenes here.

12:08.060 --> 12:13.310
We're going to be looking at the My Math system as well as the test behind it, and we'll do a recap

12:13.340 --> 12:18.920
of unit testing, just kind of talking about whatever basic concepts I see in there and think to mention.

12:18.920 --> 12:25.370
And we'll also talk about parameterized values, which is an intermediate way that you can approach

12:25.370 --> 12:25.880
testing.

12:25.880 --> 12:29.540
And it's a good additional skill to have as you approach unit testing.

12:29.570 --> 12:30.560
Let's dive in.

12:30.770 --> 12:35.330
So here I'm inside the unity editor I've opened the my math system example.

12:35.330 --> 12:37.970
Let's just give the scene itself a play.

12:38.000 --> 12:41.630
Sometimes in these workshops the scene is more exciting.

12:41.630 --> 12:43.220
This one not so exciting.

12:43.220 --> 12:48.680
We'll go ahead and hit play down here in the bottom window, we see some simple text that's helping

12:48.680 --> 12:53.960
us understand we're in the unit testing demo, and we're going to just play the scene and view the console.

12:53.960 --> 12:55.430
So let's look at the console.

12:55.520 --> 12:58.520
The console says this scene has no UI.

12:58.550 --> 13:01.430
See the unity console here we are in the console.

13:01.430 --> 13:02.090
Really.

13:02.090 --> 13:06.830
It's just going to show us a value that's been spit out after a successful operation.

13:06.830 --> 13:12.290
So this would, in real production code, be a much more interesting scene.

13:12.290 --> 13:17.540
Perhaps there's actually the game menu or the game play happening here.

13:17.780 --> 13:22.730
This is quite a lean scene here where there's not much to see, but you can imagine that that could

13:22.730 --> 13:23.150
be.

13:23.720 --> 13:28.880
It's not particularly important that there be a runtime scene for the testing sake.

13:28.880 --> 13:34.520
I just want to often talk about the balance between here's your production code doing its production

13:34.520 --> 13:35.150
thing.

13:35.150 --> 13:38.480
And then over here is the test code doing its test thing.

13:38.480 --> 13:44.330
So production code, we always experience that by hitting play on a unity scene just like this.

13:44.330 --> 13:47.750
And to do our unit testing we do something different.

13:47.780 --> 13:50.990
What we do here is we look at the test runner window.

13:51.530 --> 13:55.340
We explore the category appropriate to what we want to look at here.

13:55.340 --> 13:57.470
We're just looking at the my math system.

13:58.560 --> 14:01.020
And then we hit let's see.

14:01.020 --> 14:02.280
Let's just do the edit mode test.

14:02.430 --> 14:06.780
We'll do run all here and all the tests run just like that.

14:06.810 --> 14:09.050
Now it didn't actually run the scene.

14:09.060 --> 14:15.420
It's just running kind of off on the side in its own little universe, running those tests inside an

14:15.420 --> 14:16.290
edit mode.

14:16.290 --> 14:19.790
So edit mode tests talking a little bit about the difference there.

14:19.800 --> 14:25.050
Edit mode tests run in edit mode, which in unity there's two primary modes.

14:25.050 --> 14:30.630
Basically, from the moment you hit the play button to the moment you hit the play button, that is

14:30.630 --> 14:31.290
play mode.

14:31.320 --> 14:35.440
That's generally where the user experiences the unity gameplay.

14:35.610 --> 14:38.430
Any time we're not in that mode, we're in edit mode.

14:38.430 --> 14:40.170
Sitting right here, we're in edit mode.

14:40.200 --> 14:46.260
These tests are run in edit mode because they don't necessarily need all the complexity of a runtime

14:46.260 --> 14:46.800
scene.

14:46.800 --> 14:52.110
This helps us have a more simple little isolated area where these codes run.

14:52.110 --> 14:57.780
Now sometimes you need the conveniences of monobehaviours and runtime functionality.

14:57.780 --> 15:01.680
That's where the play mode comes into into uses.

15:01.680 --> 15:04.260
And here we've got some play mode tests as well.

15:04.260 --> 15:09.480
So each time I click one of these checkboxes, you can see it's showing us some slightly different lists

15:09.510 --> 15:10.740
of what we've got available.

15:10.740 --> 15:13.140
So here in play mode I'm going to hit run all.

15:13.950 --> 15:18.090
And here it's actually creating a brand new scene.

15:18.090 --> 15:24.420
Running a runtime scene that's just for demo sake with whatever test code I've got, and then returns

15:24.420 --> 15:26.880
us back to the original scene we were in.

15:26.880 --> 15:31.110
If we didn't have the scene saved, it would prompt us and say, hey, you're about to run a play mode

15:31.140 --> 15:31.620
test.

15:31.650 --> 15:33.360
We're going to temporarily leave your scene.

15:33.390 --> 15:35.040
Do you want to save your scene first?

15:35.040 --> 15:37.500
Generally, that's a good idea, so look out for that.

15:37.530 --> 15:39.300
Now let's look at the source code.

15:39.330 --> 15:43.020
Let's first look at the runtime production code.

15:43.020 --> 15:45.810
So we'll open up the My Math system example.

15:45.810 --> 15:52.740
Each of these workshops has, generally speaking one game object with one example script that kicks

15:52.740 --> 15:53.580
it all off.

15:53.580 --> 15:59.490
So when we look at that, here we are in the code editor and we can see the complete my math system

15:59.490 --> 16:00.180
example.

16:00.180 --> 16:05.670
Now this is a monobehaviour because I want to have the conveniences of code sitting on a game object.

16:05.670 --> 16:10.380
And then inside the await here I'm going to simulate some production code.

16:10.380 --> 16:16.140
Now it's very lean, there's not much to it, and it kind of looks the same as the test we're about

16:16.140 --> 16:21.780
to look at, because I create the class from scratch and then I call a method on it, and then I show

16:21.780 --> 16:22.530
the results.

16:22.530 --> 16:28.320
But it's important to know that in a production example, in a real game project, this equivalent would

16:28.320 --> 16:33.600
be many classes and all the scenes and all the prefabs and all the complexity you would generally have

16:33.600 --> 16:34.530
in your project.

16:34.530 --> 16:37.230
But here I'm keeping it purposely very lean.

16:37.230 --> 16:38.910
So notice what we do here.

16:38.910 --> 16:40.920
We create the my math system.

16:40.920 --> 16:45.750
We grab a couple of ints and populate them with the values five and ten.

16:45.750 --> 16:47.940
And then we call the my Math system.

16:47.940 --> 16:50.550
And we pass in the five and ten together.

16:50.550 --> 16:52.500
And then here we show the result.

16:52.500 --> 16:54.030
So let's go ahead and do that.

16:54.030 --> 16:55.470
So here I hit play.

16:59.430 --> 17:03.560
And down here in the console window we see the result is 15.

17:03.570 --> 17:09.240
Now, I like the simplicity of this coding example, because it starts us thinking about in a world

17:09.240 --> 17:14.540
where unit tests never existed, how would I go about being sure that this code is functional?

17:14.550 --> 17:21.570
Well, perhaps this code of my math system is used in many, many places of your game, and you simply,

17:21.570 --> 17:26.970
any time you want to see and validate that this system is working well, you just play the game and

17:26.970 --> 17:31.110
your game might be several minutes long, or it could be several hours long.

17:31.110 --> 17:37.140
And this particular system that's under test could be used throughout so many different places, depending

17:37.140 --> 17:40.320
on different user behavior and input and situations.

17:40.320 --> 17:42.660
Perhaps the time of day would be matter.

17:42.660 --> 17:47.970
And so it's difficult for you to know am I really testing it in raw isolation?

17:47.970 --> 17:56.490
So one first move I could do if I wanted to do some validation is I could copy this here, paste it

17:56.490 --> 17:57.360
here.

17:59.710 --> 18:02.220
And call this here and test.

18:02.230 --> 18:03.790
Well, what if it was six?

18:03.790 --> 18:05.680
And what if it was 11?

18:07.710 --> 18:09.360
A to, B to.

18:14.010 --> 18:20.000
So now I'm testing not a unit test, but I'm just validating two different examples here.

18:20.010 --> 18:22.770
So I'm doing this one first and I'm doing that in second.

18:22.800 --> 18:29.760
Now this is called user testing or play mode testing or integration testing where I'm actually running

18:29.760 --> 18:30.900
production code.

18:30.900 --> 18:37.710
And I'm just trying it out as a user, hoping that I accidentally ask it to do a bunch of different

18:37.740 --> 18:40.620
operations, see that none of them fail.

18:40.650 --> 18:44.790
But you could imagine that what I'm doing here is adding stuff that I don't really want for the end

18:44.790 --> 18:46.140
user experience.

18:46.140 --> 18:52.650
I'm just trying to give myself a little bit more confidence in my own code by calling some functionality

18:52.650 --> 18:53.910
extra times.

18:53.940 --> 19:00.510
You might also set a boolean somewhere in your project that says like is debug mode is true, and then

19:00.510 --> 19:02.280
you throughout your production code.

19:02.280 --> 19:05.730
If that's the situation, you'll do a little extra testing.

19:05.730 --> 19:07.140
Now that's not bad.

19:07.140 --> 19:12.150
In certain situations, it can definitely help you, but let's look at how much better the situation

19:12.150 --> 19:12.720
can be.

19:12.720 --> 19:15.960
If instead of doing this, I run unit tests.

19:15.960 --> 19:18.780
So here's where this project the code sits.

19:18.780 --> 19:23.010
In this project we've got the My Math system, My Math system example, which we've looked at.

19:23.700 --> 19:29.580
The structure of that and the way that they work together is talked about earlier in the course.

19:29.580 --> 19:34.350
But we have one editor test and one runtime test that we'll talk about.

19:34.350 --> 19:40.980
Again, any editor test is going to run an edit mode, and it's generally ideal for things that do not

19:40.980 --> 19:44.310
use unity specific classes like Monobehaviour.

19:44.310 --> 19:49.440
Monobehaviour is designed only to run in its fullest way in play mode.

19:49.440 --> 19:51.390
So here it's not too appropriate.

19:51.390 --> 19:51.870
So.

19:51.870 --> 19:54.810
But for simple tests like the one that we've got here, it's great.

19:54.840 --> 19:59.580
The runtime area here where we have the play mode test would be a great place.

19:59.580 --> 20:05.130
And each of these workshops I do one of each just so you can see the differences.

20:05.130 --> 20:09.960
But it's important to think that in certain situations, depending on what you're testing, probably

20:09.960 --> 20:14.010
a unit test in edit mode is more appropriate in this situation.

20:14.010 --> 20:18.630
That's definitely the case later when we're talking about moving with input and doing something with

20:18.630 --> 20:24.750
physics, maybe the play mode test is required there, because input and physics are really designed

20:24.750 --> 20:26.220
as play mode experiences.

20:26.220 --> 20:28.650
So it's important to know that distinction.

20:28.650 --> 20:30.030
And I'll bring it up here and there.

20:30.270 --> 20:32.760
So let's look at the mind math system test.

20:36.190 --> 20:39.130
And see how that is organized.

20:40.710 --> 20:45.990
So here, notice that the My Math system test has a few different.

20:51.350 --> 20:53.180
Has a few different methods under it.

20:53.330 --> 20:57.500
Each of the names that we see here are the names of the test methods.

20:57.500 --> 20:59.000
So let's start with the first one.

20:59.600 --> 21:04.970
The convention that I like to use is followed here, and we'll go into it in the code I generally put

21:04.970 --> 21:10.460
first, what method are we testing, what are we expecting and then what's the situation.

21:10.460 --> 21:13.400
So here it says the add method is what we're testing.

21:13.400 --> 21:18.080
We expect the result will be 15 when we pass in five and ten.

21:18.320 --> 21:23.750
So a nice shortcut here is that as you're running any tests you can just double click it to run it again.

21:24.800 --> 21:26.540
And then I can right click it.

21:28.490 --> 21:29.360
Sorry, I was in play mode.

21:29.810 --> 21:31.850
Double click it and it runs again.

21:31.880 --> 21:32.330
Great.

21:32.330 --> 21:33.230
Still green.

21:33.230 --> 21:36.560
And I can right click it and choose open source code.

21:37.720 --> 21:41.800
That's an easy way to get right to the right class and right to the right method.

21:41.830 --> 21:44.320
Here again is that method name that we saw.

21:44.350 --> 21:47.860
Again add result is 15 when five and ten.

21:47.890 --> 21:54.070
The reason that that's important is that if you have lots of test classes with lots of test methods,

21:54.070 --> 22:01.600
and I hope that you do in your project in order to reason which in a test runner is which in the code

22:01.600 --> 22:04.610
base here, it's nice to have that consistent naming.

22:04.630 --> 22:09.910
So here what we do, we do the arrange, act and assert methodology.

22:09.910 --> 22:10.720
In the arrange.

22:10.720 --> 22:15.310
What we're going to do first is just create a fresh instance of what we want to test.

22:15.310 --> 22:19.420
That way we know it hasn't been sitting around, doesn't have any old data inside of it.

22:19.430 --> 22:20.770
It's always a good practice.

22:20.770 --> 22:22.480
Then we're going to act upon that.

22:22.480 --> 22:26.140
This is like, what is the one method if you can get away with it?

22:26.140 --> 22:28.690
Maybe two methods that really do the testing.

22:28.690 --> 22:30.160
But one method is ideal.

22:30.190 --> 22:32.680
Here we're adding together five and ten.

22:32.680 --> 22:36.670
And then in the assert we're going to use this assert language.

22:36.670 --> 22:43.630
The assert class has a certain structure to it where you say I assert that something is something.

22:43.630 --> 22:48.670
And you can look at the documentation on that to see some variety of ways that you can format that.

22:48.670 --> 22:54.790
But often I use is equal to or is true or is false.

22:54.790 --> 22:57.670
So those are ones that you'll see quite commonly here.

22:57.970 --> 23:02.920
So when I run that because the code runs correctly it adds five and ten to be 15.

23:02.950 --> 23:03.700
That's it.

23:03.730 --> 23:05.010
We're able to do that.

23:05.020 --> 23:08.620
Now remember the example I was giving in the production code.

23:08.620 --> 23:17.650
What if you wanted to test five and ten and then test six and 11 and then test seven and 12 or whatever

23:17.650 --> 23:18.700
combinations?

23:18.700 --> 23:25.510
The better you get at testing, you'll realize how many tests you really need to provide adequate coverage.

23:25.510 --> 23:31.180
There's a lot of an art and a science around what's the minimum number of tests you can provide that

23:31.180 --> 23:34.720
maximize your impact, and the code coverage that you have?

23:34.750 --> 23:40.030
So one of the things that I wanted to talk about as part of this particular workshop is what are called

23:40.030 --> 23:41.830
parameterized tests.

23:41.830 --> 23:48.460
So instead of just copying this one, pasting it below, and tweaking the values to add together six

23:48.460 --> 23:55.780
and 11 or 0 and negative ten, we can ask unity to run the same exact test, but passing in some different

23:55.780 --> 23:56.530
values.

23:56.530 --> 23:58.750
There's a lot of different options you have here.

23:58.750 --> 24:00.340
I'm just showing one of them.

24:00.340 --> 24:02.800
But let's take a look down here.

24:03.730 --> 24:10.090
We say, and together that we assume the result is correct when these values.

24:10.090 --> 24:15.640
So the method names a little bit more vague because it's parameterized, I don't necessarily know.

24:15.640 --> 24:18.430
Is this going to test five and ten is 15.

24:18.460 --> 24:24.250
Notice here instead of the what I did before which was declaring five and ten.

24:24.280 --> 24:29.890
In the body of the method I use this particular language, I use something called value source.

24:29.890 --> 24:31.210
And then I pass it in.

24:31.210 --> 24:37.090
What unity does is it populates this first passes values in here.

24:37.090 --> 24:38.740
So let's say it's five.

24:38.770 --> 24:41.290
Then it grabs another value source here.

24:41.320 --> 24:48.010
Let's say that one is ten and it assumes that they are five plus ten added together.

24:48.010 --> 24:52.960
So each time it runs, it's going to do the equivalent of the last test that we saw.

24:52.960 --> 24:59.050
But instead of being hard coded to just one set of values, it's going to mix it up and show a variety

24:59.050 --> 24:59.560
of them.

24:59.560 --> 25:02.460
Now again, there's lots of different ways you can format this.

25:02.460 --> 25:06.670
So you want to look at the documentation for parameterized tests in unity.

25:06.670 --> 25:08.920
But let's look at my specific case here.

25:08.950 --> 25:11.350
Those value sources values A and b.

25:11.350 --> 25:14.770
They just refer to a couple arrays that I've got up here.

25:14.770 --> 25:20.980
And what it's going to do is just step through and it's going to test one and one, negative two and

25:20.980 --> 25:23.530
negative two, negative three and negative three and pass them in.

25:23.560 --> 25:30.070
You could organize them any way you want and test different scenarios where you maybe do seven, 11

25:30.070 --> 25:30.670
and 12.

25:30.700 --> 25:32.230
You test anything you want.

25:32.260 --> 25:35.020
Now you don't have to test infinite amounts there.

25:35.020 --> 25:37.450
This is where that art and science comes along.

25:37.450 --> 25:43.960
You might want to test a couple of negative values zero in some scenarios and a couple of positive values.

25:43.990 --> 25:48.820
Maybe what you're doing is not math based and you want to think about it another way, but what you're

25:48.820 --> 25:51.370
looking for what are called corner cases.

25:51.370 --> 25:57.250
So for example, if you were doing a division method and you wanted to test it mathematically, there's

25:57.250 --> 25:59.740
a challenge about dividing by zero.

25:59.740 --> 26:03.970
So you would want to see that you pass in zero and handle that elegantly.

26:03.970 --> 26:09.040
You really need to know the specific domain that your production code lies in, in order to know how

26:09.040 --> 26:09.730
to test it.

26:09.730 --> 26:14.020
But here a couple of each positive and negative and stuff like that.

26:15.200 --> 26:17.950
So let's look at how that looks in the unity editor.

26:17.960 --> 26:19.670
So notice what it does here.

26:19.670 --> 26:24.980
It actually runs 49 tests based on all the combinations that we've got there.

26:24.980 --> 26:28.850
So it shows you when values are and then it passes in.

26:28.850 --> 26:30.430
So that's really nice.

26:30.440 --> 26:37.430
Now as you're looking at this output you might realize oh it's going to be important to me to test 100

26:37.430 --> 26:38.800
and -100.

26:38.810 --> 26:39.320
Great.

26:39.320 --> 26:45.890
Then just go back and add those sample values in if you want to do other things instead of just a hard

26:45.890 --> 26:46.610
coded list.

26:46.610 --> 26:50.510
If you want to select a random values, there's lots of other options you have there.

26:50.510 --> 26:53.180
Again, do some research on parameterized tests.

26:53.360 --> 26:57.860
You can dig into the play mode test as well if you want, but since that's going to be more interesting

26:57.860 --> 27:02.000
in other examples, we'll move on and conclude this one of the workshops.

27:02.000 --> 27:02.840
Thanks.

27:09.660 --> 27:13.260
Hello and welcome to this Unity Unit testing workshop.

27:13.260 --> 27:16.830
We're going to look at my data loader Basic as an example.

27:16.830 --> 27:17.420
Let's dig in.

27:17.430 --> 27:20.280
So here in this demo I'm going to open up unity.

27:20.280 --> 27:25.650
Open up our core sample project and take a look at the scene of my data loader basic.

27:25.650 --> 27:31.500
Now the reason that I've chosen to do some sort of data loading is just to talk about, well, what

27:31.500 --> 27:39.900
if our unit tests, which we hope are very dependable and isolated and run quickly for the sake of our

27:39.900 --> 27:42.000
own testing methodologies?

27:42.000 --> 27:47.760
What if they depend on other systems, like how do we know that we're able to test just one part?

27:47.790 --> 27:55.740
In general, unit testing is testing a single unit, which you could think of as one method of one class.

27:55.740 --> 28:01.740
But often our code is multiple classes depending together, and that can be a challenge for deciding

28:01.740 --> 28:05.100
how to separate them and test them in isolation.

28:05.100 --> 28:11.280
Also, you could have a system that depends on something asynchronous like rendering graphics, rendering

28:11.280 --> 28:14.760
audio, or in this case, calling a back end server.

28:14.760 --> 28:22.380
So I created a very simple example here that loads data you pass in a URL, it just calls some web page

28:22.380 --> 28:24.630
and gets back the text of that web page.

28:24.660 --> 28:31.410
So this is the simplest example, but you could imagine that this is any server logic calling to send

28:31.410 --> 28:36.540
a high score from your game, calling to load player data, something related to multiplayer.

28:36.540 --> 28:41.250
Perhaps all of those could depend on some asynchronous network traffic.

28:41.340 --> 28:42.330
Let's take a look.

28:42.420 --> 28:44.250
So here we are in the sample.

28:44.250 --> 28:46.290
We've got my data loader basic.

28:46.290 --> 28:46.890
Load it up.

28:46.890 --> 28:47.940
Let's hit play.

28:50.730 --> 28:51.990
In this particular demo.

28:52.020 --> 28:56.550
There's not too real interesting things in this particular demo.

28:56.580 --> 28:58.950
There's not anything too interesting happening at gameplay.

28:59.220 --> 29:02.940
We'll go to the console here and see this scene has no UI.

29:02.970 --> 29:09.300
See the unity console, and then it's just showing the length of what is returned from the server.

29:09.300 --> 29:13.200
Anything not zero signifies hey, it loaded a page.

29:13.200 --> 29:14.670
So very light.

29:14.670 --> 29:15.690
Simple test.

29:15.690 --> 29:19.190
I don't have error checking or these kinds of things built in.

29:19.200 --> 29:23.640
It just assumes success for the sake of the simplicity of this demo.

29:23.670 --> 29:27.780
If you're doing production code and you're calling servers, you'd want to add a lot more functionality

29:27.780 --> 29:28.410
to it.

29:28.410 --> 29:32.770
So that's the runtime experience, which is pretty simple and not that interesting.

29:32.790 --> 29:38.550
Now if we look at the test runner here, we can set our category to be my data loader basic.

29:38.550 --> 29:42.360
So it just shows us the tests related to this particular code.

29:42.360 --> 29:44.160
And then we hit our edit mode.

29:44.160 --> 29:48.210
Here again we have play mode but you can explore that on your own.

29:48.210 --> 29:52.230
I find for this particular demo that edit mode is more interesting.

29:52.230 --> 29:54.660
So I'm going to hit run all.

29:56.330 --> 29:58.350
And we can see we've got success.

29:58.370 --> 30:04.520
This says load async result contains doctype when is loaded.

30:04.520 --> 30:06.500
So let's take a look at a little bit of that.

30:06.630 --> 30:08.780
We'll go here and do open our source.

30:10.200 --> 30:11.820
And here's the test.

30:11.940 --> 30:17.640
It is showing that first we create an instance of our My Data Loader basic.

30:17.940 --> 30:21.660
Then we listen for when it gets loaded.

30:22.610 --> 30:25.880
We'll check on the data loaded back from the server.

30:25.890 --> 30:30.800
Again, this is just calling a web page, and whatever the web page source code is returning it as a

30:30.800 --> 30:32.030
big blob of text.

30:32.030 --> 30:34.370
So it's going to look like some HTML stuff.

30:34.370 --> 30:39.920
And as I looked at it while I was creating this, I noticed that it said doctype as part of it.

30:39.920 --> 30:45.530
So Doctype is not something super significant, certainly not in the unity world, but I just thought

30:45.530 --> 30:49.640
it was some little test that tells me did I get something back from a web page?

30:49.640 --> 30:53.030
You can imagine testing for any other substring that makes sense for you.

30:53.120 --> 31:00.020
Then finally, I do the action here that we're testing upon, and I load the asynchronous call there

31:00.020 --> 31:01.340
and pass in the URL.

31:01.370 --> 31:05.690
Now notice the URL is the URL of the GitHub page.

31:05.690 --> 31:07.280
But that's not so important.

31:07.430 --> 31:08.600
There's nothing unique there.

31:08.600 --> 31:15.620
If you wanted to test like the google.com it will just go and call google.com and get the the source

31:15.620 --> 31:16.820
code back from that.

31:16.820 --> 31:22.220
I don't really want to focus on what I'm doing here in the production code, because it's an admittedly

31:22.220 --> 31:23.330
simple example.

31:23.330 --> 31:28.640
I just wanted it to be a way to get something asynchronous happening inside unity.

31:29.800 --> 31:32.500
So let's look at the source code just so we understand.

31:33.520 --> 31:33.970
Here.

31:33.970 --> 31:34.540
What we're doing.

31:34.540 --> 31:38.740
When I call load, I just say, hey, make sure that the URL is not empty.

31:39.130 --> 31:44.320
Then I go ahead and I use Unity's web request, which is built in functionality.

31:44.320 --> 31:51.520
I call send request on that, and then I set the result to be the download handler's text.

31:51.550 --> 31:53.830
This is just a super cheap, easy way.

31:53.830 --> 31:57.010
Recommended by unity to call simple data online.

31:57.040 --> 31:58.570
Very simple and straightforward.

31:58.600 --> 32:02.860
Now this brings up a question what actually are we testing here?

32:03.280 --> 32:09.580
I have a custom class called my data loader, but inside I'm heavily depending on some existing unity

32:09.610 --> 32:12.160
functionality of unity web request.

32:12.190 --> 32:16.060
Then I'm calling some web page in this case GitHub.

32:16.060 --> 32:17.650
And that's involved.

32:17.650 --> 32:22.810
If GitHub was somehow down for the day, this test would fail.

32:22.840 --> 32:24.100
Is that appropriate?

32:24.100 --> 32:31.000
If my unit test is really about testing my own methodology, my own functionality, I shouldn't consider

32:31.000 --> 32:32.050
it a failed test.

32:32.050 --> 32:34.840
If some unrelated dependency fails.

32:34.840 --> 32:36.610
But here that's the case.

32:36.610 --> 32:38.640
I would fail if GitHub was down.

32:38.650 --> 32:44.440
Also, inside here I'm using Unity web request that's built in functionality by unity.

32:44.470 --> 32:50.920
We hope that it works 100% of the time in all situations, but it's possible that my code works and

32:50.920 --> 32:52.210
its code doesn't work.

32:52.210 --> 32:54.520
So there's a gray area here.

32:54.520 --> 32:59.680
When you think about designing your classes and then designing the tests on those classes, how do you

32:59.680 --> 33:01.990
know what you should actually focus on?

33:01.990 --> 33:04.390
Testing, generally speaking.

33:04.390 --> 33:09.550
And there's books and books written on this subject of how to approach the art of unit testing.

33:09.550 --> 33:15.370
But generally speaking, you want to reduce your dependencies down, and you want to simplify the number

33:15.370 --> 33:17.530
of code lines that you're testing.

33:17.530 --> 33:24.490
So less code is better because it's more simple and focused and you know exactly in isolation which

33:24.490 --> 33:26.020
code you're testing on.

33:26.020 --> 33:28.000
So this is a perfect example.

33:28.000 --> 33:32.950
But for us it's a great way to get started and just talk about asynchronous code running.

33:32.950 --> 33:35.020
So for now we'll end this example.

33:42.300 --> 33:44.460
Hello and welcome to Unit Testing for unity.

33:44.490 --> 33:48.120
We're going to be looking at my data loader in advanced version here.

33:48.120 --> 33:54.270
To see this demo in action we're going to open up unity Download and use the Source sample project for

33:54.270 --> 33:55.020
this course.

33:55.020 --> 33:57.120
And we'll take a look at a key scene here.

33:57.120 --> 33:59.310
That is the My Data loader advanced.

33:59.310 --> 34:05.310
Some of the concepts I'm going to talk about here include dependency injection as we see and end substitute.

34:05.310 --> 34:11.250
Here we are inside unity I've got the scene for the My Data loader advanced ready and ready to go here.

34:11.250 --> 34:16.170
So we'll go ahead and run that scene for quite a lot of these scenes in the workshop.

34:16.170 --> 34:20.940
Running the production scene is not the interesting thing, but I always encourage you to do it just

34:20.940 --> 34:21.990
as a starting point.

34:21.990 --> 34:28.410
So here we see simple console log that says length of the data loaded is this.

34:28.440 --> 34:32.220
That value is not too important, but you can dig into that example class if you want to take a look

34:32.220 --> 34:32.550
at it.

34:32.550 --> 34:34.290
Let's run the test for it.

34:36.660 --> 34:40.200
So up here I've got my category set to my data loader advanced.

34:40.200 --> 34:44.430
So we're only seeing the tests related to that and only in edit mode.

34:44.460 --> 34:47.430
There's also a play mode test you can take a look at on your own time.

34:47.430 --> 34:49.710
But I think that the edit mode is more interesting here.

34:49.710 --> 34:51.600
So I will do run all.

34:57.250 --> 35:01.540
And here we see we've got two tests and they both pass with a green check, which is great.

35:01.570 --> 35:06.590
Let's look at both the load async and the mock load async and take a look at how they work.

35:06.610 --> 35:08.350
So here we are in the sample code.

35:08.350 --> 35:11.260
If you followed along from the last video and I hope you do.

35:11.290 --> 35:18.760
We went over the method that we're looking at here, which uses an actual call to a web server, loads

35:18.760 --> 35:21.000
the data back and checks the value of it.

35:21.010 --> 35:24.460
This closely resembles what the production use case would it be?

35:24.460 --> 35:26.950
But we've talked about some of the problems there.

35:26.980 --> 35:31.150
Am I testing my code or am I testing Unity Web Service underneath it?

35:31.180 --> 35:35.260
Am I testing that or am I testing the back end of github.com?

35:35.260 --> 35:42.130
And if it's a stable server, you want to focus your tests on your own custom code and have as least

35:42.130 --> 35:43.900
and fewest dependencies as possible.

35:43.900 --> 35:46.060
So there's some problems with this.

35:46.090 --> 35:51.990
The first thing that I did when I went about this is to think about dependency injection.

35:52.000 --> 35:58.630
Let's say that in production I want to have one way that I call this and that it is implemented, that

35:58.630 --> 36:00.480
is using Unity web service.

36:00.490 --> 36:04.780
Then for testing, maybe I want to have a second way that I want to approach it.

36:04.810 --> 36:11.890
Now, you could have a flag in your code base that says something like is debug equals true or is production

36:11.890 --> 36:12.790
equals false?

36:12.790 --> 36:17.360
And in your production code, do certain things in test mode and certain things not.

36:17.380 --> 36:21.930
I see a lot of that happen in code bases, but that's generally not a good practice.

36:21.940 --> 36:27.880
You are polluting your production code with really stuff that's only for tests, so it's not as appropriate.

36:27.910 --> 36:29.320
This is a better solution here.

36:29.320 --> 36:30.700
Let's take a look at what we do.

36:31.270 --> 36:37.450
Well, in the previous basic example, I did not have a concept of a network service, nor did I pass

36:37.450 --> 36:38.220
it in here.

36:38.230 --> 36:41.560
We just created it and it always worked one way.

36:41.560 --> 36:45.760
But the dependency injection here is that I decide.

36:45.760 --> 36:49.170
Here's some custom way that this could work.

36:49.180 --> 36:53.380
Here's some of the logic that I could swap out in a few different ways.

36:53.380 --> 36:56.020
I declare it here in one line, and then I pass it in.

36:56.020 --> 36:59.560
So you could imagine having several different network services.

36:59.560 --> 37:04.120
I could have one that's just for testing, one that's just for production, one that just writes to

37:04.120 --> 37:08.680
a local disk, one that is appropriate for a particular backend server.

37:08.680 --> 37:09.460
ET cetera.

37:09.490 --> 37:12.160
This has production use cases as well.

37:12.160 --> 37:14.060
This idea of dependency injection.

37:14.080 --> 37:16.360
Now why do we call it dependency injection.

37:16.360 --> 37:26.080
It's because instead of my data loader advanced always doing one thing, I pass in some info that decides

37:26.080 --> 37:27.610
how it's going to operate.

37:27.610 --> 37:34.090
So rather than the class itself knowing everything here, I'm passing in a dependency in this case to

37:34.090 --> 37:36.250
the Unity Web Request Network service.

37:36.250 --> 37:42.610
So let's take a look at how that structured, and then we'll see why it is helpful for us as we do our

37:42.610 --> 37:43.300
testing.

37:43.390 --> 37:47.140
So here's the complete source code for the My Data loader advanced.

37:47.170 --> 37:49.420
Now two things I want to focus on here.

37:49.420 --> 37:53.530
One is that in its constructor I pass in that dependency.

37:53.560 --> 38:01.060
Now dependency injection and how to create flexible classes from this concept of dependency injection

38:01.060 --> 38:03.700
are really outside of the scope of this class.

38:03.730 --> 38:06.220
It's a really good thing for you to go and look at.

38:06.220 --> 38:12.730
You could google something like D I for unity or dependency injection for unity, or even dependency

38:12.730 --> 38:17.410
injection in object oriented programming, and see some more of those general concepts.

38:17.410 --> 38:23.160
But assuming you have somewhat of a familiarity, especially given my my explanation, I just gave there,

38:23.170 --> 38:24.460
let's move forward with it.

38:24.490 --> 38:31.810
Now that I'm passing in that as a dependency here and storing it, then any time I call our core functionality

38:31.840 --> 38:38.560
of load async, what I do is I say, okay, when I'm ready to load async, just tell my network service

38:38.560 --> 38:39.730
to load async.

38:39.730 --> 38:47.020
Now you can imagine if I've passed in a network service that does a load async for a back end server

38:47.020 --> 38:48.820
of a particular technology.

38:48.850 --> 38:50.410
This line here would do that.

38:50.650 --> 38:56.920
That if I passed in something else that did a writing to disk or reading from disk as a different type

38:56.920 --> 38:59.980
of network service, this is the line here that would really change.

38:59.980 --> 39:06.130
So I don't have to have 2 or 3 different versions of the my data loader advanced here.

39:06.130 --> 39:11.130
Instead, I pass in a custom implementation that handles that particular detail in a unique way.

39:11.140 --> 39:15.130
It's a very powerful way for you to have your code be more flexible.

39:15.130 --> 39:23.410
Now, now that we've talked about passing in a dependency and how it is able to wrap the functionality

39:23.410 --> 39:26.650
here, let's look at what the source for this particular one is.

39:26.650 --> 39:31.240
So up here in the same class file I've got a couple things to talk about.

39:31.240 --> 39:33.580
One, I created an interface.

39:33.700 --> 39:41.230
This interface here of I network service declares okay, anybody who wants to be considered as a viable

39:41.230 --> 39:47.020
dependency to be passed in here has to have some method or methods available.

39:47.020 --> 39:51.970
And in this case, it just needs to have the load async and take a string URL.

39:51.970 --> 39:52.720
That's it.

39:52.750 --> 39:56.620
Now if you're not too familiar with with interfaces.

39:56.940 --> 39:58.560
Please go check out interfaces.

39:58.560 --> 40:04.290
You could look at something like interfaces versus classes in C-sharp or in unity, and you'll see lots

40:04.290 --> 40:05.130
of examples.

40:05.130 --> 40:11.970
But an important distinction here is that the interface defines what the public API is, but it doesn't

40:11.970 --> 40:13.980
worry about doing the implementation.

40:14.100 --> 40:17.530
The implementation is declared down here in a public class.

40:17.560 --> 40:19.710
Now classes you're probably more familiar with.

40:20.010 --> 40:24.570
And what we do here is we implement a particular flavor of that.

40:24.600 --> 40:30.360
I network service in this particular flavor should look very familiar to you from the previous video.

40:30.390 --> 40:32.760
This is the exact same implementation.

40:33.030 --> 40:40.130
We're just using unity web request and then doing its send web request methodology.

40:40.140 --> 40:45.510
So now that we've looked at the source code coming back here, we can see, okay, we're just creating

40:45.510 --> 40:48.270
a custom class that handles a little bit of the functionality.

40:48.270 --> 40:50.520
And we pass that custom class in there.

40:50.520 --> 40:55.010
But we now have a data loader advanced class that is much more flexible.

40:55.020 --> 40:59.720
Now, why specifically in the world of testing, is dependency injection relevant?

40:59.730 --> 41:05.370
Well, we have a wonderful utility that we can use inside unity for our unit testing.

41:05.370 --> 41:10.800
This is a library called N substitute and it's been included here in the sample project.

41:10.800 --> 41:13.980
Let's take a look at another test method just below the other one.

41:13.980 --> 41:17.880
And this is going to use what is called a mock of a class.

41:17.880 --> 41:23.280
So here we have a very similar creation of the My Data loader advanced.

41:23.280 --> 41:29.070
And instead of passing in the unity web request version, we're going to do something that looks quite

41:29.100 --> 41:29.880
odd here.

41:29.880 --> 41:32.940
We're going to use substitute library.

41:32.940 --> 41:40.260
And what we're going to do here is we're going to say hey on the fly in these two lines, go create

41:40.260 --> 41:45.000
me a class that can handle just the functionality I need.

41:45.000 --> 41:51.990
But because it's a mock class, it doesn't necessarily have to actually go call the server.

41:51.990 --> 41:57.450
What it's going to do instead is, at key moments, return a predictable value to us.

41:57.450 --> 42:06.660
Now remember, our flow here is that the test tells the data loader to go load a URL inside the data

42:06.660 --> 42:10.740
loader tells the network service to go load a URL.

42:10.770 --> 42:17.430
That last step, the end result is it takes a half a second, goes and loads from the server and returns

42:17.460 --> 42:18.870
a string back.

42:18.870 --> 42:23.760
So all I really need in a mock situation is okay, don't even call a server.

42:23.760 --> 42:27.330
Just when I call this you give me a string back.

42:27.330 --> 42:36.750
So I'm saying here with this language that I want any time I call load async and I pass in any string

42:36.750 --> 42:41.460
for the URL, then return the word mocked data.

42:41.760 --> 42:48.060
Then down here, I could make sure that I'm getting the expected result that I want, instead of checking

42:48.060 --> 42:52.020
that it has doctype in the return as I did previously.

42:52.020 --> 42:55.740
I can check for the mock data here.

42:55.740 --> 43:04.380
So what we're seeing here is a very simple example, and it might not seem useful, but imagine in a

43:04.380 --> 43:11.580
more complex example where we weren't just loading data, we were loading it, reading, writing, transforming

43:11.580 --> 43:14.850
the data, doing quite a bit, maybe a 5 or 6 different methods.

43:14.850 --> 43:21.150
All of them could be pointing to wildly different systems, but when we really want to test just the

43:21.150 --> 43:30.330
data loader, then we want to pass in mocked abilities for those other systems to be just kind of temporarily

43:30.330 --> 43:34.230
ignored so we can focus on just what we have at hand here.

43:34.260 --> 43:36.450
Now let's take a look at what would happen.

43:36.450 --> 43:38.940
So I call the load async.

43:38.940 --> 43:46.050
What's going to happen is this system inside is going to return the predicted value.

43:46.050 --> 43:50.220
And the data loader is then going to call loaded.

43:50.220 --> 43:56.160
And it's going to have its result value be the value that we expect it to be.

43:56.160 --> 44:00.330
So let's run this inside the unity editor.

44:00.330 --> 44:01.800
So we'll hit run all here.

44:04.100 --> 44:05.480
And it works quite quickly.

44:05.480 --> 44:11.270
Let's even compare if I just run load async which is actually calling a server.

44:15.200 --> 44:16.220
It was quick.

44:16.250 --> 44:20.690
Then if I call mock load async which is not calling any server.

44:24.630 --> 44:29.840
May not be evident from the video, but it's much faster to call the MOC.

44:29.850 --> 44:35.150
And that makes sense because we're not actually calling a server and waiting for a result.

44:35.160 --> 44:38.640
So this isn't just to save us a few seconds.

44:38.670 --> 44:42.270
It's again for us to focus as we're designing our tests.

44:42.300 --> 44:44.790
What actually do we want to test?

44:44.790 --> 44:46.920
And then we want to isolate it.

44:46.920 --> 44:51.160
So we're not actually testing a Unity Web Services class.

44:51.180 --> 44:53.610
We're not testing a GitHub back end.

44:53.700 --> 44:57.470
Testing several systems together is called an integration test.

44:57.480 --> 44:59.550
That is an appropriate type of test.

44:59.550 --> 45:03.660
But it's outside of what we're talking about here, which is unit testing.

45:03.660 --> 45:08.430
Again, getting down to as few dependencies as possible, few lines of code.

45:08.430 --> 45:09.450
You could think about it.

45:09.450 --> 45:17.880
So that's it there we've looked at how to use the substitute library and how also we can do a mock for

45:17.880 --> 45:19.710
a call to the back end server.

45:19.710 --> 45:20.550
So thanks.

45:26.450 --> 45:29.420
Hello and welcome to Unit testing for unity.

45:29.450 --> 45:30.710
We're in the workshop here.

45:30.710 --> 45:34.850
And in this one we're going to take a look at the character in a basic form.

45:34.850 --> 45:37.070
We're going to have a few different ones we're going to look at.

45:37.100 --> 45:39.800
We'll start with the basics and move on to something more advanced.

45:39.800 --> 45:41.480
Let's take a look at this demo in action.

45:41.480 --> 45:42.920
Inside the unity editor.

45:42.920 --> 45:45.830
We're going to open up unity, open up our sample project.

45:45.830 --> 45:49.760
And then we're going to play one or more scenes related to the topic here.

45:49.760 --> 45:55.670
The scene is going to be the character basic, and I'm going to be talking about Monobehaviour as something

45:55.670 --> 46:01.160
that can or can't be tested, as well as play mode versus edit mode, something that I've mentioned

46:01.160 --> 46:02.450
earlier in the course.

46:02.450 --> 46:04.010
We'll bring it back here and talk about it.

46:04.010 --> 46:06.380
Here we are in the project looking at the character basic.

46:06.380 --> 46:07.760
Let's go ahead and run the scene.

46:13.120 --> 46:20.020
So while most of our workshops we've done already had a pretty boring scene where absolutely nothing

46:20.050 --> 46:22.830
of interest was happening here, we have a little bit more.

46:22.840 --> 46:28.470
When we hit play there, we see a cube white cube that gets made created in the center of the screen.

46:28.480 --> 46:31.030
I can use my arrow keys and move around.

46:31.030 --> 46:37.930
So while admittedly a very simple example here, this is meant to talk about some of the more complex

46:37.930 --> 46:40.600
aspects of testing inside unity.

46:40.630 --> 46:45.730
In the previous scenes, we weren't worried about rendering graphics or taking input.

46:45.970 --> 46:52.840
We did talk in the last workshop about the difference between testing several different dependencies

46:52.840 --> 46:53.590
together.

46:53.590 --> 46:58.780
For example, a method that inside calls a second method that inside calls a third.

46:58.810 --> 47:00.490
Those are dependencies.

47:00.520 --> 47:06.790
Here we're talking about a similar aspect, except every time I want to move my character, I first

47:06.790 --> 47:13.750
ask to listen to Unity's input system, then use Unity's Monobehaviour transform movement.

47:13.750 --> 47:14.190
Right.

47:14.200 --> 47:18.820
So we're we're using several different dependencies there or different classes.

47:21.360 --> 47:24.630
So here I'm able to use the arrow keys to move around.

47:25.750 --> 47:27.190
And that's pretty much it.

47:29.010 --> 47:32.100
But the idea is we're doing a bit more than before.

47:32.190 --> 47:34.650
Let's talk about the implications of testing that.

47:34.650 --> 47:41.190
So up here in the test runner, I have the category set to our character basic, which is great.

47:41.220 --> 47:46.800
Then I can toggle on to see the play mode tests as well as the edit mode tests.

47:46.830 --> 47:53.100
We can see that we've got some of both, but because there's a monobehaviour involved, I'm going to

47:53.100 --> 47:54.600
focus more on the play mode.

47:54.630 --> 48:01.230
Now, in each of the workshops, I've included at least one edit mode test and at least one play mode

48:01.260 --> 48:03.420
test for the scene at hand.

48:03.450 --> 48:09.030
I've done that again here, but depending on what you're actually testing, you want to think, is this

48:09.030 --> 48:13.470
more appropriate for edit mode or is it more appropriate for play mode?

48:13.500 --> 48:18.510
There's an art and a science to how you'd approach that, and how you would design your code to be more

48:18.510 --> 48:19.170
testable.

48:19.200 --> 48:26.010
But a general way to look at it that's relevant for here is that if you're using Monobehaviour functionality,

48:26.010 --> 48:32.460
that sounds more like a play mode test, the more unity libraries, particularly at runtime, you're

48:32.460 --> 48:36.840
using in your production, you want to think about those being play mode tests.

48:36.870 --> 48:40.410
It's not a hard rule, but that's a good way to start thinking about it.

48:40.650 --> 48:42.490
So let's run our tests here.

48:42.510 --> 48:45.300
I have the play mode and I will run all.

48:48.880 --> 48:49.210
Okay.

48:49.240 --> 48:52.060
It took a couple seconds to run there, but we've got them all.

48:52.090 --> 48:58.060
What actually happens when you're running a play mode test is it creates a brand new empty scene and

48:58.060 --> 49:01.840
runs just one test inside of it, and it destroys that.

49:01.840 --> 49:09.040
And it creates a brand new scene guaranteeing that we have the world space provided by a scene.

49:09.040 --> 49:16.000
But the freshness of a new scene that doesn't have any dependencies or stale info that might influence

49:16.000 --> 49:16.630
the test.

49:16.630 --> 49:18.230
So we like how that's set up.

49:18.250 --> 49:25.030
Now, the things that I'm doing are moving, moving by key code and moving to a particular place.

49:25.030 --> 49:27.640
So let's take a look at this move to test.

49:29.650 --> 49:31.990
Actually, let's take a look at the production code first.

49:31.990 --> 49:34.960
So if I go here and I look at the basic example.

49:36.760 --> 49:38.560
This is the production code.

49:38.560 --> 49:40.720
Let's look at that before I go into the tests.

49:40.720 --> 49:43.960
So here all I do is I create a primitive.

49:43.990 --> 49:49.030
You could imagine also loading a prefab here if you wanted to do that.

49:49.030 --> 49:54.010
But I wanted to slowly get us into all the complexities of runtime and unity.

49:54.010 --> 49:56.140
So I'm not using a prefab here.

49:56.140 --> 50:00.130
I just create a brand new cube from scratch with a line of code.

50:00.130 --> 50:06.820
I give it a name there just for organization sake, and then I add the component of the monobehaviour

50:06.820 --> 50:08.620
that I want to actually test.

50:08.650 --> 50:14.770
Then one of the things that I'm doing is just moving it to the point of 000, and then showing that

50:14.770 --> 50:16.300
value out on the screen.

50:16.300 --> 50:18.850
So let's take a look at the source code here.

50:21.530 --> 50:22.960
Here's character basic.

50:22.970 --> 50:24.770
This extends Monobehaviour.

50:24.800 --> 50:32.730
Now, if you're familiar with unity, you probably use Monobehaviours all the time as a good best practice.

50:32.750 --> 50:35.600
You want to start thinking conscientiously.

50:35.600 --> 50:40.660
When is it appropriate to use a monobehaviour and when can I use something different?

50:40.670 --> 50:46.580
As beginning developers, we create everything as a child of monobehaviour, but with time and experience

50:46.580 --> 50:49.900
you realize there's pros and cons of using monobehaviours.

50:49.910 --> 50:54.620
One of the cons is historically, it was more difficult to test along the way.

50:54.620 --> 50:56.570
Unity provided these playmode tests.

50:56.570 --> 51:00.950
So now we can certainly test Playmode and we can test Monobehaviours.

51:00.950 --> 51:03.630
So that's great, but there's still some drawbacks.

51:03.650 --> 51:08.330
Again, Monobehaviour is going to rely on more systems of unity under the hood.

51:08.330 --> 51:13.700
And when we're trying to test our custom code, we might not be sure where a problem might lie.

51:13.730 --> 51:15.720
Is it our code or is it Unity's code?

51:15.740 --> 51:18.110
So again, there's a few dependencies there.

51:18.140 --> 51:22.280
This is all okay, but it's something you want to think about as you're designing your classes and as

51:22.280 --> 51:23.690
you're designing your tests.

51:24.110 --> 51:27.080
So we've got a movement speed.

51:27.110 --> 51:28.460
We've got a movement type.

51:28.460 --> 51:31.390
This is just the direction of the arrow key that I'm pressing.

51:31.400 --> 51:33.680
Then we use the Unity's update.

51:33.710 --> 51:36.530
Now really let me double check here.

51:38.720 --> 51:39.230
Really.

51:39.230 --> 51:44.960
The update loop here is the only major monobehaviour functionality that I'm using.

51:44.990 --> 51:49.130
The rest of this code doesn't necessarily have to be in a monobehaviour.

51:49.220 --> 51:53.560
I am also using Unity's input system, so that's a second dependency.

51:53.570 --> 51:56.760
So let's see what I do every frame of update.

51:56.780 --> 51:59.360
I call this method here move by input.

51:59.390 --> 52:04.340
I check to see is the user hitting a particular key or keys on the keyboard.

52:04.340 --> 52:08.360
And then I call move by key code down here.

52:09.710 --> 52:16.220
All we do is say, if we're currently moving left, then let's move in a vector for the left direction.

52:16.220 --> 52:19.820
If we're currently moving right and etcetera for up and down.

52:19.820 --> 52:24.860
So this would allow you to move in all four of the directions using the four arrow keys.

52:24.860 --> 52:26.420
So pretty straightforward code.

52:26.420 --> 52:30.440
And if you've created your own custom character before you'd be familiar with setting something like

52:30.440 --> 52:30.980
this up.

52:34.010 --> 52:35.870
Down here, we've got two methods.

52:35.870 --> 52:41.240
One that lets us move to a particular point and one that lets us move by a unit.

52:41.240 --> 52:44.090
So let's say I wanted to move the right one unit.

52:44.090 --> 52:48.490
I could pass in by one unit by one unit by one unit.

52:48.500 --> 52:53.740
If I want to move directly to a particular point in space, that would be the move to.

52:53.750 --> 52:59.810
So these are not necessarily the only methods you would need in a custom character class, but there's

52:59.810 --> 53:01.100
some pretty common ones.

53:01.100 --> 53:07.850
So we'll end this lesson here with just this as a basic, appropriate working way to test some functionality.

53:07.850 --> 53:13.340
If you want to take a look at the edit mode or the other tests that are here in the play mode, go ahead

53:13.340 --> 53:14.230
and do that.

53:14.240 --> 53:15.830
I'll move on to the next video.

53:15.830 --> 53:16.580
Thanks.

53:22.920 --> 53:26.060
Hello and welcome to Unit Testing for unity.

53:26.070 --> 53:30.060
In this workshop we're looking at the character class in an advanced version.

53:30.060 --> 53:31.980
Let's take a look at this demo in action.

53:31.980 --> 53:32.310
Here.

53:32.310 --> 53:33.990
We're going to open up our unity.

53:34.020 --> 53:36.000
We're going to open up our sample project.

53:36.000 --> 53:41.190
And we're going to take a look at a scene inside for the character advanced situation here.

53:41.190 --> 53:44.310
I want to talk a little bit about code separation.

53:44.340 --> 53:49.110
Earlier in one of the workshops, I talked about the different dependencies that you'd have.

53:49.110 --> 53:51.360
For example, if you're calling a back end server.

53:51.360 --> 53:58.530
And in that situation, we used a substitute library to mock out and not need to call the back end.

53:58.560 --> 54:04.890
It's a similar discussion here where we're looking at what are the dependency involved with a particular

54:04.890 --> 54:11.640
test scenario, and how do we be aware of those different dependencies, and what do we want to do about

54:11.640 --> 54:12.240
it here?

54:12.240 --> 54:14.400
We're not going to use the substitute library.

54:14.430 --> 54:18.960
We're going to think about separating our monobehaviour from other code and taking a look.

54:19.170 --> 54:20.940
So here we are inside unity.

54:21.270 --> 54:22.440
We've got a production class.

54:22.440 --> 54:23.250
Let's take a look at it.

54:23.250 --> 54:23.850
Running.

54:27.540 --> 54:30.510
Down here, we see that we can move around with our arrow keys.

54:30.510 --> 54:34.050
Just like in the basic example, the end user experience is the same.

54:34.050 --> 54:39.330
And that's something of an interesting example here, that some of the changes that we do for the code

54:39.330 --> 54:44.250
quality and testability of our systems doesn't necessarily impact the end user.

54:44.280 --> 54:45.350
That's a positive.

54:45.360 --> 54:48.270
So let's take a look at the production code here.

54:48.270 --> 54:50.340
We'll open up the character advanced example.

54:50.340 --> 54:51.890
Here's a complete example.

54:51.900 --> 54:57.830
What we're doing inside the wake of this example class is we're creating a primitive for the cube.

54:57.840 --> 55:00.270
We give it a name for organization sake.

55:00.390 --> 55:08.010
Then instead of one line here where we just add a component that has all of our functionality, we do

55:08.010 --> 55:09.180
two steps.

55:09.450 --> 55:14.700
This is reminding me a little bit of the dependency injection we saw in the My Data loader example.

55:14.700 --> 55:17.970
But this is a different use case with different dependencies.

55:17.970 --> 55:22.920
So instead of just one add component line we do the add component.

55:22.920 --> 55:28.260
And then we create our own non monobehaviour character advanced class.

55:28.260 --> 55:30.540
And we pass in the Monobehaviour.

55:30.540 --> 55:35.370
So we're passing in the dependency that the character advanced is going to use.

55:35.400 --> 55:41.910
Now character advanced is not a monobehaviour, and thereby we have more flexibility with how we want

55:41.910 --> 55:42.480
to test it.

55:42.510 --> 55:45.780
We could test it at edit mode for example, more easily.

55:45.930 --> 55:51.000
Again, whenever you're using Monobehaviours that's more appropriate for play mode tests.

55:51.030 --> 55:53.940
It's not a hard rule, but that's one way to think about it.

55:53.940 --> 56:00.660
So here, by separating our monobehaviour from our non monobehaviour, we've got a few more options.

56:00.690 --> 56:06.060
Now we're still here in a play play mode environment because this is the production code.

56:06.060 --> 56:08.970
Let's step in and see how our source code is changed.

56:08.970 --> 56:11.010
So here we are in the character advanced.

56:11.040 --> 56:13.220
You'll see that it looks pretty familiar.

56:13.230 --> 56:17.790
Most of the code in here is going to be just like the previous basic example.

56:17.800 --> 56:19.080
The few exceptions.

56:19.090 --> 56:25.710
One is that the character advanced is going to take in a reference in its constructor to the Monobehaviour.

56:25.710 --> 56:30.900
This is because it needs to know some things about the Monobehaviour, particularly around its transform

56:30.900 --> 56:31.710
position.

56:31.830 --> 56:38.400
There's also a situation where we need to use the second line and tell the Monobehaviour a reference

56:38.400 --> 56:40.830
back to us as the character advanced.

56:40.860 --> 56:47.460
This is just so that the Monobehaviour, whenever it calls update can tell us to do the proper move.

56:47.490 --> 56:52.950
There's other ways you could organize this, but for simplicity's sake, we're passing in the monobehaviour

56:52.950 --> 56:54.360
and handling it this way.

56:54.660 --> 56:57.150
Let's see what other changes we see in the code base.

56:58.510 --> 57:00.820
The move type is the same as the basic.

57:00.850 --> 57:03.040
The move by input is the same.

57:03.940 --> 57:08.260
Down here the move by key code is very similar, if not identical.

57:09.300 --> 57:15.630
And then down here in the move to and move by, you can notice that we are getting and setting the position

57:15.630 --> 57:18.300
on the transform of the Monobehaviour.

57:18.300 --> 57:25.260
So again we have mostly a non monobehaviour class here doing what it can do without any dependency on

57:25.260 --> 57:30.810
monobehaviour and only in the most necessary spots does it address the Monobehaviour.

57:30.840 --> 57:36.840
That separation begins to help us think about how could we test just the monobehaviour if we could,

57:36.840 --> 57:39.910
how could we test just the non monobehaviour if we could?

57:39.930 --> 57:45.240
Now, this isn't a perfect example because it's kind of the mid step as we're going along learning about

57:45.240 --> 57:47.040
how we can properly separate these.

57:47.040 --> 57:48.600
But I think it's a good learning.

57:48.600 --> 57:52.500
So look at the source code here for character advanced.

57:52.500 --> 57:56.550
Compare it to character basic on your own time and see the differences there.

57:56.730 --> 57:59.580
Then let's take a look at the example that we do.

57:59.580 --> 57:59.970
Again.

57:59.970 --> 58:01.500
Here's the example that we saw.

58:01.500 --> 58:02.670
So it's these two lines.

58:02.670 --> 58:03.900
That's really the key.

58:03.930 --> 58:09.960
We're going to add a component of the character advanced Monobehaviour onto our game object.

58:09.960 --> 58:12.270
And then we're going to create a new character advanced.

58:12.270 --> 58:13.440
That's a separate step.

58:13.440 --> 58:17.010
So you could imagine we would be able to test those two things in isolation.

58:17.010 --> 58:19.320
Now they are quite dependent on each other.

58:19.350 --> 58:24.000
There's ways that we could massage that so that one does not directly depend on the other.

58:24.000 --> 58:30.330
Or we could do something like we did in the data loader example and use a substitute library so that

58:30.330 --> 58:32.730
we're mocking in the dependency instead.

58:32.730 --> 58:38.400
But again, for simplicity of just learning how to separate a monobehaviour apart, I think we've done

58:38.400 --> 58:39.210
the case here.

58:39.210 --> 58:44.100
You can run those tests with the edit mode and the play mode on your own time and take a look at this.

58:44.370 --> 58:50.460
But for me, I think we're done talking about the differences in separating monobehaviour and non monobehaviour.

58:50.490 --> 58:51.120
Thanks.

58:57.320 --> 58:59.600
Hello and welcome to Unit Testing for unity.

58:59.630 --> 59:02.630
This is our workshop talking about character physics.

59:02.660 --> 59:09.110
Now in previous workshops we've slowly moved from a very simple character example, moving with arrow

59:09.110 --> 59:14.960
keys to the advanced example separating Monobehaviour and non monobehaviour concerns.

59:14.960 --> 59:20.900
And here in this one we're going to talk about what if we depend on yet another unity system like physics.

59:20.900 --> 59:26.720
And also when we're using physics in this particular example our movement becomes fuzzier.

59:26.720 --> 59:30.890
Meaning I don't click left and it immediately clicks to a position.

59:30.890 --> 59:32.930
It slowly moves over time.

59:32.930 --> 59:37.100
How would we be able to test the value that is slowly changing over time?

59:37.100 --> 59:40.220
So we'll talk about a few of those things here in the source code.

59:40.220 --> 59:45.290
So to take a look at this demo, we are opening up our unity editor and the sample project.

59:45.290 --> 59:48.020
The scene here is going to be the character physics scene.

59:48.020 --> 59:51.720
And one of the things we're going to be looking at is how to test those fuzzy values.

59:51.740 --> 59:58.640
I called it again, fuzzy values to me is values that aren't necessarily instantaneous, changing from

59:58.640 --> 1:00:05.960
A to B, they slowly animate over time, such as the position of an object or a score that gradually

1:00:05.960 --> 1:00:06.890
counts up.

1:00:06.920 --> 1:00:12.110
These are all areas where you'd want to be able to test something over time, and we have one easy approach

1:00:12.110 --> 1:00:13.250
here to do that.

1:00:13.250 --> 1:00:17.750
It's not the only way to solve it, but it's one that I think helps us learning along the way.

1:00:17.750 --> 1:00:18.770
So let's take a look.

1:00:18.770 --> 1:00:20.420
So here we are in the unity project.

1:00:20.420 --> 1:00:22.940
We've got the character physics example open.

1:00:22.940 --> 1:00:24.500
Let's go ahead and run the scene.

1:00:30.610 --> 1:00:33.520
Now here I'm able to move using the arrow keys.

1:00:37.390 --> 1:00:42.970
And in previous examples here in the workshop, we've seen it click over every click I did on the left

1:00:42.970 --> 1:00:48.430
arrow, the position would click instantaneously changing, but here there's a smoother movement.

1:00:49.060 --> 1:00:54.250
I can still use all the arrow keys to direct different traffic of which way it should go, but the idea

1:00:54.250 --> 1:00:58.030
of it moving slowly over time is really the novel situation now.

1:00:58.030 --> 1:01:03.790
There's lots of ways you could do that in unity, but I chose to use the physics system just to talk

1:01:03.790 --> 1:01:08.920
a little bit about what happens if we've got a few more unity systems involved.

1:01:08.920 --> 1:01:10.960
Remember what we've been stretching with?

1:01:10.960 --> 1:01:18.130
And as an idea here is that in an ideal world, you get your unit testing to test the fewest lines of

1:01:18.130 --> 1:01:21.760
dependency, fewest lines of code at once.

1:01:21.760 --> 1:01:25.600
But a lot of times our production code isn't so simplistic.

1:01:25.600 --> 1:01:27.520
We are depending on different things.

1:01:27.520 --> 1:01:33.370
So with my data loader and with previous character examples here, we've seen some of the ways to handle

1:01:33.370 --> 1:01:35.080
those different dependencies.

1:01:35.200 --> 1:01:38.260
This is one more example a little bit more complex than the rest.

1:01:38.290 --> 1:01:40.240
Let's take a look at the production code here.

1:01:40.240 --> 1:01:43.120
So here we'll look at the character physics example.

1:01:44.530 --> 1:01:45.790
We open that up?

1:01:47.210 --> 1:01:50.570
And here we've got creating a character primitive.

1:01:51.320 --> 1:01:59.840
Here we create the game object first with the cube in appearance for the primitive, and then we add

1:01:59.840 --> 1:02:03.500
the component of the character physics monobehaviour.

1:02:03.500 --> 1:02:07.070
And then we have a separate character physics class that we take that in there.

1:02:07.070 --> 1:02:12.740
So we're already separating from one monolithic class of monobehaviour into two.

1:02:12.740 --> 1:02:18.350
So that's a good way to get our code more simplistic and doing a single purpose each in there.

1:02:18.350 --> 1:02:25.640
We saw in the previous example that most of the Monobehaviour functionality we needed was just the update.

1:02:25.640 --> 1:02:27.680
That's the only thing we really needed to take care of.

1:02:27.710 --> 1:02:33.110
So by moving all the non update stuff into the second class, we now have something that's easier to

1:02:33.110 --> 1:02:33.740
test.

1:02:36.450 --> 1:02:39.570
Then in this simple example, we moved to a particular position.

1:02:39.600 --> 1:02:43.710
Now let's run the tests and then let's take a look at the production code.

1:02:43.740 --> 1:02:46.500
So here let's take a look at running the selected.

1:02:48.580 --> 1:02:49.830
It's all running there.

1:02:49.850 --> 1:02:50.850
Everything passes.

1:02:50.870 --> 1:02:52.640
Now that's just the play mode test.

1:02:52.640 --> 1:02:57.110
But we have also got edit mode tests if you want to dig in and take a look at it again, because we're

1:02:57.110 --> 1:02:58.950
dealing with monobehaviour stuff.

1:02:58.970 --> 1:03:01.340
It feels more appropriate to use a play mode.

1:03:01.340 --> 1:03:02.990
So that's the approach I've done here.

1:03:02.990 --> 1:03:06.470
But it's up to you and your project to decide which systems you want to test.

1:03:06.500 --> 1:03:08.230
Edit mode and which ones you want to test.

1:03:08.240 --> 1:03:08.840
Play mode.

1:03:15.570 --> 1:03:21.000
So now that we've seen those tests, let's take a quick look here at the source code for the class.

1:03:21.000 --> 1:03:22.660
And then we'll look at some of the tests on top.

1:03:22.710 --> 1:03:22.860
All right.

1:03:22.860 --> 1:03:24.780
So here we are in the character physics.

1:03:24.810 --> 1:03:28.870
We're going to see it's pretty similar to the character advanced we saw last.

1:03:28.890 --> 1:03:32.850
Again we've separated the Monobehaviour and the non monobehaviour class.

1:03:32.850 --> 1:03:36.630
So here is the non monobehaviour class that's doing most of the work.

1:03:36.660 --> 1:03:42.840
Notice here inside its constructor it takes a reference to the Monobehaviour and stores it and then

1:03:42.840 --> 1:03:47.670
also passes into the Monobehaviour a reference to this class here.

1:03:47.670 --> 1:03:51.900
That's so that it can call the move by every time it does an update.

1:03:51.930 --> 1:03:53.970
Now there's different ways you could organize that.

1:03:53.970 --> 1:03:57.810
You could even remove the hardcoded dependency we have on each other here.

1:03:57.810 --> 1:04:01.350
But for the sake of simplicity in this example, this is very appropriate.

1:04:01.740 --> 1:04:02.790
Going down the code.

1:04:02.790 --> 1:04:05.820
Again, it's just like the advanced in most parts.

1:04:05.850 --> 1:04:08.670
I'll do want to call out where there's physics being used.

1:04:08.670 --> 1:04:16.920
So here in movement, instead of just moving by the position hardcoded over one instance Taneous update,

1:04:16.950 --> 1:04:20.340
we're going to be using the move position here.

1:04:20.340 --> 1:04:25.890
And then under Add force, which is a new method that I did that is going to be moving based on physics

1:04:25.890 --> 1:04:26.580
forces.

1:04:26.580 --> 1:04:30.630
So imagine this is a block and we're giving a push on one side.

1:04:30.630 --> 1:04:36.390
And then based on friction and mass and gravity, you know there's some sort of consequence that tends

1:04:36.390 --> 1:04:39.240
to be a fuzzier reaction here using the add force.

1:04:39.240 --> 1:04:45.570
And we're moving by add force up here at the top of the same class file we see the physics monobehaviour

1:04:45.600 --> 1:04:46.590
is declared.

1:04:46.590 --> 1:04:52.560
It's pretty familiar in that the same character advanced we saw in the last workshop looks pretty similar,

1:04:52.560 --> 1:04:55.350
but we do have a rigid body here that we're storing.

1:04:55.350 --> 1:05:02.010
And then when this class wakes up, we do some attaching of the rigid body and then set some physics

1:05:02.010 --> 1:05:02.670
values.

1:05:02.670 --> 1:05:09.450
So if we think about just kind of recapping instead of having one monobehaviour that does all the physics

1:05:09.450 --> 1:05:14.220
and movement together, we've separated the monobehaviour from the non monobehaviour.

1:05:14.250 --> 1:05:20.520
Then inside the Monobehaviour we do the update loop and we also take care of some physics stuff.

1:05:20.610 --> 1:05:26.550
Then from the other one, the non monobehaviour, we're able to move as we want and take character input,

1:05:26.580 --> 1:05:28.470
so take keyboard input and stuff like that.

1:05:28.470 --> 1:05:32.940
So it's a pretty good separation here and gets us going with what we need.

1:05:34.100 --> 1:05:37.820
Let me think out loud if there's anything else I wanted to mention about this.

1:05:38.330 --> 1:05:40.430
Um, yeah.

1:05:40.430 --> 1:05:42.620
So I teased about the idea here.

1:05:42.620 --> 1:05:50.720
If you wanted to reduce the hardcoded dependency that we have each class depending on each other and

1:05:50.720 --> 1:05:56.270
get more of the flexibility that we saw in the My Data loader example, you could certainly declare

1:05:56.270 --> 1:05:58.670
interfaces and address it that way.

1:05:58.970 --> 1:06:00.680
But we don't need to do that here.

1:06:00.680 --> 1:06:03.370
We'll just go back and run the example one more time.

1:06:03.380 --> 1:06:07.700
So back here in unity we're running and we've got the arrow keys moving around.

1:06:07.730 --> 1:06:13.130
In the last few videos we've seen examples of reducing complexity.

1:06:13.130 --> 1:06:17.870
So reducing different dependencies some flexibility to separate our code out.

1:06:17.870 --> 1:06:23.480
So for the sake of this example here using input and physics and monobehaviours or stuff like that I

1:06:23.480 --> 1:06:24.620
think we're all done here.

1:06:24.650 --> 1:06:25.340
Thanks.

1:06:31.470 --> 1:06:31.730
Hi.

1:06:31.740 --> 1:06:37.470
That covers a lot of the different topics that I wanted to have in the workshop so far, but there's

1:06:37.470 --> 1:06:39.990
plenty of room for more topics in the future.

1:06:39.990 --> 1:06:42.390
We've seen in the workshops covered so far.

1:06:42.390 --> 1:06:49.350
This simplest example learning the test runner, seeing how we can make playmode tests, edit mode tests,

1:06:49.380 --> 1:06:54.870
learning a little bit about the differences of play mode and edit mode, and why you would want to test

1:06:54.870 --> 1:06:57.350
in one or the other, or both.

1:06:57.360 --> 1:07:03.510
Then we also saw some of the options we have when we have asynchronous functionality, or when we're

1:07:03.510 --> 1:07:05.460
dependent on other systems.

1:07:05.460 --> 1:07:09.990
What could we do to reduce that dependency for the sake of the test?

1:07:10.020 --> 1:07:15.180
Along the way there, we're learning some different things about dependency injection and separating

1:07:15.180 --> 1:07:16.650
the concerns of our code.

1:07:16.680 --> 1:07:22.710
Those principles are useful in production code anyway, and we're beginning to see some of the ways

1:07:22.710 --> 1:07:29.850
that when you prepare your code to be more testable, we're also creating code that is designed well

1:07:29.850 --> 1:07:31.080
for production.

1:07:31.080 --> 1:07:37.710
So having dependency injection allows flexibility that you can use at runtime, reducing the complexity

1:07:37.710 --> 1:07:44.370
of your systems by passing in flexible varieties of different dependencies when you need to.

1:07:44.400 --> 1:07:51.960
We've also seen by separating a monolithic large monobehaviour into just what we need from the monobehaviour

1:07:51.960 --> 1:07:58.620
and moving the other code into a lighter weight non monobehaviour class, we again get some flexibility

1:07:58.620 --> 1:08:03.570
that is useful in production and also helps us here in the testing world.

1:08:03.570 --> 1:08:10.170
I think overall some of the challenges that we're seeing are what happens when you have multiple dependencies

1:08:10.200 --> 1:08:14.670
or lots of systems called from one particular method.

1:08:15.060 --> 1:08:20.700
That might be a sign that that method is bloated and doing too much, or it might be a sign that it's

1:08:20.700 --> 1:08:23.130
a lean and appropriate designed one.

1:08:23.130 --> 1:08:28.800
But we need to have some additional thoughts and considerations when we go to testing that functionality.

1:08:28.800 --> 1:08:31.050
So I hope this has been helpful for you.

1:08:31.050 --> 1:08:38.130
I look forward to covering even more topics in this series as well, and they'll be added again in over

1:08:38.130 --> 1:08:38.610
time.

1:08:38.610 --> 1:08:39.750
So thanks again.
