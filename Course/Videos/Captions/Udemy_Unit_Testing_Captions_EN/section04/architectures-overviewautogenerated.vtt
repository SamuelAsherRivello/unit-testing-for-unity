WEBVTT

00:00.330 --> 00:02.580
Now let's look at architectures.

00:03.000 --> 00:08.190
A software architecture is the fundamental organization of all of its parts.

00:08.190 --> 00:13.880
We'll see that architectures are built on top of design principles and patterns.

00:13.890 --> 00:18.210
Benefits include that these are proven solutions to repeatable problems.

00:18.210 --> 00:25.080
By organizing our project in a bespoke way, we can bring confidence, scalability, performance and

00:25.080 --> 00:26.490
more to our projects.

00:26.490 --> 00:32.670
Software architectures are typically high level and could be applied to various languages or platforms,

00:32.670 --> 00:39.420
and also by using them, we can have faster development as well as easier time in the maintenance phases

00:39.420 --> 00:40.560
of our projects.

00:40.560 --> 00:46.140
Now, while we often think as developers that our job is adding new features and that that's the majority

00:46.140 --> 00:53.880
of our experience, research shows that 80% of the time on a software project is maintaining the code.

00:54.000 --> 01:00.660
So by making choices for architectures, design principles and patterns up front and applying them throughout

01:00.660 --> 01:06.960
our project, when we are adding features, that large maintenance phase can be easier and raise our

01:06.960 --> 01:09.180
quality of life from a high level.

01:09.180 --> 01:15.960
Some types of architectures are the no architecture approach, typically young teams or individuals

01:15.960 --> 01:17.550
who are getting into software.

01:17.550 --> 01:23.550
We'll do what feels right in the moment without some larger perspective or vision for the project.

01:23.550 --> 01:25.080
But ultimately we'll see.

01:25.080 --> 01:26.400
We need something else.

01:26.400 --> 01:32.790
Veteran teams can use custom architectural solutions where they look at the unique needs of a team and

01:32.790 --> 01:39.420
the product that they're creating, employing a library of those principles and patterns and create

01:39.420 --> 01:40.710
their own solution.

01:40.710 --> 01:46.830
There are pros and cons to this approach, and another key type is using an established architecture,

01:46.830 --> 01:52.460
something we can pull off the shelf and apply in a prescriptive manner to our projects.

01:52.470 --> 02:01.740
These include MVP and VC and VM, and there's many, many more we'll look at the details of these.

02:02.010 --> 02:08.700
So while it feels quite natural to just develop as we go and do what feels right in the moment, this

02:08.700 --> 02:11.190
no architecture approach has drawbacks.

02:11.190 --> 02:16.710
Whether you're an individual or on a small team, there will be more debate on how to add each feature

02:16.710 --> 02:22.860
since you don't have a recipe that leads to inconsistencies over the life of one developer and across

02:22.860 --> 02:28.110
each other developer on the team, that means applying re factors becomes more challenging because there's

02:28.110 --> 02:30.570
all subtle variations in the code base.

02:30.840 --> 02:37.100
It becomes much more difficult to read the code one day later, one week later or one year later.

02:37.110 --> 02:43.410
Also, when you're bringing new team members on or taking team members off of the project, it's more

02:43.410 --> 02:44.640
labor intensive.

02:44.670 --> 02:47.430
You have to do more custom explanations.

02:47.430 --> 02:52.260
The new dev needs to spend more time to understand what's there and the code base.

02:52.260 --> 02:57.990
And each time a developer departs, they have to explain and document more of their custom personal

02:57.990 --> 03:00.540
flavor on how they applied that to the project.

03:00.540 --> 03:06.180
Now, to many devs, particularly beginners, this approach still might feel like the fastest way to

03:06.180 --> 03:07.590
get your features across.

03:07.590 --> 03:14.160
And often we see developers in prototype phases throw these rules out the window and do the no architecture

03:14.160 --> 03:14.790
approach.

03:14.790 --> 03:21.090
However, such fast code does indeed bring more bugs and complexity to the project, and the cost of

03:21.090 --> 03:23.910
software bugs grows exponentially over time.

03:24.150 --> 03:30.090
If you can catch bugs earlier, it's quicker to fix and has less of an impact on your overall project.

03:30.090 --> 03:35.820
Research shows that if you catch that same bug after you've shipped the product, it can be 30 times

03:35.820 --> 03:40.950
or more difficult to fix that bug and get that new version out.

03:40.950 --> 03:46.770
So best practices are to create maintainable code from the beginning to increase automation and any

03:46.770 --> 03:52.440
testing around it, which we'll talk about later to catch those bugs early and often and to fix all

03:52.440 --> 03:56.040
of your bugs before you move on to making new features.

03:56.040 --> 04:02.550
Software research shows that more than 80% of bugs happens with around 20% of the functionality.

04:02.580 --> 04:08.610
These can be the core pieces of glue or the architecture that holds everything together, working quickly

04:08.610 --> 04:14.820
to add new features for the architecture or the no architecture approach will cause more and more problems

04:14.820 --> 04:15.420
over time.

04:15.420 --> 04:23.160
Also, quite surprising to many, over 80% of the life of developers on a software project, that 80%

04:23.160 --> 04:27.360
is maintaining the code base, not necessarily adding new features.

04:27.360 --> 04:33.630
So while we might think that all day is adding features, it's quite a small part of the overall workload.

04:33.630 --> 04:41.160
So a key takeaway here is to do that 20% of new functionality and features in an efficient long term

04:41.160 --> 04:47.220
methodology so that when we're spending the time maintaining the code base, we reap those benefits

04:47.220 --> 04:47.790
together.

04:47.790 --> 04:56.220
We'll see that using an established architecture like MVC will bring us many benefits in our unity development.

04:56.580 --> 04:59.850
One of the themes we see in this section is that often the.

05:00.040 --> 05:04.870
Idea we have about how software development goes doesn't match the reality.

05:04.960 --> 05:10.840
We feel like all day is about adding new features, but actually that's a small part of the lifespan

05:10.840 --> 05:11.650
of a project.

05:11.650 --> 05:17.350
When we begin to think about long term solutions that make that maintenance easier, we place a higher

05:17.350 --> 05:23.690
value on learning good design principles, design patterns, and ultimately architectures.

05:23.710 --> 05:25.240
That's it for this section.

05:25.240 --> 05:25.990
Thank you.
