WEBVTT

00:00.590 --> 00:02.660
Hola y bienvenidos a Unit Testing for unity.

00:02.690 --> 00:03.860
Los talleres.

00:03.860 --> 00:09.590
En esta sección de talleres, vamos a cubrir un montón de diferentes pequeños ejemplos que cada uno nos muestran algunos

00:09.590 --> 00:11.030
características de las pruebas unitarias.

00:11.030 --> 00:12.800
Echemos un vistazo a los contenidos aquí.

00:12.800 --> 00:16.730
En primer lugar voy a dar esta visión general que estoy pasando ahora en esta introducción de la sección.

00:16.730 --> 00:19.070
Y luego iremos paso a paso por cada taller.

00:19.070 --> 00:24.320
Normalmente, cada taller se refiere a una escena de nuestro proyecto de ejemplo.

00:24.320 --> 00:28.370
Si descargas ese proyecto de ejemplo, podrás seguir cada una de las escenas.

00:28.370 --> 00:35.270
Vamos a cubrir mi sistema de matemáticas, que es un ejemplo muy básico, sólo para volver a familiarizarnos con lo que las pruebas unitarias

00:35.270 --> 00:36.500
es dentro de la unidad.

00:36.500 --> 00:42.230
A continuación, vamos a pasar a un ejemplo de mi cargador de datos, y que uno voy a estar mostrando una versión básica y, a continuación

00:42.230 --> 00:48.740
una versión más avanzada utilizando algunas características adicionales que son opcionales, pero increíblemente potente dentro de

00:48.740 --> 00:50.390
unity para pruebas unitarias.

00:50.420 --> 00:54.920
A continuación, vamos a ir a través de un ejemplo que quería hacer algo con gráficos renderizados.

00:54.920 --> 01:00.530
Así que tengo un cubo que podemos manejar con las teclas de flecha o con un gamepad, y lo llamaremos nuestro

01:00.530 --> 01:01.340
personaje.

01:01.400 --> 01:06.950
Vamos a pasar a través de algunos ejemplos, viendo casos de uso cada vez más complejos para las pruebas,

01:06.950 --> 01:13.520
finalmente haciendo un movimiento basado en la física, tomando la entrada y moviendo nuestro personaje con cuerpo rígido,

01:13.520 --> 01:17.990
y viendo cómo y por qué querríamos hacer pruebas unitarias en torno a eso.

01:18.020 --> 01:25.340
En términos generales, cuantas más funciones unity utilices y más animaciones en tiempo de ejecución hagas, hace que

01:25.340 --> 01:27.440
más desafíos para el proceso de pruebas.

01:27.440 --> 01:28.880
Hablaremos un poco de ello.

01:28.880 --> 01:31.670
Siempre tengo la oportunidad de añadir más contenido aquí.

01:31.670 --> 01:34.160
Así que vamos a hacer algunos temas avanzados también.

01:34.160 --> 01:38.990
Y este taller nos va a permitir profundizar en algunos subtemas concretos.

01:38.990 --> 01:43.580
Todo el código fuente está disponible en la descarga del código fuente del propio proyecto.

01:43.580 --> 01:44.720
Así que puedes cogerlo.

01:44.720 --> 01:48.950
Y el formato aquí va a ser una pantalla compartida improvisada.

01:48.980 --> 01:53.750
Voy a hacer tomas más largas de lo normal, y sólo pensar en voz alta cuando hay algunas cosas diferentes

01:53.750 --> 01:58.520
que quiero hablar y compartir con ustedes acerca de los poderes y los retos de las pruebas unitarias.

01:58.820 --> 02:03.320
Voy a estar revisando algo de código existente y aquí y allá crear nuevo código en el camino.

02:03.320 --> 02:09.590
Una buena manera de ver esto y utilizar esta información es descargar el proyecto de ejemplo y seguir a lo largo de

02:09.590 --> 02:10.400
aquí y allá.

02:10.400 --> 02:16.190
Te animaré a que añadas un nuevo método de producción a probar, o nuevos métodos de prueba para cubrir lo que has

02:16.190 --> 02:17.540
en el código de producción.

02:17.540 --> 02:21.200
Puedes construir sobre las muestras existentes que tengo aquí.

02:21.200 --> 02:23.720
O puedes crear tus propias escenas de ejemplo.

02:23.720 --> 02:27.230
Y como recapitulación, leamos aquí los beneficios de las pruebas unitarias.

02:27.230 --> 02:33.560
Algunos de ellos incluyen la adición de confianza en el código, así como permitir refactorizaciones más audaces a su código

02:33.560 --> 02:39.560
base con más conciencia antes y después de la refactorización del estado de tu proyecto.

02:39.560 --> 02:44.990
Y en general, esto va a ahorrar tiempo porque hemos visto que, si bien puede parecer que siempre estamos

02:45.020 --> 02:50.210
añadiendo nuevas características en la mayor parte de nuestro esfuerzo de trabajo, aprendemos de la investigación que el desarrollo de software

02:50.210 --> 02:55.220
se trata principalmente de mantener un código existente, y ahí es realmente donde van las pruebas unitarias

02:55.220 --> 02:55.640
a brillar.

02:55.640 --> 02:58.700
Así que nos va a ahorrar tiempo durante la vida del proyecto.

02:58.730 --> 03:04.130
Los resultados que esperamos de este curso y del uso de pruebas unitarias es tener más confianza y

03:04.130 --> 03:05.990
robustez en nuestro código base.

03:06.020 --> 03:12.680
Vamos a tener más clases y métodos de propósito único, que es un gran principio de diseño para centrarse

03:12.680 --> 03:14.930
y sin duda nos ayuda en nuestra comprobabilidad.

03:14.930 --> 03:17.450
Y vamos a fomentar más soluciones simples.

03:17.450 --> 03:19.550
Y hablaremos de ello en algunos de estos ejemplos.

03:19.550 --> 03:21.650
Recapitulemos el ejemplo más sencillo.

03:21.650 --> 03:24.380
Este es también el primero de los talleres en los que nos vamos a sumergir.

03:24.410 --> 03:30.290
Si tenemos una clase de sistema de matemáticas de la mente, y tiene dos métodos en él para sumar y restar.

03:30.320 --> 03:35.090
Ahora podrías imaginar que una vez que veas esta base de código funcionando, podrías añadir tu propio método para multiplicar

03:35.090 --> 03:38.300
o dividir, y luego añadir algunas pruebas de unidad en la parte superior de eso.

03:38.310 --> 03:39.800
Una buena forma de practicar.

03:39.800 --> 03:43.220
Y esta es a propósito la más simple de las escenas por las que pasaremos.

03:43.220 --> 03:48.560
Así que si usted todavía está acostumbrando a los fundamentos y desea asegurarse de que realmente se hunde en,

03:48.560 --> 03:53.300
Te sugiero que dediques un poco más de tiempo a esta parte del vídeo y a esta parte del código base hasta que

03:53.300 --> 03:55.340
te sientas bien, y después sigas adelante.

03:55.340 --> 03:59.450
Y de nuevo, aquí está una muestra del tipo de pruebas unitarias que vamos a crear.

03:59.450 --> 04:04.100
Esta es una prueba sencilla, completa y adecuada para cubrir que mi sistema de matemáticas.

04:04.100 --> 04:08.690
Así que aquí lo que hacemos es seguir el paradigma de organizar, actuar y afirmar.

04:08.720 --> 04:14.540
Esta es una forma opcional de abordar tus pruebas unitarias, sólo para organizar tus propios pensamientos a medida que avanzas.

04:14.720 --> 04:18.740
A veces, en el camino, puedes estar haciendo desarrollo de código asíncrono.

04:18.740 --> 04:23.990
Así que en esa metodología yo haría arrange, act, await y assert.

04:23.990 --> 04:29.840
Y si no estás exactamente seguro de lo que es una espera, veremos la metodología await y async para hacer

04:29.870 --> 04:32.120
la codificación asíncrona como parte del taller.

04:32.120 --> 04:37.760
Ahora, mientras trabajaba en el código fuente aquí para contribuir al proyecto y para este curso, ¿qué

04:37.760 --> 04:40.330
hice fue mirar cada una de las dependencias.

04:40.340 --> 04:47.990
Unity tiene ciertas librerías en el gestor de paquetes unity disponibles para que hagamos la solución unity oficial

04:47.990 --> 04:49.550
para pruebas unitarias.

04:49.550 --> 04:55.820
Ahora, lo que hice aquí es en lugar de utilizar el x que está en libertad, yo uso una versión experimental.

04:55.820 --> 04:59.900
Así que usted puede notar que el corredor de prueba como voy a través en el video se ve.

05:00.050 --> 05:04.940
Un poco diferente que tal vez algunas capturas de pantalla que has visto en la web, o si tienes experiencia

05:04.940 --> 05:06.400
con el test runner.

05:06.410 --> 05:08.630
Lo que estoy mostrando hoy puede parecer un poco diferente.

05:08.660 --> 05:13.370
El proyecto de ejemplo que vas a descargar va a coincidir con el aspecto de este video, porque he

05:13.400 --> 05:15.020
incluido esa dependencia.

05:15.050 --> 05:16.340
Hay razones por las que lo hice.

05:16.340 --> 05:21.020
No es sólo que el ejecutor de pruebas se vea diferente y sea más estable, que creo que es el caso.

05:21.050 --> 05:26.870
También la biblioteca detrás de él nos permite hacer algunas cosas adicionales, en particular en torno a algunos asíncrono

05:26.870 --> 05:28.370
desarrollo y pruebas.

05:29.730 --> 05:33.060
Puedes echar un vistazo a este archivo de texto de la versión que se incluye en el proyecto.

05:33.060 --> 05:37.790
Si quieres ver cómo y dónde y por qué incluimos cada una de estas dependencias.

05:37.800 --> 05:43.020
El proyecto de ejemplo en el que vamos a entrar incluye un activo Readme, en el que podemos hacer clic y ver

05:43.020 --> 05:44.390
este bonito menú a la derecha.

05:44.400 --> 05:49.950
Es una manera fácil de orientarse para recordar algunos enlaces populares, y para hacer clic a la derecha en cada uno de los

05:49.950 --> 05:51.690
muestras en las que quieras entrar.

05:51.960 --> 05:57.270
Tengo un diseño particular que me verás usar aquí, que es mantener el corredor de prueba en el centro

05:57.270 --> 05:59.930
allí sólo para que sea agradable y grande para los propósitos del vídeo.

05:59.940 --> 06:04.710
A menudo, en el desarrollo, mi corredor de prueba tal vez se sientan en el lado derecho allí, pero me gusta tenerlo

06:04.710 --> 06:08.280
al frente y al centro, especialmente con el propósito de discutir las pruebas.

06:08.370 --> 06:13.290
Puede cambiar el tamaño de estas ventanas y diseños, por supuesto, de la forma que desee, pero algunas de las claves para

06:13.290 --> 06:18.150
echar un vistazo aquí sería la ventana del proyecto, el corredor de prueba, y luego el inspector, que vamos a

06:18.150 --> 06:19.020
echaremos un vistazo.

06:19.020 --> 06:23.310
Así que estamos a punto de sumergirnos aquí y echar un vistazo al primero de los talleres.

06:23.370 --> 06:27.870
Lo he dividido en varias secciones, centrándome de nuevo en algunos subtemas diferentes.

06:27.870 --> 06:35.130
También pensé en el camino a más o menos organizarlos de uno en el número más alto, a partir de

06:35.130 --> 06:39.840
con el más fácil y menos complejo, y luego construir sobre esos conceptos allí.

06:40.140 --> 06:42.810
Cada una de las escenas de demostración se ejecuta por sí misma.

06:42.810 --> 06:44.880
Sólo tienes que darle al play en la ventana de la consola.

06:44.910 --> 06:47.070
Verás algunas lecturas y cosas por el estilo.

06:47.070 --> 06:52.050
Puedes seguirlo, y en algunas de las escenas hay algo que hacer cuando le das al play.

06:52.080 --> 06:56.610
A veces no hay interfaz de usuario, es algo simple y sólo tienes que mirar algunas declaraciones de registro de depuración.

06:56.610 --> 07:00.110
Así que estoy muy emocionado de compartir estos talleres como una gran manera de sumergirse.

07:00.120 --> 07:01.140
Así que empecemos.

07:01.140 --> 07:02.970
Vamos a abrir el editor de unity.

07:02.970 --> 07:07.680
Ya he descargado el código fuente siguiendo los recursos del curso de la lección anterior.

07:07.680 --> 07:12.540
Vamos a abrir ese proyecto de ejemplo del curso, y luego vamos a abrir y reproducir una o más escenas

07:12.540 --> 07:13.680
en cada uno de los talleres.

07:13.680 --> 07:18.360
Primero vamos a ver el archivo Readme que nos orienta en el proyecto.

07:18.390 --> 07:23.700
También vamos a ver el gestor de paquetes, explorar la estructura del proyecto y luego echar un vistazo a la prueba

07:23.700 --> 07:24.630
de pruebas.

07:24.630 --> 07:29.610
Así que aquí estamos dando una visión general de lo que el proyecto de ejemplo es y cómo los talleres son

07:29.610 --> 07:30.270
formateados.

07:30.270 --> 07:33.090
Y luego pasaremos a cada uno de los talleres.

07:33.090 --> 07:35.190
Aquí estamos dentro de la unidad.

07:35.190 --> 07:39.960
Haré lo que pueda para mantener la cabeza de mi webcam alejada de la acción.

07:39.960 --> 07:45.360
Y lo que vamos a ver es que el Readme, que está disponible en un par de puntos, que

07:45.360 --> 07:48.810
podemos ir aquí y explorar esta opción de menú para abrir el Readme.

07:49.440 --> 07:54.060
También podemos navegar a través de la ventana del proyecto e ir aquí abajo y simplemente hacer clic en el readme.

07:54.180 --> 07:56.900
De cualquier manera, se abrirá el readme en el Inspector.

07:56.910 --> 07:58.650
Echemos un vistazo a lo que tenemos aquí.

08:00.900 --> 08:05.490
Tenemos algunos enlaces al curso y al proyecto de ejemplo sólo para orientación donde esta información

08:05.490 --> 08:06.060
está disponible.

08:06.060 --> 08:08.670
Si quieres hacer clic y echar un vistazo a esos enlaces.

08:11.450 --> 08:13.220
Y luego la sección "Primeros pasos".

08:13.220 --> 08:18.650
Hay una manera rápida de llegar a algunos de los ejemplos más populares, por lo que sin duda puede navegar a través de la

08:18.650 --> 08:20.060
ventana de proyecto y encontrarlos.

08:20.060 --> 08:22.140
Pero esta es una buena manera de orientarse.

08:22.160 --> 08:25.190
Otra cosa a la que quería echar un vistazo es al gestor de paquetes.

08:25.220 --> 08:29.360
Si estás descargando este proyecto, verás los mismos paquetes aquí.

08:29.360 --> 08:35.510
Pero si usted decide para el propósito de su aprendizaje aquí o más adelante en el futuro para llevar estas lecciones

08:35.510 --> 08:40.640
en un proyecto diferente, vas a querer hacer que tu gestor de paquetes sea similar si quieres

08:40.640 --> 08:42.230
tener la misma experiencia aquí.

08:42.230 --> 08:46.160
Fíjate que tengo el paquete sustituto final.

08:46.400 --> 08:52.130
También tengo el paquete de cobertura de código, el marco de pruebas.

08:52.130 --> 08:56.990
Y para el propósito de este curso, tenga en cuenta que tengo una versión de pre-lanzamiento que nos da algunos adicionales

08:56.990 --> 08:57.940
adicionales.

08:57.950 --> 09:00.050
Esto es opcional para las pruebas unitarias.

09:00.050 --> 09:04.730
Ciertamente no lo necesitas para la mayor parte de las funcionalidades de las pruebas unitarias, pero creo que tiene algo de

09:04.730 --> 09:06.020
cosas interesantes de vanguardia.

09:06.020 --> 09:10.040
Así que nos vamos a centrar en eso, y te recomiendo que lo pruebes.

09:10.070 --> 09:11.420
Algo más a destacar aquí.

09:11.420 --> 09:14.750
Este archivo de versión que he seleccionado profundizará en ello.

09:14.750 --> 09:19.430
Estas son sólo algunas notas que tomé en el camino para hablar un poco sobre las dependencias que yo

09:19.430 --> 09:20.390
elegí y por qué.

09:22.530 --> 09:24.420
Así que no vamos a entrar en ello aquí.

09:24.450 --> 09:26.080
Esto también puede cambiar con el tiempo.

09:26.100 --> 09:30.210
Pero sólo echa un vistazo a este archivo si tienes curiosidad de cómo y por qué he utilizado cada una de las dependencias, y

09:30.210 --> 09:33.450
por qué utilizo la versión preliminar que mencioné explícitamente.

09:33.480 --> 09:37.110
Y por último, al frente y al centro aquí, echemos un vistazo a la ventana del ejecutor de pruebas.

09:37.140 --> 09:42.480
Ahora esa ventana está disponible desde Ventana General y Test Runner.

09:42.480 --> 09:47.160
Y está incluida en todas las instalaciones por defecto de unity como ya he mencionado.

09:47.190 --> 09:51.600
He añadido la versión preliminar de un paquete determinado, por lo que el diseño de la mía puede parecer un poco diferente

09:51.600 --> 09:54.150
que el estándar aquí en este diseño.

09:54.180 --> 10:01.260
Lo que tenemos aquí es la posibilidad de activar y desactivar las pruebas en modo edición, y activar y desactivar las pruebas en modo reproducción.

10:01.260 --> 10:03.570
Se muestran aquí en la misma vista de pestaña.

10:03.720 --> 10:04.840
Esto es realmente genial.

10:04.860 --> 10:07.800
Entonces lo que puedo hacer es navegar por las diferentes categorías.

10:07.800 --> 10:13.140
Ahora he creado todas las pruebas que estamos viendo y las he marcado cada una como una categoría específica.

10:13.140 --> 10:18.360
Así que si quiero ver sólo uno en particular como mi sistema de matemáticas, a continuación, sólo se filtra la vista

10:18.390 --> 10:23.970
aquí y te mostrará sólo la edición o sólo el juego y de una categoría determinada.

10:24.000 --> 10:25.230
Eso realmente te ayuda.

10:25.260 --> 10:31.170
Entonces lo que puedo hacer aquí con sólo la edición seleccionada, por ejemplo, es ser capaz de ver todas las pruebas

10:31.170 --> 10:31.770
que están ahí.

10:31.770 --> 10:36.600
Y aquí abajo en la parte inferior puedo ejecutar seleccionado o ejecutar todo lo que voy a ejecutar seleccionado, por ejemplo.

10:36.600 --> 10:40.950
Y lo que hace es ejecutar todo el código de prueba.

10:41.040 --> 10:48.270
Esto es algo así como el núcleo de la metodología que estamos abordando aquí es que periódicamente en su desarrollo

10:48.270 --> 10:50.270
quieres probar tu propio código base.

10:50.280 --> 10:55.190
Llegas a esta ventana y pulsas manualmente el botón de ejecutar seleccionado o el de ejecutar todo.

10:55.200 --> 10:59.340
Vemos todo verde aquí arriba indicando éxito.

10:59.340 --> 11:02.970
Nos da un pequeño resumen de que tenemos 100 pruebas que han tenido éxito.

11:02.970 --> 11:07.550
Tenemos cero que fallaron, y tenemos cero que fueron omitidas o ignoradas.

11:07.560 --> 11:13.530
Así que una gran práctica al hacer pruebas unitarias es asegurarse de que todas las pruebas pasan.

11:13.560 --> 11:18.570
No permitas que una prueba fallida permanezca en tu proyecto durante mucho tiempo.

11:18.570 --> 11:19.680
Quieres solucionar eso.

11:19.680 --> 11:20.520
Quítalo de en medio.

11:20.520 --> 11:23.280
Incluso si sabes que va a haber una migración en el futuro.

11:23.280 --> 11:29.280
Así que la mejor práctica aquí es mantener tus pruebas actualizadas con los cambios de código y tenerlas siempre

11:29.280 --> 11:30.030
pasando.

11:30.030 --> 11:32.700
Así que aquí mostramos la mejor práctica en efecto.

11:33.690 --> 11:36.690
En el próximo taller veremos más de cerca el código fuente.

11:36.690 --> 11:41.850
Pero eso es todo para esta sección de mirar a los talleres y el proyecto de ejemplo.

11:46.910 --> 11:47.900
Hola y bienvenidos.

11:47.900 --> 11:53.990
En este taller, vamos a echar un vistazo al sistema My Math, entrando en lo que es un bonito

11:54.020 --> 11:58.250
ejemplo simple, sólo para familiarizarnos con los fundamentos de las pruebas unitarias.

11:58.250 --> 12:01.640
En esta demo puedes usar el proyecto Core Sample para seguirnos.

12:01.640 --> 12:06.440
Vamos a abrir el editor de la unidad, la apertura de ese proyecto de ejemplo de núcleo, y luego vamos a

12:06.440 --> 12:08.060
abriremos y reproduciremos algunas escenas.

12:08.060 --> 12:13.310
Vamos a ver el sistema My Math, así como la prueba detrás de él, y vamos a hacer una recapitulación

12:13.340 --> 12:18.920
de las pruebas unitarias, sólo un poco de hablar de cualquier concepto básico que veo allí y creo que mencionar.

12:18.920 --> 12:25.370
Y también vamos a hablar de valores parametrizados, que es una forma intermedia que usted puede acercarse a

12:25.370 --> 12:25.880
pruebas.

12:25.880 --> 12:29.540
Y es una buena habilidad adicional para acercarse a las pruebas unitarias.

12:29.570 --> 12:30.560
Vamos a sumergirnos.

12:30.770 --> 12:35.330
Así que aquí estoy dentro del editor de la unidad que he abierto el ejemplo de mi sistema de matemáticas.

12:35.330 --> 12:37.970
Vamos a jugar con la escena.

12:38.000 --> 12:41.630
A veces en estos talleres la escena es más emocionante.

12:41.630 --> 12:43.220
Esta no es tan emocionante.

12:43.220 --> 12:48.680
Vamos a darle al play aquí abajo en la ventana inferior, vemos un texto sencillo que está ayudando

12:48.680 --> 12:53.960
a entender que estamos en la demo de pruebas unitarias, y vamos a reproducir la escena y ver la consola.

12:53.960 --> 12:55.430
Así que vamos a ver la consola.

12:55.520 --> 12:58.520
La consola dice que esta escena no tiene UI.

12:58.550 --> 13:01.430
Veamos la consola de unity aquí estamos en la consola.

13:01.430 --> 13:02.090
Realmente.

13:02.090 --> 13:06.830
Nos va a mostrar un valor que ha sido escupido después de una operación exitosa.

13:06.830 --> 13:12.290
Así que esto sería, en código de producción real, una escena mucho más interesante.

13:12.290 --> 13:17.540
Quizás aquí esté ocurriendo el menú del juego o el juego.

13:17.780 --> 13:22.730
Esta es una escena bastante magra aquí donde no hay mucho que ver, pero se puede imaginar que eso podría

13:22.730 --> 13:23.150
ser.

13:23.720 --> 13:28.880
No es particularmente importante que haya una escena de ejecución para las pruebas.

13:28.880 --> 13:34.520
Sólo quiero hablar a menudo sobre el equilibrio entre aquí está su código de producción haciendo su producción

13:34.520 --> 13:35.150
cosa.

13:35.150 --> 13:38.480
Y luego aquí está el código de prueba haciendo su cosa de prueba.

13:38.480 --> 13:44.330
Así que el código de producción, siempre lo experimentamos dándole al play en una escena unity como esta.

13:44.330 --> 13:47.750
Y para hacer nuestras pruebas unitarias hacemos algo diferente.

13:47.780 --> 13:50.990
Lo que hacemos aquí es mirar la ventana del test runner.

13:51.530 --> 13:55.340
Exploramos la categoría apropiada a lo que queremos mirar aquí.

13:55.340 --> 13:57.470
Estamos viendo el sistema de mis matemáticas.

13:58.560 --> 14:01.020
Y luego le damos a ver.

14:01.020 --> 14:02.280
Hagamos la prueba del modo edición.

14:02.430 --> 14:06.780
Haremos ejecutar todo aquí y todas las pruebas se ejecutarán así.

14:06.810 --> 14:09.050
Ahora no se ha ejecutado la escena.

14:09.060 --> 14:15.420
Se está ejecutando en su propio pequeño universo, ejecutando esas pruebas dentro de una escena.

14:15.420 --> 14:16.290
modo edición.

14:16.290 --> 14:19.790
Así que las pruebas de modo de edición hablando un poco sobre la diferencia allí.

14:19.800 --> 14:25.050
Las pruebas en modo edición se ejecutan en modo edición, que en unity tiene dos modos primarios.

14:25.050 --> 14:30.630
Básicamente, desde el momento en que se pulsa el botón de reproducción hasta el momento en que se pulsa el botón de reproducción, es decir

14:30.630 --> 14:31.290
modo play.

14:31.320 --> 14:35.440
Generalmente es ahí donde el usuario experimenta la jugabilidad de la unidad.

14:35.610 --> 14:38.430
Cada vez que no estamos en ese modo, estamos en modo edición.

14:38.430 --> 14:40.170
Sentados aquí, estamos en modo edición.

14:40.200 --> 14:46.260
Estas pruebas se ejecutan en modo edición porque no necesitan necesariamente toda la complejidad de un tiempo de ejecución

14:46.260 --> 14:46.800
escena.

14:46.800 --> 14:52.110
Esto nos ayuda a tener una pequeña área aislada más simple donde se ejecutan estos códigos.

14:52.110 --> 14:57.780
Ahora bien, a veces necesitas las comodidades de los monoconductos y la funcionalidad en tiempo de ejecución.

14:57.780 --> 15:01.680
Ahí es donde entra en juego el modo de reproducción.

15:01.680 --> 15:04.260
Y aquí tenemos también algunas pruebas del modo reproducción.

15:04.260 --> 15:09.480
Así que cada vez que haga clic en una de estas casillas de verificación, se puede ver que nos está mostrando algunas listas ligeramente diferentes

15:09.510 --> 15:10.740
de lo que tenemos disponible.

15:10.740 --> 15:13.140
Así que aquí en modo reproducción voy a darle a ejecutar todo.

15:13.950 --> 15:18.090
Y aquí se está creando una nueva escena.

15:18.090 --> 15:24.420
Ejecutando una escena en tiempo de ejecución que es sólo para demostración con cualquier código de prueba que tengo, y luego devuelve

15:24.420 --> 15:26.880
a la escena original en la que estábamos.

15:26.880 --> 15:31.110
Si no tuviéramos la escena guardada, nos avisaría y nos diría, hey, estás a punto de ejecutar un modo de reproducción

15:31.140 --> 15:31.620
prueba.

15:31.650 --> 15:33.360
Vamos a abandonar temporalmente tu escena.

15:33.390 --> 15:35.040
¿Quieres guardar tu escena primero?

15:35.040 --> 15:37.500
Generalmente, es una buena idea, así que ten cuidado con eso.

15:37.530 --> 15:39.300
Ahora veamos el código fuente.

15:39.330 --> 15:43.020
Veamos primero el código de producción en tiempo de ejecución.

15:43.020 --> 15:45.810
Abriremos el ejemplo del sistema My Math.

15:45.810 --> 15:52.740
Cada uno de estos talleres tiene, en general un objeto de juego con un script de ejemplo que patea

15:52.740 --> 15:53.580
todo.

15:53.580 --> 15:59.490
Así que cuando nos fijamos en eso, aquí estamos en el editor de código y podemos ver el completo mi sistema de matemáticas

15:59.490 --> 16:00.180
ejemplo.

16:00.180 --> 16:05.670
Ahora bien, este es un mono-comportamiento porque quiero tener las comodidades del código sentado en un objeto del juego.

16:05.670 --> 16:10.380
Y luego dentro del await aquí voy a simular algo de código de producción.

16:10.380 --> 16:16.140
Ahora es muy simple, no hay mucho que hacer, y se parece a la prueba que estamos a punto de hacer

16:16.140 --> 16:21.780
a ver, porque creo la clase desde cero y luego llamo a un método en él, y luego muestro

16:21.780 --> 16:22.530
los resultados.

16:22.530 --> 16:28.320
Pero es importante saber que en un ejemplo de producción, en un proyecto de juego real, este equivalente sería

16:28.320 --> 16:33.600
ser muchas clases y todas las escenas y todos los prefabs y toda la complejidad que generalmente tendría

16:33.600 --> 16:34.530
en tu proyecto.

16:34.530 --> 16:37.230
Pero aquí estoy manteniendo a propósito muy magra.

16:37.230 --> 16:38.910
Fíjate en lo que hacemos aquí.

16:38.910 --> 16:40.920
Creamos mi sistema matemático.

16:40.920 --> 16:45.750
Cogemos un par de ints y los rellenamos con los valores cinco y diez.

16:45.750 --> 16:47.940
Y luego llamamos al sistema my Math.

16:47.940 --> 16:50.550
Y pasamos el cinco y el diez juntos.

16:50.550 --> 16:52.500
Y aquí mostramos el resultado.

16:52.500 --> 16:54.030
Así que vamos a seguir adelante y hacer eso.

16:54.030 --> 16:55.470
Aquí le doy al play.

16:59.430 --> 17:03.560
Y aquí abajo en la ventana de la consola vemos que el resultado es 15.

17:03.570 --> 17:09.240
Ahora, me gusta la simplicidad de este ejemplo de codificación, porque nos hace empezar a pensar en un mundo

17:09.240 --> 17:14.540
donde las pruebas unitarias nunca existieron, ¿cómo puedo estar seguro de que este código es funcional?

17:14.550 --> 17:21.570
Bueno, tal vez este código de mi sistema matemático se utiliza en muchos, muchos lugares de su juego, y usted simplemente,

17:21.570 --> 17:26.970
cada vez que quieras ver y validar que este sistema está funcionando bien, sólo tienes que jugar el juego y

17:26.970 --> 17:31.110
tu juego puede durar varios minutos, o puede durar varias horas.

17:31.110 --> 17:37.140
Y este sistema en particular que se está probando podría ser utilizado en muchos lugares diferentes, dependiendo de

17:37.140 --> 17:40.320
de los diferentes comportamientos de los usuarios.

17:40.320 --> 17:42.660
Quizás la hora del día sería importante.

17:42.660 --> 17:47.970
Así que es difícil saber si realmente lo estoy probando aisladamente.

17:47.970 --> 17:56.490
Así que un primer movimiento que podría hacer si quisiera hacer alguna validación es que podría copiar esto aquí, pegarlo

17:56.490 --> 17:57.360
aquí.

17:59.710 --> 18:02.220
Y llamar a esto aquí y probar.

18:02.230 --> 18:03.790
Bueno, ¿y si fuera seis?

18:03.790 --> 18:05.680
¿Y si fuera 11?

18:07.710 --> 18:09.360
A a, B a.

18:14.010 --> 18:20.000
Así que ahora estoy probando no una prueba unitaria, pero sólo estoy validando dos ejemplos diferentes aquí.

18:20.010 --> 18:22.770
Así que estoy haciendo esto primero y estoy haciendo eso en segundo lugar.

18:22.800 --> 18:29.760
Ahora bien, esto se llama pruebas de usuario o pruebas de modo de juego o pruebas de integración en la que en realidad estoy ejecutando

18:29.760 --> 18:30.900
código de producción.

18:30.900 --> 18:37.710
Y sólo lo estoy probando como usuario, esperando que accidentalmente le pida que haga un montón de diferentes

18:37.740 --> 18:40.620
operaciones, y ver que ninguna de ellas falla.

18:40.650 --> 18:44.790
Pero puedes imaginar que lo que estoy haciendo aquí es añadir cosas que realmente no quiero para el final

18:44.790 --> 18:46.140
experiencia del usuario.

18:46.140 --> 18:52.650
Sólo estoy tratando de darme un poco más de confianza en mi propio código llamando a alguna funcionalidad

18:52.650 --> 18:53.910
veces extra.

18:53.940 --> 19:00.510
También puede establecer un booleano en algún lugar de su proyecto que dice como es el modo de depuración es verdadera, y luego

19:00.510 --> 19:02.280
en todo el código de producción.

19:02.280 --> 19:05.730
Si esa es la situación, harás un poco de pruebas extra.

19:05.730 --> 19:07.140
Ahora no está mal.

19:07.140 --> 19:12.150
En ciertas situaciones, definitivamente te puede ayudar, pero veamos como mejora la situación

19:12.150 --> 19:12.720
puede ser.

19:12.720 --> 19:15.960
Si en lugar de hacer esto, ejecuto pruebas unitarias.

19:15.960 --> 19:18.780
Así que aquí es donde este proyecto el código se sienta.

19:18.780 --> 19:23.010
En este proyecto tenemos el sistema My Math, ejemplo del sistema My Math, que hemos visto.

19:23.700 --> 19:29.580
La estructura de eso y la forma en que trabajan juntos se habla antes en el curso.

19:29.580 --> 19:34.350
Pero tenemos una prueba de editor y una prueba de ejecución de las que hablaremos.

19:34.350 --> 19:40.980
Una vez más, cualquier prueba de editor va a ejecutar un modo de edición, y por lo general es ideal para las cosas que no

19:40.980 --> 19:44.310
usan clases específicas de unity como Monobehaviour.

19:44.310 --> 19:49.440
Monobehaviour está diseñado sólo para funcionar en toda su extensión en el modo de juego.

19:49.440 --> 19:51.390
Así que aquí no es demasiado apropiado.

19:51.390 --> 19:51.870
Entonces

19:51.870 --> 19:54.810
Pero para pruebas simples como la que tenemos aquí, es genial.

19:54.840 --> 19:59.580
El área de tiempo de ejecución aquí donde tenemos la prueba de modo de juego sería un gran lugar.

19:59.580 --> 20:05.130
Y en cada uno de estos talleres hago uno de cada para que veáis las diferencias.

20:05.130 --> 20:09.960
Pero es importante pensar que en ciertas situaciones, dependiendo de lo que estés probando, probablemente

20:09.960 --> 20:14.010
una prueba unitaria en modo edición es más apropiada en esta situación.

20:14.010 --> 20:18.630
Ese es definitivamente el caso más adelante cuando estamos hablando de moverse con la entrada y hacer algo con

20:18.630 --> 20:24.750
física, tal vez la prueba de modo de juego se requiere allí, porque la entrada y la física son realmente diseñado

20:24.750 --> 20:26.220
como experiencias del modo de juego.

20:26.220 --> 20:28.650
Así que es importante conocer esa distinción.

20:28.650 --> 20:30.030
Y lo mencionaré aquí y allá.

20:30.270 --> 20:32.760
Así que veamos la prueba del sistema matemático mental.

20:36.190 --> 20:39.130
Y veamos cómo está organizado.

20:40.710 --> 20:45.990
Así que aquí, observe que la prueba del sistema de Mis Matemáticas tiene algunas diferentes.

20:51.350 --> 20:53.180
Tiene algunos métodos diferentes.

20:53.330 --> 20:57.500
Cada uno de los nombres que vemos aquí son los nombres de los métodos de prueba.

20:57.500 --> 20:59.000
Así que vamos a empezar con el primero.

20:59.600 --> 21:04.970
La convención que me gusta usar se sigue aquí, y vamos a entrar en el código que generalmente pongo

21:04.970 --> 21:10.460
primero, qué método estamos probando, qué estamos esperando y luego cuál es la situación.

21:10.460 --> 21:13.400
Aquí dice que estamos probando el método add.

21:13.400 --> 21:18.080
Esperamos que el resultado sea 15 cuando pasemos en cinco y diez.

21:18.320 --> 21:23.750
Así que un buen atajo aquí es que a medida que se está ejecutando cualquier prueba sólo puede hacer doble clic en él para ejecutarlo de nuevo.

21:24.800 --> 21:26.540
Y luego puedo hacer clic con el botón derecho.

21:28.490 --> 21:29.360
Lo siento, estaba en modo reproducción.

21:29.810 --> 21:31.850
Doble click y se ejecuta de nuevo.

21:31.880 --> 21:32.330
Genial.

21:32.330 --> 21:33.230
Sigue en verde.

21:33.230 --> 21:36.560
Y puedo hacer clic con el botón derecho y elegir código fuente abierto.

21:37.720 --> 21:41.800
Es una forma fácil de ir directamente a la clase correcta y al método correcto.

21:41.830 --> 21:44.320
Aquí está de nuevo el nombre del método que vimos.

21:44.350 --> 21:47.860
Una vez más añadir resultado es 15 cuando cinco y diez.

21:47.890 --> 21:54.070
La razón por la que esto es importante es que si tienes muchas clases de prueba con muchos métodos de prueba,

21:54.070 --> 22:01.600
y espero que lo hagas en tu proyecto para poder razonar cual en un test runner es cual en el código

22:01.600 --> 22:04.610
base aquí, es bueno tener esa nomenclatura coherente.

22:04.630 --> 22:09.910
Así que aquí lo que hacemos, hacemos el arreglo, actuar y afirmar la metodología.

22:09.910 --> 22:10.720
En el arrange.

22:10.720 --> 22:15.310
Lo que vamos a hacer primero es crear una nueva instancia de lo que queremos probar.

22:15.310 --> 22:19.420
De esa manera sabremos que no ha estado sentado por ahí, que no tiene datos antiguos en su interior.

22:19.430 --> 22:20.770
Siempre es una buena práctica.

22:20.770 --> 22:22.480
Entonces vamos a actuar en consecuencia.

22:22.480 --> 22:26.140
Esto es como, ¿cuál es el único método si puedes salirte con la tuya?

22:26.140 --> 22:28.690
Quizás dos métodos que realmente hagan las pruebas.

22:28.690 --> 22:30.160
Pero un método es ideal.

22:30.190 --> 22:32.680
Aquí estamos sumando cinco y diez.

22:32.680 --> 22:36.670
Y luego en el assert vamos a usar este lenguaje assert.

22:36.670 --> 22:43.630
La clase assert tiene una cierta estructura en la que se dice que algo es algo.

22:43.630 --> 22:48.670
Y puedes mirar la documentación para ver la variedad de formas en que puedes formatear eso.

22:48.670 --> 22:54.790
Pero a menudo uso es igual a o es verdadero o es falso.

22:54.790 --> 22:57.670
Así que esos son los que verás con bastante frecuencia aquí.

22:57.970 --> 23:02.920
Así que cuando ejecuto eso porque el código se ejecuta correctamente suma cinco y diez para ser 15.

23:02.950 --> 23:03.700
Y ya está.

23:03.730 --> 23:05.010
Somos capaces de hacerlo.

23:05.020 --> 23:08.620
Ahora recuerda el ejemplo que estaba dando en el código de producción.

23:08.620 --> 23:17.650
¿Y si quisieras probar cinco y diez y luego probar seis y once y luego probar siete y doce o lo que sea?

23:17.650 --> 23:18.700
combinaciones?

23:18.700 --> 23:25.510
Cuanto mejor te desenvuelvas en las pruebas, te darás cuenta de cuántas pruebas necesitas realmente para proporcionar una cobertura adecuada.

23:25.510 --> 23:31.180
Hay mucho de arte y de ciencia en torno a cuál es el número mínimo de pruebas que puedes proporcionar que

23:31.180 --> 23:34.720
maximice tu impacto, y la cobertura de código que tienes?

23:34.750 --> 23:40.030
Así que una de las cosas de las que quería hablar como parte de este taller en particular es lo que se llama

23:40.030 --> 23:41.830
pruebas parametrizadas.

23:41.830 --> 23:48.460
Así que en lugar de simplemente copiar este, pegarlo a continuación, y ajustar los valores para sumar seis

23:48.460 --> 23:55.780
y 11 o 0 y diez negativo, podemos pedir a la unidad para ejecutar la misma prueba exacta, pero pasando en algunos diferentes

23:55.780 --> 23:56.530
valores.

23:56.530 --> 23:58.750
Hay un montón de opciones diferentes que tienes aquí.

23:58.750 --> 24:00.340
Sólo estoy mostrando una de ellas.

24:00.340 --> 24:02.800
Pero echemos un vistazo aquí abajo.

24:03.730 --> 24:10.090
Decimos, y juntos que asumimos que el resultado es correcto cuando estos valores.

24:10.090 --> 24:15.640
Así que los nombres de método un poco más vago porque es parametrizado, no sé necesariamente.

24:15.640 --> 24:18.430
¿Esto va a probar cinco y diez es 15.

24:18.460 --> 24:24.250
Fíjate que aquí en lugar de lo que hice antes que era declarar cinco y diez.

24:24.280 --> 24:29.890
En el cuerpo del método utilizo este lenguaje en particular, utilizo algo llamado fuente de valor.

24:29.890 --> 24:31.210
Y luego lo paso.

24:31.210 --> 24:37.090
Lo que hace unity es rellenar esto primero pasa los valores aquí.

24:37.090 --> 24:38.740
Así que digamos que es cinco.

24:38.770 --> 24:41.290
Luego toma otra fuente de valores aquí.

24:41.320 --> 24:48.010
Digamos que uno es diez y asume que son cinco más diez sumados.

24:48.010 --> 24:52.960
Así que cada vez que se ejecute, va a hacer el equivalente de la última prueba que vimos.

24:52.960 --> 24:59.050
Pero en lugar de estar codificado a un solo conjunto de valores, se va a mezclar y mostrar una variedad

24:59.050 --> 24:59.560
de ellos.

24:59.560 --> 25:02.460
Ahora de nuevo, hay un montón de maneras diferentes que usted puede dar formato a esto.

25:02.460 --> 25:06.670
Así que usted quiere mirar en la documentación para las pruebas parametrizadas en la unidad.

25:06.670 --> 25:08.920
Pero veamos mi caso específico aquí.

25:08.950 --> 25:11.350
Esas fuentes de valores A y b.

25:11.350 --> 25:14.770
Se refieren a un par de matrices que tengo aquí.

25:14.770 --> 25:20.980
Y lo que va a hacer es sólo paso a través y va a probar uno y uno, negativo dos y

25:20.980 --> 25:23.530
negativo dos, negativo tres y negativo tres y pasarlos.

25:23.560 --> 25:30.070
Puedes organizarlos como quieras y probar diferentes escenarios donde quizás hagas siete, 11

25:30.070 --> 25:30.670
y 12.

25:30.700 --> 25:32.230
Puedes probar lo que quieras.

25:32.260 --> 25:35.020
Ahora no tienes que probar cantidades infinitas allí.

25:35.020 --> 25:37.450
Aquí es donde aparece el arte y la ciencia.

25:37.450 --> 25:43.960
Es posible que desee probar un par de valores negativos cero en algunos escenarios y un par de valores positivos.

25:43.990 --> 25:48.820
Tal vez lo que estás haciendo no se basa en las matemáticas y quieres pensar en ello de otra manera, pero lo que estás

25:48.820 --> 25:51.370
buscando lo que se llaman casos de esquina.

25:51.370 --> 25:57.250
Así, por ejemplo, si estuvieras haciendo un método de división y quisieras probarlo matemáticamente, hay

25:57.250 --> 25:59.740
un desafío sobre la división por cero.

25:59.740 --> 26:03.970
Así que usted querría ver que se pasa en cero y manejar eso con elegancia.

26:03.970 --> 26:09.040
Realmente necesitas conocer el dominio específico en el que se encuentra tu código de producción, para saber cómo

26:09.040 --> 26:09.730
probarlo.

26:09.730 --> 26:14.020
Pero aquí un par de cada positivo y negativo y cosas así.

26:15.200 --> 26:17.950
Así que vamos a ver cómo se ve en el editor de la unidad.

26:17.960 --> 26:19.670
Fíjate en lo que hace aquí.

26:19.670 --> 26:24.980
Ejecuta 49 pruebas basadas en todas las combinaciones que tenemos aquí.

26:24.980 --> 26:28.850
Así que te muestra cuándo están los valores y luego los pasa.

26:28.850 --> 26:30.430
Eso está muy bien.

26:30.440 --> 26:37.430
Ahora, mientras miras este resultado, te darás cuenta de que va a ser importante para mí probar el 100

26:37.430 --> 26:38.800
y -100.

26:38.810 --> 26:39.320
Genial.

26:39.320 --> 26:45.890
Entonces vuelve atrás y añade esos valores de muestra si quieres hacer otras cosas en lugar de sólo un duro

26:45.890 --> 26:46.610
lista codificada.

26:46.610 --> 26:50.510
Si quieres seleccionar valores aleatorios, tienes muchas otras opciones.

26:50.510 --> 26:53.180
De nuevo, investiga un poco sobre pruebas parametrizadas.

26:53.360 --> 26:57.860
Usted puede cavar en la prueba de modo de juego, así si quieres, pero ya que va a ser más interesante

26:57.860 --> 27:02.000
en otros ejemplos, seguiremos adelante y concluiremos este de los talleres.

27:02.000 --> 27:02.840
Gracias.

27:09.660 --> 27:13.260
Hola y bienvenidos a este taller de Unity Unit testing.

27:13.260 --> 27:16.830
Vamos a ver mi cargador de datos Basic como ejemplo.

27:16.830 --> 27:17.420
Vamos a profundizar.

27:17.430 --> 27:20.280
Así que aquí en esta demo voy a abrir unity.

27:20.280 --> 27:25.650
Abrimos nuestro proyecto core de ejemplo y echamos un vistazo a la escena de mi cargador de datos básico.

27:25.650 --> 27:31.500
Ahora la razón por la que he elegido para hacer algún tipo de carga de datos es sólo para hablar de, bueno, lo que

27:31.500 --> 27:39.900
si nuestras pruebas unitarias, que esperamos que sean muy fiables y aisladas y se ejecutan rápidamente por el bien de nuestra

27:39.900 --> 27:42.000
propias metodologías de prueba?

27:42.000 --> 27:47.760
¿Y si dependen de otros sistemas, cómo sabemos que somos capaces de probar sólo una parte?

27:47.790 --> 27:55.740
En general, las pruebas unitarias son pruebas de una sola unidad, que se podría pensar como un método de una clase.

27:55.740 --> 28:01.740
Pero a menudo nuestro código es de múltiples clases que dependen entre sí, y que puede ser un reto para decidir

28:01.740 --> 28:05.100
cómo separarlas y probarlas aisladamente.

28:05.100 --> 28:11.280
Además, puedes tener un sistema que dependa de algo asíncrono como el renderizado de gráficos, renderizado

28:11.280 --> 28:14.760
audio, o en este caso, llamar a un servidor back-end.

28:14.760 --> 28:22.380
Así que he creado un ejemplo muy simple aquí que carga los datos que usted pasa en una URL, sólo llama a alguna página web

28:22.380 --> 28:24.630
y obtiene el texto de esa página web.

28:24.660 --> 28:31.410
Así que este es el ejemplo más simple, pero se podría imaginar que se trata de cualquier lógica de servidor llamando para enviar

28:31.410 --> 28:36.540
una puntuación alta de su juego, llamando para cargar los datos del jugador, algo relacionado con multijugador.

28:36.540 --> 28:41.250
Quizás todo eso podría depender de algún tráfico de red asíncrono.

28:41.340 --> 28:42.330
Echemos un vistazo.

28:42.420 --> 28:44.250
Aquí estamos en la muestra.

28:44.250 --> 28:46.290
Tenemos mi cargador de datos básico.

28:46.290 --> 28:46.890
Cárgalo.

28:46.890 --> 28:47.940
Vamos a darle al play.

28:50.730 --> 28:51.990
En esta demo en particular.

28:52.020 --> 28:56.550
No hay demasiadas cosas interesantes en esta demo en particular.

28:56.580 --> 28:58.950
No hay nada demasiado interesante en el juego.

28:59.220 --> 29:02.940
Iremos a la consola aquí y veremos que esta escena no tiene UI.

29:02.970 --> 29:09.300
Veamos la consola de unity, y entonces sólo muestra la longitud de lo que se devuelve desde el servidor.

29:09.300 --> 29:13.200
Cualquier cosa que no sea cero significa hey, cargó una página.

29:13.200 --> 29:14.670
Así que muy ligero.

29:14.670 --> 29:15.690
Prueba simple.

29:15.690 --> 29:19.190
No tengo comprobación de errores ni este tipo de cosas integradas.

29:19.200 --> 29:23.640
Sólo asume el éxito en aras de la simplicidad de esta demo.

29:23.670 --> 29:27.780
Si estás haciendo código de producción y estás llamando a servidores, querrás añadir mucha más funcionalidad

29:27.780 --> 29:28.410
a la misma.

29:28.410 --> 29:32.770
Así que esa es la experiencia en tiempo de ejecución, que es bastante simple y no tan interesante.

29:32.790 --> 29:38.550
Ahora bien, si nos fijamos en el ejecutor de pruebas aquí, podemos establecer nuestra categoría para ser mi cargador de datos básico.

29:38.550 --> 29:42.360
Así que sólo nos muestra las pruebas relacionadas con este código en particular.

29:42.360 --> 29:44.160
Y luego pasamos al modo de edición.

29:44.160 --> 29:48.210
Aquí de nuevo tenemos el modo de reproducción, pero puedes explorarlo por tu cuenta.

29:48.210 --> 29:52.230
Creo que para esta demo en particular el modo edición es más interesante.

29:52.230 --> 29:54.660
Así que voy a darle a ejecutar todo.

29:56.330 --> 29:58.350
Y podemos ver que tenemos éxito.

29:58.370 --> 30:04.520
Esto dice que load async result contiene doctype cuando se carga.

30:04.520 --> 30:06.500
Así que vamos a echar un vistazo a un poco de eso.

30:06.630 --> 30:08.780
Iremos aquí y abriremos nuestra fuente.

30:10.200 --> 30:11.820
Y aquí está la prueba.

30:11.940 --> 30:17.640
Se muestra que en primer lugar crear una instancia de nuestro My Data Loader básico.

30:17.940 --> 30:21.660
Luego escuchamos cuando se carga.

30:22.610 --> 30:25.880
Comprobaremos los datos cargados desde el servidor.

30:25.890 --> 30:30.800
De nuevo, esto es sólo llamar a una página web, y cualquiera que sea el código fuente de la página web lo devuelve como un

30:30.800 --> 30:32.030
una gran mancha de texto.

30:32.030 --> 30:34.370
Así que va a parecer algo de HTML.

30:34.370 --> 30:39.920
Y mientras lo miraba mientras creaba esto, me di cuenta de que decía doctype como parte de él.

30:39.920 --> 30:45.530
Así Doctype no es algo super importante, ciertamente no en el mundo de la unidad, pero yo sólo pensaba

30:45.530 --> 30:49.640
que era una pequeña prueba que me dice ¿recibí algo de una página web?

30:49.640 --> 30:53.030
Puedes imaginar hacer pruebas para cualquier otra subcadena que tenga sentido para ti.

30:53.120 --> 31:00.020
Finalmente, realizo la acción sobre la que estamos probando, y cargo la llamada asíncrona aquí

31:00.020 --> 31:01.340
y paso la URL.

31:01.370 --> 31:05.690
Ahora observa que la URL es la URL de la página de GitHub.

31:05.690 --> 31:07.280
Pero eso no es tan importante.

31:07.430 --> 31:08.600
No hay nada único ahí.

31:08.600 --> 31:15.620
Si quieres probar como el google.com sólo tiene que ir y llamar google.com y obtener la la fuente

31:15.620 --> 31:16.820
código fuente.

31:16.820 --> 31:22.220
En realidad no quiero centrarme en lo que estoy haciendo aquí en el código de producción, porque es un admitido

31:22.220 --> 31:23.330
ejemplo simple.

31:23.330 --> 31:28.640
Yo sólo quería que fuera una manera de conseguir algo asíncrono sucediendo dentro de la unidad.

31:29.800 --> 31:32.500
Así que vamos a ver el código fuente para que lo entendamos.

31:33.520 --> 31:33.970
Aquí.

31:33.970 --> 31:34.540
Lo que estamos haciendo.

31:34.540 --> 31:38.740
Cuando llamo a cargar, sólo digo, hey, asegúrate de que la URL no está vacía.

31:39.130 --> 31:44.320
Luego sigo adelante y uso la petición web de Unity, que es una funcionalidad incorporada.

31:44.320 --> 31:51.520
Llamo a enviar petición en eso, y luego establezco el resultado para que sea el texto del controlador de descarga.

31:51.550 --> 31:53.830
Esta es una forma super barata y fácil.

31:53.830 --> 31:57.010
Recomendado por unity para llamar datos simples en línea.

31:57.040 --> 31:58.570
Muy simple y sencillo.

31:58.600 --> 32:02.860
Esto nos lleva a preguntarnos ¿qué estamos probando aquí?

32:03.280 --> 32:09.580
Tengo una clase personalizada llamada mi cargador de datos, pero en su interior estoy dependiendo en gran medida de alguna unidad existente

32:09.610 --> 32:12.160
funcionalidad de unity web request.

32:12.190 --> 32:16.060
Entonces estoy llamando a alguna página web en este caso GitHub.

32:16.060 --> 32:17.650
Y eso es todo.

32:17.650 --> 32:22.810
Si GitHub estuviera de alguna manera fuera de servicio durante el día, esta prueba fallaría.

32:22.840 --> 32:24.100
¿Es apropiado?

32:24.100 --> 32:31.000
Si mi prueba unitaria es realmente para probar mi propia metodología, mi propia funcionalidad, no debería considerar

32:31.000 --> 32:32.050
una prueba fallida.

32:32.050 --> 32:34.840
Si alguna dependencia no relacionada falla.

32:34.840 --> 32:36.610
Pero aquí es el caso.

32:36.610 --> 32:38.640
Fallaría si GitHub estuviera caído.

32:38.650 --> 32:44.440
Además, aquí dentro estoy usando Unity web request que es una funcionalidad incorporada por unity.

32:44.470 --> 32:50.920
Esperamos que funcione el 100% de las veces en todas las situaciones, pero es posible que mi código funcione y

32:50.920 --> 32:52.210
su código no funcione.

32:52.210 --> 32:54.520
Así que hay una zona gris aquí.

32:54.520 --> 32:59.680
Cuando se piensa en el diseño de sus clases y luego el diseño de las pruebas en esas clases, ¿cómo se

32:59.680 --> 33:01.990
¿sabes en qué deberías centrarte?

33:01.990 --> 33:04.390
En las pruebas, en general.

33:04.390 --> 33:09.550
Y hay libros y libros escritos sobre este tema de cómo abordar el arte de las pruebas unitarias.

33:09.550 --> 33:15.370
Pero en términos generales, usted quiere reducir sus dependencias hacia abajo, y desea simplificar el número

33:15.370 --> 33:17.530
de líneas de código que estás probando.

33:17.530 --> 33:24.490
Así que menos código es mejor porque es más simple y centrado y usted sabe exactamente en el aislamiento que

33:24.490 --> 33:26.020
código estás probando.

33:26.020 --> 33:28.000
Este es un ejemplo perfecto.

33:28.000 --> 33:32.950
Pero para nosotros es una gran manera de empezar y sólo hablar de la ejecución de código asíncrono.

33:32.950 --> 33:35.020
Así que por ahora vamos a terminar este ejemplo.

33:42.300 --> 33:44.460
Hola y bienvenidos a Unit Testing for unity.

33:44.490 --> 33:48.120
Vamos a ver mi cargador de datos en versión avanzada aquí.

33:48.120 --> 33:54.270
Para ver esta demo en acción vamos a abrir unity Download y utilizar el proyecto de ejemplo Source para

33:54.270 --> 33:55.020
este curso.

33:55.020 --> 33:57.120
Y vamos a echar un vistazo a una escena clave aquí.

33:57.120 --> 33:59.310
Este es el cargador My Data avanzado.

33:59.310 --> 34:05.310
Algunos de los conceptos que voy a hablar aquí incluyen la inyección de dependencia como vemos y sustituto final.

34:05.310 --> 34:11.250
Aquí estamos dentro de unity tengo la escena para el cargador de My Data avanzado listo y listo para ir aquí.

34:11.250 --> 34:16.170
Así que vamos a seguir adelante y ejecutar esa escena para un buen montón de estas escenas en el taller.

34:16.170 --> 34:20.940
Ejecutar la escena de producción no es lo interesante, pero siempre os animo a hacerlo sólo

34:20.940 --> 34:21.990
como punto de partida.

34:21.990 --> 34:28.410
Así que aquí vemos simple registro de la consola que dice longitud de los datos cargados es este.

34:28.440 --> 34:32.220
Ese valor no es demasiado importante, pero puedes indagar en esa clase de ejemplo si quieres echarle un vistazo

34:32.220 --> 34:32.550
en él.

34:32.550 --> 34:34.290
Vamos a ejecutar la prueba para ello.

34:36.660 --> 34:40.200
Así que aquí arriba tengo mi categoría establecida en mi cargador de datos avanzado.

34:40.200 --> 34:44.430
Así que sólo estamos viendo las pruebas relacionadas con eso y sólo en el modo de edición.

34:44.460 --> 34:47.430
También hay una prueba en modo reproducción a la que puedes echar un vistazo cuando quieras.

34:47.430 --> 34:49.710
Pero creo que el modo edición es más interesante aquí.

34:49.710 --> 34:51.600
Así que voy a hacer correr todo.

34:57.250 --> 35:01.540
Y aquí vemos que tenemos dos pruebas y ambas pasan con una marca verde, lo que es genial.

35:01.570 --> 35:06.590
Echemos un vistazo a la carga asíncrona y al simulacro de carga asíncrona y veamos cómo funcionan.

35:06.610 --> 35:08.350
Aquí estamos en el código de ejemplo.

35:08.350 --> 35:11.260
Si has seguido desde el último video y espero que lo hagas.

35:11.290 --> 35:18.760
Repasamos el método que estamos viendo aquí, que utiliza una llamada real a un servidor web, carga

35:18.760 --> 35:21.000
los datos y comprueba su valor.

35:21.010 --> 35:24.460
¿Esto se parece mucho a lo que sería el caso de uso en producción?

35:24.460 --> 35:26.950
Pero ya hemos hablado de algunos problemas.

35:26.980 --> 35:31.150
¿Estoy probando mi código o estoy probando el servicio web de Unity?

35:31.180 --> 35:35.260
¿Estoy probando eso o estoy probando el backend de github.com?

35:35.260 --> 35:42.130
Y si se trata de un servidor estable, querrás centrar tus pruebas en tu propio código personalizado y tener como mínimo

35:42.130 --> 35:43.900
y menos dependencias posibles.

35:43.900 --> 35:46.060
Hay algunos problemas con esto.

35:46.090 --> 35:51.990
Lo primero que hice cuando me puse a ello fue pensar en la inyección de dependencias.

35:52.000 --> 35:58.630
Digamos que en producción quiero tener una forma de llamar a esto y que se implemente, que

35:58.630 --> 36:00.480
es usando el servicio web de Unity.

36:00.490 --> 36:04.780
Entonces, para las pruebas, tal vez quiero tener una segunda forma de abordarlo.

36:04.810 --> 36:11.890
Ahora, usted podría tener una bandera en su base de código que dice algo así como es la depuración es igual a verdadero o es la producción

36:11.890 --> 36:12.790
¿igual a falso?

36:12.790 --> 36:17.360
Y en su código de producción, hacer ciertas cosas en modo de prueba y ciertas cosas no.

36:17.380 --> 36:21.930
Veo mucho de eso en bases de código, pero generalmente no es una buena práctica.

36:21.940 --> 36:27.880
Estás contaminando tu código de producción con cosas que en realidad son sólo para pruebas, así que no es tan apropiado.

36:27.910 --> 36:29.320
Esta es una mejor solución.

36:29.320 --> 36:30.700
Echemos un vistazo a lo que hacemos.

36:31.270 --> 36:37.450
Bien, en el ejemplo básico anterior, no tenía el concepto de servicio de red, ni pasé

36:37.450 --> 36:38.220
aquí.

36:38.230 --> 36:41.560
Simplemente lo creamos y siempre funcionó de una manera.

36:41.560 --> 36:45.760
Pero la inyección de dependencia aquí es que yo decido.

36:45.760 --> 36:49.170
Aquí hay una forma personalizada en que esto podría funcionar.

36:49.180 --> 36:53.380
Aquí hay algo de la lógica que podría cambiar de diferentes maneras.

36:53.380 --> 36:56.020
Lo declaro aquí en una línea, y luego lo paso.

36:56.020 --> 36:59.560
Así que podrías imaginar tener varios servicios de red diferentes.

36:59.560 --> 37:04.120
Podría tener uno que es sólo para pruebas, uno que es sólo para producción, uno que sólo escribe a

37:04.120 --> 37:08.680
un disco local, uno que sea apropiado para un servidor backend en particular.

37:08.680 --> 37:09.460
Etcétera.

37:09.490 --> 37:12.160
Esto también tiene casos de uso en producción.

37:12.160 --> 37:14.060
Esta idea de inyección de dependencia.

37:14.080 --> 37:16.360
¿Por qué lo llamamos inyección de dependencias?

37:16.360 --> 37:26.080
Es porque en lugar de que mi cargador de datos avanzado haga siempre una cosa, le paso alguna información que decide

37:26.080 --> 37:27.610
cómo va a funcionar.

37:27.610 --> 37:34.090
Así que en lugar de que la propia clase lo sepa todo, estoy pasando una dependencia en este caso a

37:34.090 --> 37:36.250
el servicio Unity Web Request Network.

37:36.250 --> 37:42.610
Así que vamos a echar un vistazo a cómo se estructuró, y luego vamos a ver por qué es útil para nosotros a medida que hacemos nuestra

37:42.610 --> 37:43.300
pruebas.

37:43.390 --> 37:47.140
Así que aquí está el código fuente completo para el My Data loader advanced.

37:47.170 --> 37:49.420
Ahora dos cosas en las que quiero centrarme aquí.

37:49.420 --> 37:53.530
Una es que en su constructor le paso esa dependencia.

37:53.560 --> 38:01.060
Ahora inyección de dependencia y cómo crear clases flexibles a partir de este concepto de inyección de dependencia

38:01.060 --> 38:03.700
están realmente fuera del alcance de esta clase.

38:03.730 --> 38:06.220
Es algo realmente bueno para que vayas y lo veas.

38:06.220 --> 38:12.730
Podrías buscar en google algo como D I para unity o inyección de dependencia para unity, o incluso dependencia

38:12.730 --> 38:17.410
en la programación orientada a objetos, y ver algunos más de los conceptos generales.

38:17.410 --> 38:23.160
Pero asumiendo que tienes cierta familiaridad, especialmente dada mi explicación, que acabo de dar aquí,

38:23.170 --> 38:24.460
Sigamos adelante.

38:24.490 --> 38:31.810
Ahora que estoy pasando en que como una dependencia aquí y almacenarlo, entonces cada vez que llamo a nuestra funcionalidad básica

38:31.840 --> 38:38.560
de carga asíncrona, lo que hago es decir, bien, cuando estoy listo para cargar asíncrona, sólo decirle a mi servicio de red

38:38.560 --> 38:39.730
que cargue async.

38:39.730 --> 38:47.020
Ahora puedes imaginar si he pasado un servicio de red que hace una carga asíncrona para un servidor back-end

38:47.020 --> 38:48.820
de una tecnología en particular.

38:48.850 --> 38:50.410
Esta línea de aquí lo haría.

38:50.650 --> 38:56.920
Que si yo pasara algo más que hiciera una escritura a disco o lectura de disco como un tipo diferente

38:56.920 --> 38:59.980
de servicio de red, esta es la línea aquí que realmente cambiaría.

38:59.980 --> 39:06.130
Así que no tengo que tener 2 o 3 versiones diferentes de la mi cargador de datos avanzado aquí.

39:06.130 --> 39:11.130
En su lugar, paso una implementación personalizada que maneja ese detalle particular de una manera única.

39:11.140 --> 39:15.130
Es una forma muy poderosa de hacer que tu código sea más flexible.

39:15.130 --> 39:23.410
Ahora, ahora que hemos hablado de pasar una dependencia y cómo es capaz de envolver la funcionalidad

39:23.410 --> 39:26.650
aquí, vamos a ver lo que la fuente de este particular es.

39:26.650 --> 39:31.240
Así que aquí arriba en el mismo archivo de clase tengo un par de cosas de las que hablar.

39:31.240 --> 39:33.580
Una, he creado una interfaz.

39:33.700 --> 39:41.230
Esta interfaz aquí de I servicio de red declara bien, cualquiera que quiera ser considerado como un viable

39:41.230 --> 39:47.020
tiene que tener algún método o métodos disponibles.

39:47.020 --> 39:51.970
Y en este caso, sólo tiene que tener la carga asíncrona y tomar una cadena URL.

39:51.970 --> 39:52.720
Y ya está.

39:52.750 --> 39:56.620
Ahora, si no estás muy familiarizado con las interfaces.

39:56.940 --> 39:58.560
Por favor, echa un vistazo a las interfaces.

39:58.560 --> 40:04.290
Puedes mirar algo como interfaces versus clases en C-sharp o en unity, y verás un montón de...

40:04.290 --> 40:05.130
de ejemplos.

40:05.130 --> 40:11.970
Pero una distinción importante aquí es que la interfaz define lo que es la API pública, pero no lo hace

40:11.970 --> 40:13.980
se preocupa de hacer la implementación.

40:14.100 --> 40:17.530
La implementación se declara aquí abajo en una clase pública.

40:17.560 --> 40:19.710
Ahora las clases con las que probablemente estés más familiarizado.

40:20.010 --> 40:24.570
Y lo que hacemos aquí es implementar un sabor particular de eso.

40:24.600 --> 40:30.360
El servicio de red en esta versión particular debería resultarte muy familiar del vídeo anterior.

40:30.390 --> 40:32.760
Esta es exactamente la misma implementación.

40:33.030 --> 40:40.130
Sólo estamos usando la petición web de la unidad y luego haciendo su metodología de enviar petición web.

40:40.140 --> 40:45.510
Así que ahora que hemos mirado el código fuente de volver aquí, podemos ver, bien, sólo estamos creando

40:45.510 --> 40:48.270
una clase personalizada que maneja un poco de la funcionalidad.

40:48.270 --> 40:50.520
Y pasamos esa clase personalizada allí.

40:50.520 --> 40:55.010
Pero ahora tenemos un cargador de datos de clase avanzada que es mucho más flexible.

40:55.020 --> 40:59.720
Ahora, ¿por qué específicamente en el mundo de las pruebas, la inyección de dependencia es relevante?

40:59.730 --> 41:05.370
Bueno, tenemos una maravillosa utilidad que podemos utilizar dentro de unity para nuestras pruebas unitarias.

41:05.370 --> 41:10.800
Esta es una biblioteca llamada N sustituto y se ha incluido aquí en el proyecto de ejemplo.

41:10.800 --> 41:13.980
Echemos un vistazo a otro método de prueba justo debajo del otro.

41:13.980 --> 41:17.880
Y esto va a utilizar lo que se llama un simulacro de una clase.

41:17.880 --> 41:23.280
Así que aquí tenemos una creación muy similar del cargador My Data avanzado.

41:23.280 --> 41:29.070
Y en lugar de pasar la versión de la petición web de la unidad, vamos a hacer algo que parece bastante

41:29.100 --> 41:29.880
extraño aquí.

41:29.880 --> 41:32.940
Vamos a utilizar la biblioteca sustituta.

41:32.940 --> 41:40.260
Y lo que vamos a hacer aquí es decir hey on the fly en estas dos líneas, ir a crear

41:40.260 --> 41:45.000
una clase que puede manejar sólo la funcionalidad que necesito.

41:45.000 --> 41:51.990
Pero debido a que es una clase simulada, no necesariamente tiene que llamar al servidor.

41:51.990 --> 41:57.450
Lo que va a hacer en su lugar es, en momentos clave, devolvernos un valor predecible.

41:57.450 --> 42:06.660
Ahora recuerda, nuestro flujo aquí es que la prueba le dice al cargador de datos que vaya a cargar una URL dentro de los datos

42:06.660 --> 42:10.740
le dice al servicio de red que cargue una URL.

42:10.770 --> 42:17.430
Ese último paso, el resultado final es que tarda medio segundo, va y carga desde el servidor y devuelve

42:17.460 --> 42:18.870
una cadena de vuelta.

42:18.870 --> 42:23.760
Así que todo lo que realmente necesito en una situación simulada es bien, ni siquiera llamar a un servidor.

42:23.760 --> 42:27.330
Sólo cuando llame a esto me devuelves una cadena.

42:27.330 --> 42:36.750
Así que estoy diciendo aquí con este lenguaje que quiero que cada vez que llame a load async y le pase cualquier cadena

42:36.750 --> 42:41.460
para la URL, entonces devuelve la palabra mocked data.

42:41.760 --> 42:48.060
Entonces aquí abajo, podría asegurarme de que estoy obteniendo el resultado esperado que quiero, en lugar de comprobar

42:48.060 --> 42:52.020
que tiene doctype en el retorno como hice anteriormente.

42:52.020 --> 42:55.740
Aquí puedo comprobar los datos simulados.

42:55.740 --> 43:04.380
Así que lo que estamos viendo aquí es un ejemplo muy simple, y podría no parecer útil, pero imagina en un

43:04.380 --> 43:11.580
ejemplo más complejo en el que no sólo cargáramos datos, sino que los cargáramos, leyéramos, escribiéramos, transformáramos...

43:11.580 --> 43:14.850
los datos, haciendo bastante, tal vez 5 o 6 métodos diferentes.

43:14.850 --> 43:21.150
Todos ellos podrían estar apuntando a sistemas muy diferentes, pero cuando realmente queremos probar sólo el

43:21.150 --> 43:30.330
cargador de datos, entonces queremos pasar en habilidades simuladas para los otros sistemas a ser sólo una especie de temporalmente

43:30.330 --> 43:34.230
para que podamos centrarnos en lo que tenemos entre manos.

43:34.260 --> 43:36.450
Ahora echemos un vistazo a lo que pasaría.

43:36.450 --> 43:38.940
Así que llamo a la carga async.

43:38.940 --> 43:46.050
Lo que va a pasar es que este sistema va a devolver el valor previsto.

43:46.050 --> 43:50.220
Y el cargador de datos va a llamar cargado.

43:50.220 --> 43:56.160
Y va a hacer que su valor resultante sea el valor que esperamos que sea.

43:56.160 --> 44:00.330
Así que vamos a ejecutar esto dentro del editor de la unidad.

44:00.330 --> 44:01.800
Así que vamos a pulsar ejecutar todo aquí.

44:04.100 --> 44:05.480
Y funciona bastante rápido.

44:05.480 --> 44:11.270
Comparemos incluso si sólo ejecuto load async que en realidad está llamando a un servidor.

44:15.200 --> 44:16.220
Fue rápido.

44:16.250 --> 44:20.690
Entonces si llamo a mock load async que no está llamando a ningún servidor.

44:24.630 --> 44:29.840
Puede que no sea evidente en el video, pero es mucho más rápido llamar al MOC.

44:29.850 --> 44:35.150
Y eso tiene sentido porque en realidad no estamos llamando a un servidor y esperando un resultado.

44:35.160 --> 44:38.640
Así que esto no es sólo para ahorrarnos unos segundos.

44:38.670 --> 44:42.270
Es de nuevo para que nos centremos mientras diseñamos nuestras pruebas.

44:42.300 --> 44:44.790
¿Qué es lo que realmente queremos probar?

44:44.790 --> 44:46.920
Y luego queremos aislarlo.

44:46.920 --> 44:51.160
Así que en realidad no estamos probando una clase de Unity Web Services.

44:51.180 --> 44:53.610
No estamos probando un backend de GitHub.

44:53.700 --> 44:57.470
Probar varios sistemas juntos se llama prueba de integración.

44:57.480 --> 44:59.550
Es un tipo de prueba apropiado.

44:59.550 --> 45:03.660
Pero está fuera de lo que estamos hablando aquí, que son las pruebas unitarias.

45:03.660 --> 45:08.430
De nuevo, reduciendo al máximo las dependencias y las líneas de código.

45:08.430 --> 45:09.450
Podrías pensarlo.

45:09.450 --> 45:17.880
Así que eso es todo, hemos visto cómo utilizar la biblioteca de sustitución y cómo también podemos hacer un simulacro para

45:17.880 --> 45:19.710
una llamada al servidor.

45:19.710 --> 45:20.550
Gracias.

45:26.450 --> 45:29.420
Hola y bienvenidos a Unit testing for unity.

45:29.450 --> 45:30.710
Estamos en el taller.

45:30.710 --> 45:34.850
Y en este vamos a echar un vistazo al personaje de forma básica.

45:34.850 --> 45:37.070
Vamos a ver unas cuantas diferentes.

45:37.100 --> 45:39.800
Empezaremos con lo básico y pasaremos a algo más avanzado.

45:39.800 --> 45:41.480
Echemos un vistazo a esta demo en acción.

45:41.480 --> 45:42.920
Dentro del editor unity.

45:42.920 --> 45:45.830
Vamos a abrir unity, abrir nuestro proyecto de ejemplo.

45:45.830 --> 45:49.760
Y luego vamos a jugar una o más escenas relacionadas con el tema aquí.

45:49.760 --> 45:55.670
La escena va a ser el carácter básico, y voy a estar hablando de Monobehaviour como algo

45:55.670 --> 46:01.160
que puede o no puede ser probado, así como el modo de juego frente al modo de edición, algo que he mencionado

46:01.160 --> 46:02.450
anteriormente en el curso.

46:02.450 --> 46:04.010
Lo traeremos aquí y hablaremos de ello.

46:04.010 --> 46:06.380
Aquí estamos en el proyecto viendo el carácter básico.

46:06.380 --> 46:07.760
Vamos a ejecutar la escena.

46:13.120 --> 46:20.020
Así que mientras la mayoría de los talleres que hemos hecho ya tenían una escena bastante aburrida donde absolutamente nada

46:20.050 --> 46:22.830
de interés, tenemos algo más.

46:22.840 --> 46:28.470
Cuando le damos al play ahí, vemos un cubo blanco que se hace crear en el centro de la pantalla.

46:28.480 --> 46:31.030
Puedo usar las flechas del teclado y moverme.

46:31.030 --> 46:37.930
Aunque se trata de un ejemplo muy simple, se trata de hablar de algunos de los aspectos más complejos de la programación.

46:37.930 --> 46:40.600
aspectos de las pruebas dentro de la unidad.

46:40.630 --> 46:45.730
En las escenas anteriores, no estábamos preocupados por el renderizado de gráficos o la toma de datos.

46:45.970 --> 46:52.840
En el último taller hablamos de la diferencia entre probar varias dependencias diferentes

46:52.840 --> 46:53.590
juntas.

46:53.590 --> 46:58.780
Por ejemplo, un método que dentro llama a un segundo método que dentro llama a un tercero.

46:58.810 --> 47:00.490
Eso son dependencias.

47:00.520 --> 47:06.790
Aquí estamos hablando de un aspecto similar, excepto que cada vez que quiero mover mi personaje, primero

47:06.790 --> 47:13.750
pido escuchar el sistema de entrada de Unity, luego uso el movimiento de transformación Monobehaviour de Unity.

47:13.750 --> 47:14.190
Correcto.

47:14.200 --> 47:18.820
Así que estamos usando diferentes dependencias o diferentes clases.

47:21.360 --> 47:24.630
Aquí puedo usar las flechas para moverme.

47:25.750 --> 47:27.190
Y eso es todo.

47:29.010 --> 47:32.100
Pero la idea es que estamos haciendo un poco más que antes.

47:32.190 --> 47:34.650
Hablemos de las implicaciones de probar eso.

47:34.650 --> 47:41.190
Así que aquí arriba en el ejecutor de pruebas, tengo la categoría establecida a nuestro carácter básico, lo cual es genial.

47:41.220 --> 47:46.800
Entonces puedo cambiar para ver las pruebas del modo de juego, así como las pruebas del modo de edición.

47:46.830 --> 47:53.100
Podemos ver que tenemos algo de ambos, pero como hay un monocomportamiento involucrado, voy a

47:53.100 --> 47:54.600
centrarme más en el modo de juego.

47:54.630 --> 48:01.230
Ahora, en cada uno de los talleres, he incluido al menos una prueba de modo edición y al menos una de modo reproducción

48:01.260 --> 48:03.420
para la escena en cuestión.

48:03.450 --> 48:09.030
Lo he hecho de nuevo aquí, pero dependiendo de lo que estés probando en realidad, querrás pensar, es esto

48:09.030 --> 48:13.470
más apropiado para el modo de edición o es más apropiado para el modo de reproducción?

48:13.500 --> 48:18.510
Hay un arte y una ciencia en cómo enfocar eso, y en cómo diseñar tu código para que sea más

48:18.510 --> 48:19.170
comprobable.

48:19.200 --> 48:26.010
Pero una forma general de verlo que es relevante aquí es que si estás usando funcionalidad Monobehaviour,

48:26.010 --> 48:32.460
que suena más como una prueba de modo de juego, las bibliotecas más unidad, sobre todo en tiempo de ejecución, estás

48:32.460 --> 48:36.840
usas en tu producción, querrás pensar que son pruebas de modo de juego.

48:36.870 --> 48:40.410
No es una regla rígida, pero es una buena forma de empezar a pensar en ello.

48:40.650 --> 48:42.490
Hagamos nuestras pruebas.

48:42.510 --> 48:45.300
Tengo el modo de reproducción y voy a ejecutarlo todo.

48:48.880 --> 48:49.210
Bien.

48:49.240 --> 48:52.060
Ha tardado un par de segundos en ejecutarse, pero ya los tenemos todos.

48:52.090 --> 48:58.060
Lo que realmente sucede cuando se está ejecutando una prueba de modo de juego es que crea una nueva escena vacía y

48:58.060 --> 49:01.840
ejecuta sólo una prueba dentro de ella, y la destruye.

49:01.840 --> 49:09.040
Y crea una nueva escena garantizando que tenemos el espacio del mundo proporcionado por una escena.

49:09.040 --> 49:16.000
Pero la frescura de una nueva escena que no tiene ninguna dependencia o información obsoleta que pueda influir en

49:16.000 --> 49:16.630
la prueba.

49:16.630 --> 49:18.230
Así que nos gusta cómo está configurado.

49:18.250 --> 49:25.030
Ahora, las cosas que estoy haciendo son moverme, moverme por código clave y moverme a un lugar en particular.

49:25.030 --> 49:27.640
Echemos un vistazo a este movimiento de prueba.

49:29.650 --> 49:31.990
En realidad, echemos un vistazo primero al código de producción.

49:31.990 --> 49:34.960
Así que si voy aquí y miro el ejemplo básico.

49:36.760 --> 49:38.560
Este es el código de producción.

49:38.560 --> 49:40.720
Veámoslo antes de pasar a las pruebas.

49:40.720 --> 49:43.960
Aquí todo lo que hago es crear una primitiva.

49:43.990 --> 49:49.030
Podrías imaginar también cargar un prefab aquí si quisieras hacer eso.

49:49.030 --> 49:54.010
Pero quería meternos poco a poco en todas las complejidades del tiempo de ejecución y unity.

49:54.010 --> 49:56.140
Así que no estoy usando un prefab aquí.

49:56.140 --> 50:00.130
Simplemente creo un nuevo cubo desde cero con una línea de código.

50:00.130 --> 50:06.820
Le doy un nombre sólo para organizarlo, y luego añado el componente del mono-comportamiento

50:06.820 --> 50:08.620
que realmente quiero probar.

50:08.650 --> 50:14.770
Entonces una de las cosas que estoy haciendo es simplemente moverlo al punto de 000, y luego mostrar que

50:14.770 --> 50:16.300
valor en la pantalla.

50:16.300 --> 50:18.850
Echemos un vistazo al código fuente.

50:21.530 --> 50:22.960
Aquí está el carácter básico.

50:22.970 --> 50:24.770
Esto extiende Monobehaviour.

50:24.800 --> 50:32.730
Ahora, si estás familiarizado con unity, probablemente uses Monobehaviours todo el tiempo como una buena práctica.

50:32.750 --> 50:35.600
Quieres empezar a pensar a conciencia.

50:35.600 --> 50:40.660
¿Cuándo es apropiado utilizar un monocomportamiento y cuándo puedo utilizar algo diferente?

50:40.670 --> 50:46.580
Como desarrolladores principiantes, creamos todo como un hijo del mono-comportamiento, pero con el tiempo y la experiencia

50:46.580 --> 50:49.900
te das cuenta de que hay pros y contras de usar mono-comportamientos.

50:49.910 --> 50:54.620
Uno de los contras es que, históricamente, era más difícil hacer pruebas sobre la marcha.

50:54.620 --> 50:56.570
Unity proporcionó estas pruebas de modo de juego.

50:56.570 --> 51:00.950
Así que ahora sin duda podemos probar Playmode y podemos probar Monobehaviours.

51:00.950 --> 51:03.630
Eso es genial, pero aún hay algunos inconvenientes.

51:03.650 --> 51:08.330
De nuevo, Monobehaviour va a depender de más sistemas de unidad bajo el capó.

51:08.330 --> 51:13.700
Y cuando estamos tratando de probar nuestro código personalizado, puede que no estemos seguros de dónde puede estar el problema.

51:13.730 --> 51:15.720
¿Es nuestro código o es el código de Unity?

51:15.740 --> 51:18.110
De nuevo, hay algunas dependencias.

51:18.140 --> 51:22.280
Todo esto está bien, pero es algo en lo que querrás pensar cuando estés diseñando tus clases y como

51:22.280 --> 51:23.690
estás diseñando tus pruebas.

51:24.110 --> 51:27.080
Así que tenemos una velocidad de movimiento.

51:27.110 --> 51:28.460
Tenemos un tipo de movimiento.

51:28.460 --> 51:31.390
Esto es sólo la dirección de la tecla de flecha que estoy pulsando.

51:31.400 --> 51:33.680
Luego usamos la actualización de Unity.

51:33.710 --> 51:36.530
Ahora déjame comprobarlo dos veces.

51:38.720 --> 51:39.230
De verdad.

51:39.230 --> 51:44.960
El bucle de actualización es la única funcionalidad importante que estoy usando.

51:44.990 --> 51:49.130
El resto de este código no tiene que estar necesariamente en un mono-comportamiento.

51:49.220 --> 51:53.560
También estoy usando el sistema de entrada de Unity, así que esa es una segunda dependencia.

51:53.570 --> 51:56.760
Veamos que hago en cada frame de actualización.

51:56.780 --> 51:59.360
Llamo a este método de aquí mover por entrada.

51:59.390 --> 52:04.340
Compruebo si el usuario está pulsando una tecla o teclas concretas del teclado.

52:04.340 --> 52:08.360
Y luego llamo a mover por código de tecla aquí abajo.

52:09.710 --> 52:16.220
Todo lo que hacemos es decir, si actualmente nos estamos moviendo a la izquierda, entonces vamos a movernos en un vector para la dirección izquierda.

52:16.220 --> 52:19.820
Si actualmente nos estamos moviendo a la derecha y etcétera para arriba y abajo.

52:19.820 --> 52:24.860
Así que esto te permitiría moverte en las cuatro direcciones usando las cuatro teclas de flecha.

52:24.860 --> 52:26.420
Un código bastante sencillo.

52:26.420 --> 52:30.440
Y si has creado tu propio personaje personalizado antes, estarás familiarizado con la configuración de algo como

52:30.440 --> 52:30.980
esto.

52:34.010 --> 52:35.870
Aquí abajo, tenemos dos métodos.

52:35.870 --> 52:41.240
Uno que nos permite movernos a un punto en particular y otro que nos permite movernos por una unidad.

52:41.240 --> 52:44.090
Digamos que quiero moverme a la derecha una unidad.

52:44.090 --> 52:48.490
Podría pasar una unidad, una unidad, una unidad.

52:48.500 --> 52:53.740
Si quiero moverme directamente a un punto concreto del espacio, ese sería el movimiento a.

52:53.750 --> 52:59.810
Así que estos no son necesariamente los únicos métodos que necesitarías en una clase de personaje personalizada, pero hay

52:59.810 --> 53:01.100
algunos bastante comunes.

53:01.100 --> 53:07.850
Así que vamos a terminar esta lección aquí con sólo esto como una forma básica y adecuada de trabajo para probar algunas funcionalidades.

53:07.850 --> 53:13.340
Si quieres echar un vistazo al modo de edición o a las otras pruebas que están aquí en el modo de reproducción, adelante

53:13.340 --> 53:14.230
y hazlo.

53:14.240 --> 53:15.830
Pasaré al siguiente vídeo.

53:15.830 --> 53:16.580
Gracias.

53:22.920 --> 53:26.060
Hola y bienvenidos a Unit Testing for unity.

53:26.070 --> 53:30.060
En este taller veremos la clase personaje en una versión avanzada.

53:30.060 --> 53:31.980
Echemos un vistazo a esta demo en acción.

53:31.980 --> 53:32.310
Aquí.

53:32.310 --> 53:33.990
Vamos a abrir nuestra unidad.

53:34.020 --> 53:36.000
Vamos a abrir nuestro proyecto de ejemplo.

53:36.000 --> 53:41.190
Y vamos a echar un vistazo a una escena dentro de la situación de carácter avanzado aquí.

53:41.190 --> 53:44.310
Quiero hablar un poco sobre la separación de código.

53:44.340 --> 53:49.110
Antes, en uno de los talleres, hablé de las diferentes dependencias que tendrías.

53:49.110 --> 53:51.360
Por ejemplo, si estás llamando a un servidor back-end.

53:51.360 --> 53:58.530
Y en esa situación, usamos una librería sustituta para burlarnos y no necesitar llamar al back end.

53:58.560 --> 54:04.890
Es una discusión similar aquí donde estamos viendo cuáles son las dependencias involucradas con un particular

54:04.890 --> 54:11.640
escenario de prueba, y cómo podemos ser conscientes de esas diferentes dependencias, y qué queremos hacer acerca de

54:11.640 --> 54:12.240
aquí?

54:12.240 --> 54:14.400
No vamos a usar la biblioteca sustituta.

54:14.430 --> 54:18.960
Vamos a pensar en separar nuestro mono-comportamiento de otro código y echar un vistazo.

54:19.170 --> 54:20.940
Así que aquí estamos dentro de unity.

54:21.270 --> 54:22.440
Tenemos una clase de producción.

54:22.440 --> 54:23.250
Vamos a echarle un vistazo.

54:23.250 --> 54:23.850
Corriendo.

54:27.540 --> 54:30.510
Aquí abajo, vemos que podemos movernos con las flechas del teclado.

54:30.510 --> 54:34.050
Al igual que en el ejemplo básico, la experiencia del usuario final es la misma.

54:34.050 --> 54:39.330
Y ese es un ejemplo interesante aquí, que algunos de los cambios que hacemos para el código

54:39.330 --> 54:44.250
la calidad del código y la comprobabilidad de nuestros sistemas no necesariamente afectan al usuario final.

54:44.280 --> 54:45.350
Eso es positivo.

54:45.360 --> 54:48.270
Echemos un vistazo al código de producción.

54:48.270 --> 54:50.340
Abriremos el ejemplo avanzado de caracteres.

54:50.340 --> 54:51.890
Aquí tenemos un ejemplo completo.

54:51.900 --> 54:57.830
Lo que estamos haciendo dentro de la estela de esta clase de ejemplo es crear una primitiva para el cubo.

54:57.840 --> 55:00.270
Le damos un nombre para organizarlo.

55:00.390 --> 55:08.010
Luego, en lugar de una línea aquí donde sólo añadimos un componente que tiene toda nuestra funcionalidad, hacemos

55:08.010 --> 55:09.180
dos pasos.

55:09.450 --> 55:14.700
Esto me recuerda un poco a la inyección de dependencia que vimos en el ejemplo del cargador My Data.

55:14.700 --> 55:17.970
Pero este es un caso de uso diferente con diferentes dependencias.

55:17.970 --> 55:22.920
Así que en lugar de sólo una línea de agregar componente hacemos la de agregar componente.

55:22.920 --> 55:28.260
Y luego creamos nuestra propia clase avanzada de caracteres no monocomportamiento.

55:28.260 --> 55:30.540
Y le pasamos el Monobehaviour.

55:30.540 --> 55:35.370
Así que estamos pasando en la dependencia que el carácter avanzado va a utilizar.

55:35.400 --> 55:41.910
Ahora el carácter avanzado no es un mono-comportamiento, y por lo tanto tenemos más flexibilidad con la forma en que queremos

55:41.910 --> 55:42.480
probarlo.

55:42.510 --> 55:45.780
Podríamos probarlo en modo edición, por ejemplo, más fácilmente.

55:45.930 --> 55:51.000
De nuevo, siempre que uses Monobehaviours es más apropiado para pruebas en modo reproducción.

55:51.030 --> 55:53.940
No es una regla rígida, pero es una forma de verlo.

55:53.940 --> 56:00.660
Así que aquí, separando nuestro mono comportamiento de nuestro no mono comportamiento, tenemos algunas opciones más.

56:00.690 --> 56:06.060
Ahora todavía estamos aquí en un entorno de modo de juego porque este es el código de producción.

56:06.060 --> 56:08.970
Entremos y veamos cómo ha cambiado nuestro código fuente.

56:08.970 --> 56:11.010
Aquí estamos en el carácter avanzado.

56:11.040 --> 56:13.220
Verás que parece bastante familiar.

56:13.230 --> 56:17.790
La mayor parte del código aquí va a ser igual que en el ejemplo básico anterior.

56:17.800 --> 56:19.080
Las pocas excepciones.

56:19.090 --> 56:25.710
Una es que el carácter avanzado va a tomar una referencia en su constructor al Monobehaviour.

56:25.710 --> 56:30.900
Esto se debe a que necesita saber algunas cosas sobre el Monobehaviour, en particular sobre su transformación

56:30.900 --> 56:31.710
posición.

56:31.830 --> 56:38.400
También hay una situación en la que necesitamos usar la segunda línea y decirle al Monobehaviour una referencia

56:38.400 --> 56:40.830
de vuelta a nosotros como el carácter avanzado.

56:40.860 --> 56:47.460
Esto es sólo para que el MonoComportamiento, cada vez que llame a update pueda decirnos que hagamos el movimiento apropiado.

56:47.490 --> 56:52.950
Hay otras maneras de organizar esto, pero por simplicidad, estamos pasando en el mono-comportamiento

56:52.950 --> 56:54.360
y lo manejamos de esta manera.

56:54.660 --> 56:57.150
Veamos qué otros cambios vemos en el código base.

56:58.510 --> 57:00.820
El tipo de movimiento es el mismo que el básico.

57:00.850 --> 57:03.040
El movimiento por entrada es el mismo.

57:03.940 --> 57:08.260
Aquí abajo el movimiento por código de tecla es muy similar, si no idéntico.

57:09.300 --> 57:15.630
Y luego aquí abajo en mover a y mover por, puedes notar que estamos obteniendo y fijando la posición

57:15.630 --> 57:18.300
en la transformación del Monobehaviour.

57:18.300 --> 57:25.260
Así que de nuevo tenemos una clase que no es monocomportamiento haciendo lo que puede hacer sin depender de

57:25.260 --> 57:30.810
monocomportamiento y sólo en los puntos más necesarios se dirige al Monocomportamiento.

57:30.840 --> 57:36.840
Esa separación empieza a ayudarnos a pensar en cómo podríamos probar sólo el monocomportamiento si pudiéramos,

57:36.840 --> 57:39.910
¿cómo podríamos probar sólo el no mono-comportamiento si pudiéramos?

57:39.930 --> 57:45.240
Ahora, esto no es un ejemplo perfecto porque es una especie de paso intermedio a medida que avanzamos aprendiendo sobre

57:45.240 --> 57:47.040
cómo podemos separarlos correctamente.

57:47.040 --> 57:48.600
Pero creo que es un buen aprendizaje.

57:48.600 --> 57:52.500
Así que mira el código fuente aquí para el carácter avanzado.

57:52.500 --> 57:56.550
Compáralo con character basic en tu tiempo libre y observa las diferencias.

57:56.730 --> 57:59.580
Entonces echemos un vistazo al ejemplo que hacemos.

57:59.580 --> 57:59.970
Otra vez.

57:59.970 --> 58:01.500
Este es el ejemplo que vimos.

58:01.500 --> 58:02.670
Así que son estas dos líneas.

58:02.670 --> 58:03.900
Esa es realmente la clave.

58:03.930 --> 58:09.960
Vamos a añadir un componente del carácter avanzado Monobehaviour en nuestro objeto de juego.

58:09.960 --> 58:12.270
Y luego vamos a crear un nuevo personaje avanzado.

58:12.270 --> 58:13.440
Ese es un paso separado.

58:13.440 --> 58:17.010
Así que se podría imaginar que seríamos capaces de probar esas dos cosas de forma aislada.

58:17.010 --> 58:19.320
Ahora son bastante dependientes la una de la otra.

58:19.350 --> 58:24.000
Hay formas en las que podríamos masajear eso para que una no dependa directamente de la otra.

58:24.000 --> 58:30.330
O podríamos hacer algo como lo que hicimos en el ejemplo del cargador de datos y utilizar una biblioteca sustituta para que

58:30.330 --> 58:32.730
estamos burlándonos de la dependencia en su lugar.

58:32.730 --> 58:38.400
Pero de nuevo, para simplificar el aprendizaje de cómo separar un mono-comportamiento, creo que hemos hecho

58:38.400 --> 58:39.210
el caso aquí.

58:39.210 --> 58:44.100
Puedes hacer esas pruebas con el modo edición y el modo reproducción en tu tiempo libre y echar un vistazo a esto.

58:44.370 --> 58:50.460
Pero para mí, creo que hemos terminado de hablar sobre las diferencias en la separación de mono comportamiento y no mono comportamiento.

58:50.490 --> 58:51.120
Gracias.

58:57.320 --> 58:59.600
Hola y bienvenido a Unit Testing for unity.

58:59.630 --> 59:02.630
Este es nuestro taller hablando sobre la física de los personajes.

59:02.660 --> 59:09.110
Ahora, en los talleres anteriores nos hemos movido lentamente desde un ejemplo de personaje muy simple, moviendonos con flecha

59:09.110 --> 59:14.960
hasta el ejemplo avanzado separando lo que es Monocomportamiento y lo que no es Monocomportamiento.

59:14.960 --> 59:20.900
Y aquí en este vamos a hablar de lo que si dependemos de otro sistema de unidad como la física.

59:20.900 --> 59:26.720
Y también cuando estamos usando la física en este ejemplo en particular nuestro movimiento se vuelve más confuso.

59:26.720 --> 59:30.890
Lo que significa que no hago clic a la izquierda e inmediatamente hace clic en una posición.

59:30.890 --> 59:32.930
Se mueve lentamente con el tiempo.

59:32.930 --> 59:37.100
¿Cómo podríamos comprobar el valor que cambia lentamente con el tiempo?

59:37.100 --> 59:40.220
Así que vamos a hablar de algunas de esas cosas aquí en el código fuente.

59:40.220 --> 59:45.290
Así que para echar un vistazo a esta demo, vamos a abrir nuestro editor unity y el proyecto de ejemplo.

59:45.290 --> 59:48.020
La escena aquí va a ser la escena de física del personaje.

59:48.020 --> 59:51.720
Y una de las cosas que vamos a ver es cómo probar esos valores difusos.

59:51.740 --> 59:58.640
Lo llamé de nuevo, valores difusos para mí son valores que no son necesariamente instantáneos, cambiando de

59:58.640 --> 1:00:05.960
A a B, se animan lentamente con el tiempo, como la posición de un objeto o una puntuación que gradualmente

1:00:05.960 --> 1:00:06.890
cuenta hacia arriba.

1:00:06.920 --> 1:00:12.110
Estas son todas las áreas en las que usted querría ser capaz de probar algo en el tiempo, y tenemos un enfoque fácil

1:00:12.110 --> 1:00:13.250
aquí para hacer eso.

1:00:13.250 --> 1:00:17.750
No es la única forma de resolverlo, pero es una que creo que nos ayuda a aprender por el camino.

1:00:17.750 --> 1:00:18.770
Así que echemos un vistazo.

1:00:18.770 --> 1:00:20.420
Así que aquí estamos en el proyecto unity.

1:00:20.420 --> 1:00:22.940
Tenemos abierto el ejemplo de física de personajes.

1:00:22.940 --> 1:00:24.500
Vamos a ejecutar la escena.

1:00:30.610 --> 1:00:33.520
Ahora puedo moverme usando las flechas del teclado.

1:00:37.390 --> 1:00:42.970
Y en ejemplos anteriores aquí en el taller, hemos visto que hace clic sobre cada clic que hice a la izquierda

1:00:42.970 --> 1:00:48.430
flecha, la posición haría clic en cambiar instantáneamente, pero aquí hay un movimiento más suave.

1:00:49.060 --> 1:00:54.250
Todavía puedo utilizar todas las teclas de flecha para dirigir el tráfico diferente de la forma en que debe ir, pero la idea

1:00:54.250 --> 1:00:58.030
de que se mueve lentamente con el tiempo es realmente la nueva situación ahora.

1:00:58.030 --> 1:01:03.790
Hay un montón de maneras que usted podría hacer eso en la unidad, pero he optado por utilizar el sistema de física sólo para hablar

1:01:03.790 --> 1:01:08.920
un poco acerca de lo que sucede si tenemos un poco más de los sistemas de la unidad involucrados.

1:01:08.920 --> 1:01:10.960
¿Recuerdas con qué nos hemos estado estirando?

1:01:10.960 --> 1:01:18.130
Y como una idea aquí es que en un mundo ideal, usted consigue su unidad de pruebas para probar el menor número de líneas de

1:01:18.130 --> 1:01:21.760
dependencia, el menor número de líneas de código a la vez.

1:01:21.760 --> 1:01:25.600
Pero muchas veces nuestro código de producción no es tan simplista.

1:01:25.600 --> 1:01:27.520
Dependemos de cosas diferentes.

1:01:27.520 --> 1:01:33.370
Así que con mi cargador de datos y con ejemplos de caracteres anteriores aquí, hemos visto algunas de las formas de manejar

1:01:33.370 --> 1:01:35.080
esas diferentes dependencias.

1:01:35.200 --> 1:01:38.260
Este es otro ejemplo un poco más complejo que el resto.

1:01:38.290 --> 1:01:40.240
Echemos un vistazo al código de producción aquí.

1:01:40.240 --> 1:01:43.120
Veamos aquí el ejemplo de la física del personaje.

1:01:44.530 --> 1:01:45.790
¿Lo abrimos?

1:01:47.210 --> 1:01:50.570
Y aquí tenemos la creación de una primitiva de personaje.

1:01:51.320 --> 1:01:59.840
Aquí creamos primero el objeto de juego con el cubo en apariencia para la primitiva, y luego añadimos

1:01:59.840 --> 1:02:03.500
el componente del monocomportamiento físico del personaje.

1:02:03.500 --> 1:02:07.070
Y luego tenemos una clase separada de la física del personaje que tomamos allí.

1:02:07.070 --> 1:02:12.740
Así que ya estamos separando de una clase monolítica de mono-comportamiento en dos.

1:02:12.740 --> 1:02:18.350
Así que esa es una buena manera de conseguir nuestro código más simplista y hacer un solo propósito cada uno allí.

1:02:18.350 --> 1:02:25.640
Vimos en el ejemplo anterior que la mayor parte de la funcionalidad Monobehaviour que necesitábamos era sólo la actualización.

1:02:25.640 --> 1:02:27.680
Eso es lo único de lo que realmente necesitábamos ocuparnos.

1:02:27.710 --> 1:02:33.110
Así que moviendo todas las cosas no actualización en la segunda clase, ahora tenemos algo que es más fácil de

1:02:33.110 --> 1:02:33.740
probar.

1:02:36.450 --> 1:02:39.570
Entonces, en este sencillo ejemplo, nos movemos a una posición particular.

1:02:39.600 --> 1:02:43.710
Ahora ejecutemos las pruebas y echemos un vistazo al código de producción.

1:02:43.740 --> 1:02:46.500
Ahora echemos un vistazo a la ejecución de los seleccionados.

1:02:48.580 --> 1:02:49.830
Ahí está todo corriendo.

1:02:49.850 --> 1:02:50.850
Todo pasa.

1:02:50.870 --> 1:02:52.640
Ahora es sólo la prueba del modo de juego.

1:02:52.640 --> 1:02:57.110
Pero también tenemos pruebas de modo de edición si quieres profundizar y echar un vistazo de nuevo, porque estamos

1:02:57.110 --> 1:02:58.950
tratando con cosas de mono-comportamiento.

1:02:58.970 --> 1:03:01.340
Parece más apropiado usar un modo de reproducción.

1:03:01.340 --> 1:03:02.990
Así que ese es el enfoque que he hecho aquí.

1:03:02.990 --> 1:03:06.470
Pero depende de ti y de tu proyecto decidir qué sistemas quieres probar.

1:03:06.500 --> 1:03:08.230
Modo edición y cuáles quieres probar.

1:03:08.240 --> 1:03:08.840
Modo Play.

1:03:15.570 --> 1:03:21.000
Ahora que hemos visto estas pruebas, echemos un vistazo al código fuente de la clase.

1:03:21.000 --> 1:03:22.660
Y luego vamos a ver algunas de las pruebas en la parte superior.

1:03:22.710 --> 1:03:22.860
De acuerdo.

1:03:22.860 --> 1:03:24.780
Así que aquí estamos en la física del personaje.

1:03:24.810 --> 1:03:28.870
Vamos a ver que es bastante similar a la avanzada de carácter que vimos por última vez.

1:03:28.890 --> 1:03:32.850
De nuevo hemos separado la clase Monobehaviour de la que no lo es.

1:03:32.850 --> 1:03:36.630
Así que aquí está la clase no monocomportamiento que está haciendo la mayor parte del trabajo.

1:03:36.660 --> 1:03:42.840
Fíjate que dentro de su constructor toma una referencia al Monobehaviour y la almacena y luego

1:03:42.840 --> 1:03:47.670
también pasa a la Monobehaviour una referencia a esta clase aquí.

1:03:47.670 --> 1:03:51.900
Esto es para que pueda llamar al movimiento cada vez que hace una actualización.

1:03:51.930 --> 1:03:53.970
Ahora hay diferentes maneras de organizar eso.

1:03:53.970 --> 1:03:57.810
Incluso podrías eliminar la dependencia codificada que tenemos entre nosotros aquí.

1:03:57.810 --> 1:04:01.350
Pero en aras de la simplicidad en este ejemplo, esto es muy apropiado.

1:04:01.740 --> 1:04:02.790
Bajando el código.

1:04:02.790 --> 1:04:05.820
De nuevo, es como el avanzado en la mayoría de las partes.

1:04:05.850 --> 1:04:08.670
Quiero señalar dónde se usa la física.

1:04:08.670 --> 1:04:16.920
Así que aquí en el movimiento, en lugar de sólo mover por la posición hardcoded sobre una instancia Taneous actualización,

1:04:16.950 --> 1:04:20.340
vamos a utilizar la posición de movimiento aquí.

1:04:20.340 --> 1:04:25.890
Y luego en Añadir fuerza, que es un nuevo método que hice que se va a mover sobre la base de la física

1:04:25.890 --> 1:04:26.580
fuerzas.

1:04:26.580 --> 1:04:30.630
Así que imagina que esto es un bloque y estamos dando un empujón en un lado.

1:04:30.630 --> 1:04:36.390
Y luego basado en la fricción y la masa y la gravedad, usted sabe que hay algún tipo de consecuencia que tiende a

1:04:36.390 --> 1:04:39.240
a ser una reacción más borrosa aquí usando la fuerza de adición.

1:04:39.240 --> 1:04:45.570
Y nos estamos moviendo por add force aquí arriba en la parte superior del mismo archivo de clase vemos la física monobehaviour

1:04:45.600 --> 1:04:46.590
está declarado.

1:04:46.590 --> 1:04:52.560
Es bastante familiar en el sentido de que el mismo carácter avanzado que vimos en el último taller se parece bastante,

1:04:52.560 --> 1:04:55.350
pero tenemos un cuerpo rígido aquí que estamos almacenando.

1:04:55.350 --> 1:05:02.010
Y luego, cuando esta clase se despierta, hacemos algunos adjuntando del cuerpo rígido y, a continuación, establecer algunos física

1:05:02.010 --> 1:05:02.670
valores.

1:05:02.670 --> 1:05:09.450
Así que si pensamos en recapitular en lugar de tener un mono-comportamiento que haga toda la física

1:05:09.450 --> 1:05:14.220
y movimiento juntos, hemos separado el mono-comportamiento del no mono-comportamiento.

1:05:14.250 --> 1:05:20.520
Luego dentro del Monobehaviour hacemos el bucle de actualización y también nos encargamos de algunas cosas de física.

1:05:20.610 --> 1:05:26.550
A continuación, desde el otro, el no monobehaviour, somos capaces de movernos como queramos y tomar la entrada de caracteres,

1:05:26.580 --> 1:05:28.470
por lo que tomar la entrada de teclado y cosas por el estilo.

1:05:28.470 --> 1:05:32.940
Así que es una separación bastante buena aquí y nos pone en marcha con lo que necesitamos.

1:05:34.100 --> 1:05:37.820
Déjame pensar en voz alta si hay algo más que quiera mencionar sobre esto.

1:05:38.330 --> 1:05:40.430
Um, sí.

1:05:40.430 --> 1:05:42.620
Así que me burlé de la idea aquí.

1:05:42.620 --> 1:05:50.720
Si desea reducir la dependencia codificada que tenemos cada clase que dependen unos de otros y

1:05:50.720 --> 1:05:56.270
obtener más de la flexibilidad que vimos en el ejemplo de My Data loader, sin duda podría declarar

1:05:56.270 --> 1:05:58.670
interfaces y abordarlo de esa manera.

1:05:58.970 --> 1:06:00.680
Pero no necesitamos hacer eso aquí.

1:06:00.680 --> 1:06:03.370
Volveremos a ejecutar el ejemplo una vez más.

1:06:03.380 --> 1:06:07.700
Así que de vuelta aquí en unity estamos ejecutando y tenemos las teclas de flecha moviéndose alrededor.

1:06:07.730 --> 1:06:13.130
En los últimos vídeos hemos visto ejemplos de reducción de la complejidad.

1:06:13.130 --> 1:06:17.870
Así que reduciendo diferentes dependencias algo de flexibilidad para separar nuestro código.

1:06:17.870 --> 1:06:23.480
Así que por el bien de este ejemplo aquí utilizando la entrada y la física y monobehaviours o cosas por el estilo yo

1:06:23.480 --> 1:06:24.620
creo que ya hemos terminado.

1:06:24.650 --> 1:06:25.340
Gracias.

1:06:31.470 --> 1:06:31.730
Hola.

1:06:31.740 --> 1:06:37.470
Eso cubre muchos de los diferentes temas que quería tener en el taller hasta ahora, pero hay

1:06:37.470 --> 1:06:39.990
mucho espacio para más temas en el futuro.

1:06:39.990 --> 1:06:42.390
Hemos visto en los talleres cubiertos hasta ahora

1:06:42.390 --> 1:06:49.350
Este ejemplo más sencillo aprendiendo el ejecutor de pruebas, viendo cómo podemos hacer pruebas en modo reproducción, pruebas en modo edición,

1:06:49.380 --> 1:06:54.870
aprendiendo un poco sobre las diferencias entre modo reproducción y modo edición, y por qué querrías hacer pruebas

1:06:54.870 --> 1:06:57.350
en uno u otro, o en ambos.

1:06:57.360 --> 1:07:03.510
Luego también vimos algunas de las opciones que tenemos cuando tenemos funcionalidad asíncrona, o cuando estamos

1:07:03.510 --> 1:07:05.460
dependientes de otros sistemas.

1:07:05.460 --> 1:07:09.990
¿Qué podríamos hacer para reducir esa dependencia en beneficio de la prueba?

1:07:10.020 --> 1:07:15.180
A lo largo del camino, estamos aprendiendo algunas cosas diferentes acerca de la inyección de dependencia y la separación de

1:07:15.180 --> 1:07:16.650
las preocupaciones de nuestro código.

1:07:16.680 --> 1:07:22.710
Estos principios son útiles en el código de producción de todos modos, y estamos empezando a ver algunas de las maneras

1:07:22.710 --> 1:07:29.850
que cuando se prepara el código para ser más comprobable, también estamos creando código que está bien diseñado

1:07:29.850 --> 1:07:31.080
para la producción.

1:07:31.080 --> 1:07:37.710
Así que tener inyección de dependencias permite flexibilidad que puedes usar en tiempo de ejecución, reduciendo la complejidad

1:07:37.710 --> 1:07:44.370
de tus sistemas pasando variedades flexibles de diferentes dependencias cuando lo necesites.

1:07:44.400 --> 1:07:51.960
También hemos visto al separar un gran monocomportamiento monolítico en sólo lo que necesitamos del monocomportamiento

1:07:51.960 --> 1:07:58.620
y moviendo el resto del código a una clase más ligera que no sea monocomportamiento, obtenemos de nuevo cierta flexibilidad

1:07:58.620 --> 1:08:03.570
que es útil en la producción y también nos ayuda aquí en el mundo de las pruebas.

1:08:03.570 --> 1:08:10.170
Creo que en general algunos de los retos que estamos viendo son lo que sucede cuando se tienen múltiples dependencias

1:08:10.200 --> 1:08:14.670
o muchos sistemas llamados desde un método en particular.

1:08:15.060 --> 1:08:20.700
Eso podría ser una señal de que ese método está hinchado y haciendo demasiado, o podría ser una señal de que es

1:08:20.700 --> 1:08:23.130
un diseño delgado y apropiado.

1:08:23.130 --> 1:08:28.800
Pero necesitamos tener algunos pensamientos y consideraciones adicionales cuando vayamos a probar esa funcionalidad.

1:08:28.800 --> 1:08:31.050
Espero que esto te haya sido útil.

1:08:31.050 --> 1:08:38.130
Espero cubrir aún más temas en esta serie también, y se añadirán de nuevo en más de

1:08:38.130 --> 1:08:38.610
tiempo.

1:08:38.610 --> 1:08:39.750
Así que gracias de nuevo.
