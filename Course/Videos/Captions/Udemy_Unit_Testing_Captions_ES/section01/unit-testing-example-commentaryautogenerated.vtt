WEBVTT

00:02.920 --> 00:07.120
Demos un paso atrás y veamos rápidamente un ejemplo fundamental.

00:07.120 --> 00:09.100
Esto no es una prueba unitaria.

00:09.100 --> 00:16.270
Y esto representa una clase de unidad algo que yo consideraría código de producción es decir, no código de prueba.

00:16.270 --> 00:19.990
Y esto sería en tu quizás un juego de matemáticas.

00:19.990 --> 00:23.890
Es una clase muy simple de mi sistema matemático que hace dos cosas.

00:23.890 --> 00:26.140
Puede sumar y puede restar.

00:26.140 --> 00:27.820
Así que tenemos el método de suma.

00:27.820 --> 00:31.300
Fíjate que estoy pasando un entero int a y b.

00:31.300 --> 00:33.970
Los sumo y devuelvo ese valor.

00:33.970 --> 00:40.540
Ahora bien, si esto se utilizara en tu juego y quisieras estar seguro de que funciona fielmente, sólo tendrías que

00:40.540 --> 00:48.640
jugar tu juego y esperarías que la implementación de una operación de adición exitosa te diera en pantalla,

00:48.640 --> 00:50.500
resultados fáciles de juzgar.

00:50.500 --> 00:52.210
Pero ese no es siempre el caso.

00:52.210 --> 00:59.470
Tal vez esto es la adición de A y B y C por accidente, y usted podría no darse cuenta de que tal vez su sistema de puntuación

00:59.470 --> 01:05.470
está incrementando de 1 a 2 a 4 haciendo mal las matemáticas, y simplemente no te das cuenta.

01:05.500 --> 01:11.920
Lo bueno de añadir una prueba unitaria es que eres capaz de probar más situaciones de las que te puedes encontrar

01:11.920 --> 01:15.370
como jugador, y hacerlo de forma más sistemática.

01:15.370 --> 01:18.400
Vamos a echar un vistazo rápido a nuestra primera prueba de unidad.

01:18.400 --> 01:21.850
Y va a ser una prueba de unidad en la parte superior de este sistema aquí.

01:22.870 --> 01:25.540
Así que esta es una clase separada.

01:25.540 --> 01:31.060
Y poniendo la base de código aquí, estamos viendo en un lugar determinado en su proyecto.

01:31.060 --> 01:36.600
Y marcando el método como muestra la flecha con test, unity lo tratará un poco diferente.

01:36.610 --> 01:42.880
Esto no tiene que ser llamado en cualquier lugar dentro de su código de producción, pero mira lo fácil que es dentro de

01:42.880 --> 01:43.570
en el cuerpo.

01:43.570 --> 01:49.960
Aquí vemos que estamos usando la metodología arrange, act y assert, y profundizaremos en esa metodología

01:49.960 --> 01:50.380
allí.

01:50.380 --> 01:53.950
Es un enfoque opcional que simplemente te ayuda a organizar tus pensamientos.

01:53.950 --> 01:56.380
Así que primero creamos una instancia de la clase.

01:56.380 --> 01:59.020
Luego llamamos a un método de esa clase.

01:59.020 --> 02:04.990
Y entonces afirmamos o asumimos que este va a ser nuestro resultado esperado.

02:05.020 --> 02:12.010
Ahora esta prueba pasará si la afirmación es correcta y fallará si la afirmación es incorrecta.

02:12.040 --> 02:18.820
Ahora, puede parecer una tontería pasar cinco y diez y comprobar que cumple 15, porque de nuevo, nuestra implementación

02:18.820 --> 02:20.110
código es tan simple.

02:20.110 --> 02:26.080
Pero estas son las ideas fundamentales que cuando las aplicamos a clases aún más grandes, va a ser

02:26.080 --> 02:26.800
importante.

02:26.920 --> 02:28.900
Este es el resumen de nuestro curso.

02:28.900 --> 02:31.240
Pensemos en lo que hemos aprendido aquí.

02:31.240 --> 02:35.980
Hemos hablado un poco sobre cómo y por qué las pruebas unitarias son importantes para un proyecto.

02:35.980 --> 02:39.640
He insinuado un poco acerca de por qué es bastante raro en el desarrollo de juegos.

02:39.670 --> 02:45.490
Una de las razones es que nosotros, como desarrolladores de juegos, nos encanta añadir nuevas características, y esto se siente un poco

02:45.490 --> 02:48.070
que nos ralentiza.

02:48.070 --> 02:53.500
Pero cuando nos fijamos en que 80 sobre 20 regla, vemos, ya sabes, estamos bastante sorprendidos de que en realidad

02:53.500 --> 02:59.800
la mayor parte de nuestra vida como desarrolladores de juegos se gasta en la fijación y el mantenimiento de las características existentes, no en la adición de

02:59.800 --> 03:00.490
nuevas.

03:00.490 --> 03:07.420
Así que reconocer eso y ver que las pruebas unitarias nos ayudarán a crear esas nuevas características, así como

03:07.420 --> 03:13.630
darnos mucha más confianza en el código en el 80% del mantenimiento que estamos gastando en nuestro proyecto.

03:13.630 --> 03:19.210
Te va a reportar beneficios fácilmente como desarrollador de juegos, y es una habilidad maravillosa de aprender.

03:19.210 --> 03:20.500
Así que vamos a empezar.
