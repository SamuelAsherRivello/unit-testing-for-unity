WEBVTT

00:03.320 --> 00:08.780
Recapitulemos algunos de los beneficios que hemos visto hasta ahora sólo en esta parte teórica sobre las pruebas unitarias.

00:08.780 --> 00:11.940
Así que los beneficios incluyen la adición de confianza a su código.

00:11.960 --> 00:12.830
¿Qué significa esto?

00:12.830 --> 00:19.070
Significa que cuando tu equipo piense en ese código base, tendrá la feliz sensación de que ese 101

00:19.070 --> 00:21.080
característica no romperá las cosas.

00:21.110 --> 00:26.060
Cuando hay una falta de confianza, eres un poco tímido para añadir características, particularmente en ciertas áreas

00:26.060 --> 00:32.300
de la base de código donde sabes que las cosas se mantienen unidas con bastante holgura y una nueva línea de código podría

00:32.330 --> 00:33.320
romper algo.

00:33.320 --> 00:36.080
También permite refactorizaciones más audaces.

00:36.080 --> 00:41.270
Ahora, por ejemplo, si vas a refactorizar un sistema particular en tu juego y tienes

00:41.270 --> 00:46.040
ninguna prueba, el proceso sería jugar el juego y hacer que tu equipo lo juegue.

00:46.070 --> 00:49.880
Hacer todo el trabajo de refactorización, y luego volver a jugar.

00:49.910 --> 00:53.690
El problema con esas pruebas manuales es que consumen más tiempo.

00:53.690 --> 00:59.960
Es más difícil estar seguro de que la prueba antes y después de la refactorización son las mismas, y las pruebas

00:59.960 --> 01:02.450
las mismas áreas también.

01:02.990 --> 01:10.340
Así que teniendo algunas pruebas unitarias que cubran esos sistemas antes de la refactorización, eres capaz de ejecutar las pruebas,

01:10.370 --> 01:14.960
ver que todo pasa, que la automatización que has tenido allí funciona bien.

01:14.960 --> 01:18.350
A continuación, ejecuta exactamente las mismas pruebas después de la refactorización.

01:18.380 --> 01:21.650
Puede que encuentres por el camino que algunas de las pruebas fallan.

01:21.650 --> 01:23.390
Puedes hacer algunos cambios.

01:23.390 --> 01:24.380
La prueba pasa.

01:24.380 --> 01:30.860
Usted puede incluso añadir nuevas pruebas porque la refactorización las necesita, y entonces su código ahora se encuentra en un incluso

01:30.860 --> 01:34.130
mejor lugar con más confianza en el código después de esa refactorización.

01:34.310 --> 01:36.170
Esto también ahorra tiempo.

01:36.170 --> 01:41.480
Se sentirá cuando usted está comenzando con la unidad de pruebas que se trata de un extra, tal vez incluso.

01:41.480 --> 01:45.950
Se siente un poco innecesario en ciertos sistemas, pero vamos a estirar en eso.

01:45.950 --> 01:51.650
Vamos a trabajar en esa área y ver cómo y cuándo desea agregar sus pruebas unitarias.

01:51.680 --> 01:56.810
Cada desarrollador encontrará su propio estilo, y como equipo, querréis uniros y establecer unas

01:56.810 --> 01:59.000
buenas prácticas que todos puedan seguir.

01:59.980 --> 02:04.720
Los resultados aquí, tendrás más confianza y solidez en tu base de código, como he mencionado,

02:04.720 --> 02:10.450
y el efecto en su base de código no es sólo que es el mismo viejo código con las pruebas.

02:10.480 --> 02:15.040
Es que la propia naturaleza de las pruebas influirá en cómo diseñas tu código.

02:15.070 --> 02:22.360
Para hacer código testeable, las cosas tienen que funcionar en unidades más pequeñas o clases más pequeñas con menos código en ellas,

02:22.360 --> 02:27.550
y eso nos anima a tener un único propósito para cada clase y método, que es una buena práctica de diseño.

02:27.550 --> 02:30.010
Lo veremos en la sección de diseño de software.

02:30.010 --> 02:34.630
También fomenta soluciones más simples, especialmente cuando hablamos de desarrollo dirigido por pruebas.

02:34.660 --> 02:41.290
Ahora bien, tener esta prueba automatizada, lo que significa pruebas unitarias como parte de su base de código que son automáticamente

02:41.290 --> 02:47.760
llamadas y reintentadas periódicamente, eso es lo que realmente te va a dar el mejor beneficio aquí.

02:47.770 --> 02:54.100
Ahora, algunos equipos utilizarán la unidad de pruebas dentro de la unidad, que va a ser el foco de nuestra charla

02:54.100 --> 02:54.550
aquí.

02:54.550 --> 03:02.230
También puede tomar esa habilidad y hacer que su repositorio git u otro sistema de control de versiones ejecute automáticamente

03:02.230 --> 03:09.280
esas pruebas en momentos clave, tal vez todos los días o todas las noches, o cada vez que su equipo se compromete a un determinado

03:09.280 --> 03:11.260
rama, se ejecutará la prueba de nuevo.

03:11.260 --> 03:17.110
Así que hay maneras elegantes que usted puede aumentar la frecuencia a la que esto se llama, y luego sólo

03:17.110 --> 03:20.020
fusionar tu código si todas las pruebas pasan.
