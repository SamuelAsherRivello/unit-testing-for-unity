WEBVTT

00:02.840 --> 00:04.730
¿Por qué hacer pruebas unitarias?

00:04.880 --> 00:06.200
Me gusta empezar con esta cita.

00:06.200 --> 00:07.050
La leeré aquí.

00:07.070 --> 00:14.150
Cada decisión que tomamos, ya sea sobre tecnología, procesos o personas, puede considerarse una forma de inversión.

00:14.510 --> 00:19.040
Estas inversiones tienen un coste y confiamos en que darán sus frutos.

00:19.250 --> 00:24.950
Así que si ya estás familiarizado con el desarrollo de juegos y eres capaz de conseguir algunas de las funcionalidades

00:24.950 --> 00:29.480
que tienes en tu mente en los proyectos y compartirlos con los jugadores que están jugando su juego,

00:29.480 --> 00:32.520
puede que no esté muy claro cuál es el valor de las pruebas unitarias.

00:32.540 --> 00:38.060
Las pruebas unitarias deben ser consideradas, en primer lugar, como una actividad opcional que se puede añadir a la parte superior.

00:38.060 --> 00:39.640
a tu código de producción.

00:39.650 --> 00:47.210
En cierto modo, tus usuarios finales nunca verán esa funcionalidad, pero la idea y los beneficios que se derivan de

00:47.210 --> 00:53.960
pruebas unitarias, en particular el desarrollo dirigido por pruebas, esperamos que nos dará una recompensa por esa inversión.

00:53.990 --> 01:01.010
Tendremos clases y sistemas que funcionen de forma más fiable, que sean más robustos, pero que sean

01:01.010 --> 01:08.330
menos propensos a errores y que te permitirán añadir más funciones para tus usuarios de forma más rápida y segura.

01:08.330 --> 01:11.670
con las pruebas unitarias como una de tus habilidades.

01:11.690 --> 01:15.190
Ahora, en este mundo de pruebas unitarias, hay muchos términos diferentes.

01:15.200 --> 01:18.320
Algunos de los que vemos aquí, sólo leeré un par de ellos.

01:18.320 --> 01:23.660
Composición y abstracción, refiriéndose a la forma en que tus clases y tus arquitecturas pueden encajar

01:23.660 --> 01:24.470
juntas.

01:24.710 --> 01:29.120
Las clases y los métodos son los fundamentos de la programación orientada a objetos.

01:29.120 --> 01:34.630
Luego cosas como mock y assertion y range act y assert también.

01:34.640 --> 01:37.850
Estas son cosas que se refieren específicamente a las pruebas unitarias.

01:37.850 --> 01:42.500
Vamos a cubrir de una manera informal, todos los términos que vemos aquí.

01:42.500 --> 01:44.810
Probablemente los cubriremos ahora en este último.

01:44.810 --> 01:46.040
Desarrollo profesional.

01:46.040 --> 01:52.010
Cuando empiezas como desarrollador de juegos dentro de unity, aprendiendo la herramienta unity, aprendiendo la teoría

01:52.010 --> 01:56.840
detrás de unity y por supuesto la codificación en C-sharp, te das cuenta de que te estás graduando.

01:56.840 --> 02:01.700
Los conceptos son cada vez más complejos a medida que avanzas en los diferentes temas.

02:01.730 --> 02:06.050
Cosas como las clases en programación orientada a objetos, que se aprenden al principio del desarrollo.

02:06.050 --> 02:13.340
Más adelante en tu carrera, te centrarás más en conseguir que tus proyectos sean más modulares, reutilizables, añadiendo

02:13.370 --> 02:18.800
pruebas, que es el núcleo aquí, y luego hablar en gran medida acerca de la arquitectura de sus proyectos.

02:18.830 --> 02:25.460
Un signo de un proyecto con una buena arquitectura es aquel en el que cuando añades la característica 101, ésta no

02:25.460 --> 02:26.900
rompa todo lo demás que tienes.

02:26.930 --> 02:33.050
Ahora, aquí vemos un posible camino de un desarrollador junior moviéndose a través de una carrera.

02:33.050 --> 02:38.600
Y es particularmente interesante que las habilidades que estamos hablando aquí son realmente lo que se mueve

02:38.600 --> 02:42.890
de un desarrollador principiante a un junior a un senior.

02:42.890 --> 02:49.070
Es realmente este tipo de conocimiento práctico que estás añadiendo a tu conjunto de habilidades lo que te ayudará a

02:49.070 --> 02:55.040
conseguir un ascenso en tu puesto actual, o encontrar nuevas funciones y oportunidades para contribuir en otros campos.

02:55.040 --> 02:55.790
equipos.

02:55.820 --> 03:02.030
Ahora, no todos los equipos utilizan pruebas unitarias en el mundo de la programación, y creo que particularmente en el desarrollo de juegos,

03:02.030 --> 03:07.670
no lo encuentras tan a menudo como lo haces con otras plataformas de programación y paradigmas, pero es

03:07.670 --> 03:08.870
igual de importante aquí.

03:08.870 --> 03:11.150
Veamos por qué las pruebas unitarias son importantes.

03:11.150 --> 03:12.460
Voy a leer aquí.

03:12.470 --> 03:19.100
A medida que tu proyecto crece con más scripts, clases y métodos, se hace difícil para ti asegurar

03:19.100 --> 03:23.810
que un cambio en una parte de tu código no rompe algo en otra parte.

03:23.900 --> 03:28.850
Las pruebas automatizadas te ayudan a comprobar que tu código funciona según lo esperado.

03:29.150 --> 03:35.870
Las pruebas ahorran tiempo al encontrar dónde y cuándo se producen los problemas tan pronto como se introducen en el desarrollo,

03:35.870 --> 03:42.290
en lugar de confiar en las pruebas manuales, o incluso la más costosa espera de sus usuarios finales, su

03:42.290 --> 03:47.030
jugadores del juego para informar de un error, vamos a hablar un poco sobre el valor de encontrar sus errores temprano.

03:47.030 --> 03:54.410
Muchos desarrolladores pensamos que el proceso de desarrollo de un juego consiste en añadir nuevas características.

03:54.410 --> 03:59.540
y que cuanto más rápido las añades, más valor ofreces a tus usuarios finales.

03:59.570 --> 04:05.300
Ahora bien, aunque esa es una forma divertida de empezar un proyecto, todos conocemos los resultados que se obtienen al añadir características

04:05.300 --> 04:13.160
demasiado rápido en el desarrollo temprano, especialmente en la parte superior de una base de código que no está bien diseñado, bien arquitecturado

04:13.160 --> 04:14.210
o bien probado.

04:14.210 --> 04:21.620
Lo que la investigación en la industria del desarrollo de juegos muestra es algo de la regla 80 sobre 20 que el 80% de

04:21.620 --> 04:25.250
errores de desarrollo provienen de sólo el 20% de sus características.

04:25.250 --> 04:29.780
La complejidad del núcleo a menudo se encuentra en una esquina estrecha de la base de código.

04:29.780 --> 04:36.080
El proyecto, la organización o la falta de ella pueden causar tremendos problemas recurrentes.

04:36.110 --> 04:42.050
Terminas luchando contra los mismos viejos incendios una y otra vez, porque no tienes el diseño y la

04:42.050 --> 04:46.070
pruebas que demuestren que esa zona está desarrollada con seguridad.

04:47.120 --> 04:49.770
El 80% del tiempo de desarrollo es mantenimiento de código.

04:49.790 --> 04:55.190
Ahora que es una cosa aterradora de escuchar, pero esto es lo que vemos en grandes bases de código.

04:55.220 --> 05:01.100
Imagina lanzar un juego en seis meses y darle soporte durante 1 o 2 años más mientras estás con los bugs.

05:01.100 --> 05:03.210
y añadiendo nuevas características.

05:03.230 --> 05:05.800
Ese es un ejemplo de un juego muy simple.

05:05.810 --> 05:12.020
Incluso en ese proceso, encontramos que el 80% del tiempo que pasas en un desarrollador no es añadiendo esas

05:12.020 --> 05:12.890
nuevas características.

05:12.890 --> 05:20.030
Es reducir y encontrar errores en los sistemas antiguos y hacer refactorizaciones como los primeros seis meses.

05:20.060 --> 05:24.050
La arquitectura puede no encajar en los segundos seis meses de arquitectura.

05:24.080 --> 05:29.300
Tu proyecto va a crecer y tu equipo va a aprender, así que vas a estar haciendo cambios

05:29.300 --> 05:30.150
a lo largo del camino.

05:30.170 --> 05:31.430
Sin problemas.

05:31.460 --> 05:33.950
Estos cambios a menudo se llaman refactorización.

05:33.950 --> 05:39.860
Refactorizar es hacer tu código más eficiente y ofrecer el mismo valor a tus consumidores finales.

05:39.890 --> 05:45.530
Cada refactorización te permite tener un nuevo punto de partida para añadir nuevas características.

05:45.530 --> 05:52.460
Así que lo que vemos aquí es que mediante el establecimiento de buenas prácticas de hacer pruebas, que va a ayudar a que

05:52.460 --> 05:56.450
mantenimiento del código, que va a ayudar a que el 80% donde pasamos mucho de nuestro tiempo.

05:56.450 --> 06:02.480
Y como he aludido antes, echemos un vistazo aquí que el coste de los errores de software aumenta con el tiempo.

06:02.480 --> 06:08.420
Ahora, esta porción particular de la investigación muestra que si estás conversando con un colega sobre

06:08.420 --> 06:13.250
una característica del juego, y uno de ustedes señala algo que puede ser un problema, lo están arreglando en,

06:13.280 --> 06:15.420
esa conversación es super barata.

06:15.440 --> 06:22.340
Llamemos a eso una x cantidad de tiempo y esfuerzo muy bajo a medida que avanzas y lo implementas

06:22.340 --> 06:28.430
proyecto, encontrar ese mismo error después de haber codificado, es más difícil de encontrar y más difícil

06:28.430 --> 06:30.860
arreglarlo y asegurarte de que lo arreglas.

06:30.860 --> 06:36.860
Bueno, una vez que has hecho las pruebas, se lo pasas a tus clientes para que lo prueben y luego lo envías...

06:36.860 --> 06:38.400
a los jugadores finales.

06:38.420 --> 06:41.000
Imagina que un jugador se encuentra con el mismo problema.

06:41.030 --> 06:44.330
Tendrán que estar decepcionados por ello.

06:44.330 --> 06:47.510
Tal vez eso afecte negativamente a lo que piensan del juego.

06:47.510 --> 06:50.060
Puede que incluso los pierda como jugadores del juego.

06:50.060 --> 06:55.400
Pero si son una persona vocal y tienes un buen canal de atención al cliente y te lo envían,

06:55.430 --> 07:00.950
va a tu sistema de tickets de errores, eventualmente se asigna, eventualmente se arregla, tal vez

07:00.950 --> 07:06.950
es o no es corregido correctamente, y luego envías esa actualización a los usuarios finales, con la esperanza de que ese usuario

07:06.980 --> 07:08.270
de ese usuario.

07:08.300 --> 07:09.590
Es mucho más caro.

07:09.590 --> 07:10.210
Al final.

07:10.220 --> 07:15.480
Veremos que las pruebas unitarias nos permiten, en primer lugar, diseñar mejor nuestro software.

07:15.500 --> 07:22.550
En segundo lugar, poner pruebas en nuestro proyecto para que estas pruebas automatizadas encuentren antes ese fallo.

07:22.550 --> 07:28.130
Tal vez en la etapa de integración, como estamos viendo aquí, no es tan bueno como arreglarlo en esa primera

07:28.130 --> 07:32.240
conversación, pero es mucho mejor que esperar a que el proyecto sea liberado.

07:32.480 --> 07:38.090
Así que algunas de las mejores prácticas que se destacan aquí son la creación de código mantenible, aumentando

07:38.090 --> 07:44.150
la automatización y las pruebas que tiene en su código, la captura de sus errores temprano y con frecuencia, y la fijación de esos

07:44.150 --> 07:46.490
errores antes de añadir nuevas características.
